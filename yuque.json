[
  {
    "id": 60703923,
    "slug": "xw7sl8",
    "title": "博客模板",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "categories: '随笔'<br />tags: '随笔'\n\n---\n\n每一行代码，都是美丽的诗句。<br /><!-- more -->\n",
    "body_html": "",
    "body_lake": "",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"ufdfc8943\" id=\"ufdfc8943\"><span data-lake-id=\"udcecf414\" id=\"udcecf414\">categories: '随笔'</span></p><p data-lake-id=\"ue5123036\" id=\"ue5123036\"><span data-lake-id=\"u3e5336d8\" id=\"u3e5336d8\">tags: '随笔'</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22he9lQ%22%7D\"></card><p data-lake-id=\"u21e002df\" id=\"u21e002df\"><span data-lake-id=\"u7dceb869\" id=\"u7dceb869\">每一行代码，都是美丽的诗句。</span></p><p data-lake-id=\"u0bfc10d6\" id=\"u0bfc10d6\"><span data-lake-id=\"uc3869b8c\" id=\"uc3869b8c\">&lt;!-- more --&gt;</span></p>",
    "public": 1,
    "status": 0,
    "view_status": 0,
    "read_status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-11-18T05:36:52.000Z",
    "deleted_at": null,
    "created_at": "2021-11-18T05:36:52.000Z",
    "updated_at": "2021-11-18T05:36:52.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": null,
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 60703208,
    "slug": "bdigug",
    "title": "java的虚拟机",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: '技术'<br />tags: 'java'<br />cover: <br />description: test\n\n---\n\n<!-- 简介 --><br />每一行代码，都是美丽的诗句。<br /><!-- more -->\n<a name=\"GJY2B\"></a>\n# 名称\njava 虚拟的优化\n<a name=\"XfT0g\"></a>\n# 原因\njava虚拟机的不好\n",
    "body_draft": "categories: '技术'<br />tags: 'java'<br />cover: <br />description: test\n\n---\n\n<!-- 简介 --><br />每一行代码，都是美丽的诗句。<br /><!-- more -->\n<a name=\"GJY2B\"></a>\n# 名称\njava 虚拟的优化\n<a name=\"XfT0g\"></a>\n# 原因\njava虚拟机的不好\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"ufdfc8943\" class=\"ne-p\"><span class=\"ne-text\">categories: '技术'</span></p><p id=\"ue5123036\" class=\"ne-p\"><span class=\"ne-text\">tags: 'java'</span></p><p id=\"ua6f7ee13\" class=\"ne-p\"><span class=\"ne-text\">cover: </span></p><p id=\"u228f5256\" class=\"ne-p\"><span class=\"ne-text\">description: test</span></p><hr id=\"he9lQ\" class=\"ne-hr\"><p id=\"ue1432a9f\" class=\"ne-p\"><span class=\"ne-text\">&lt;!-- 简介 --&gt;</span></p><p id=\"u21e002df\" class=\"ne-p\"><span class=\"ne-text\">每一行代码，都是美丽的诗句。</span></p><p id=\"u0bfc10d6\" class=\"ne-p\"><span class=\"ne-text\">&lt;!-- more --&gt;</span></p><h1 id=\"GJY2B\"><span class=\"ne-text\">名称</span></h1><p id=\"u137dc61c\" class=\"ne-p\"><span class=\"ne-text\">java 虚拟的优化</span></p><h1 id=\"XfT0g\"><span class=\"ne-text\">原因</span></h1><p id=\"u86f789e6\" class=\"ne-p\"><span class=\"ne-text\">java虚拟机的不好</span></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"ufdfc8943\" id=\"ufdfc8943\"><span data-lake-id=\"udcecf414\" id=\"udcecf414\">categories: '技术'</span></p><p data-lake-id=\"ue5123036\" id=\"ue5123036\"><span data-lake-id=\"u3e5336d8\" id=\"u3e5336d8\">tags: 'java'</span></p><p data-lake-id=\"ua6f7ee13\" id=\"ua6f7ee13\"><span data-lake-id=\"u59d54b7c\" id=\"u59d54b7c\">cover: </span></p><p data-lake-id=\"u228f5256\" id=\"u228f5256\"><span data-lake-id=\"u737e3c10\" id=\"u737e3c10\">description: test</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22he9lQ%22%7D\"></card><p data-lake-id=\"ue1432a9f\" id=\"ue1432a9f\"><span data-lake-id=\"uc8cb6aa5\" id=\"uc8cb6aa5\">&lt;!-- 简介 --&gt;</span></p><p data-lake-id=\"u21e002df\" id=\"u21e002df\"><span data-lake-id=\"u7dceb869\" id=\"u7dceb869\">每一行代码，都是美丽的诗句。</span></p><p data-lake-id=\"u0bfc10d6\" id=\"u0bfc10d6\"><span data-lake-id=\"uc3869b8c\" id=\"uc3869b8c\">&lt;!-- more --&gt;</span></p><h1 data-lake-id=\"GJY2B\" id=\"GJY2B\"><span data-lake-id=\"uf331818e\" id=\"uf331818e\">名称</span></h1><p data-lake-id=\"u137dc61c\" id=\"u137dc61c\"><span data-lake-id=\"u4298a55a\" id=\"u4298a55a\">java 虚拟的优化</span></p><h1 data-lake-id=\"XfT0g\" id=\"XfT0g\"><span data-lake-id=\"uab03cf0b\" id=\"uab03cf0b\">原因</span></h1><p data-lake-id=\"u86f789e6\" id=\"u86f789e6\"><span data-lake-id=\"ubbd5048f\" id=\"ubbd5048f\">java虚拟机的不好</span></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"ufdfc8943\" id=\"ufdfc8943\"><span data-lake-id=\"udcecf414\" id=\"udcecf414\">categories: '技术'</span></p><p data-lake-id=\"ue5123036\" id=\"ue5123036\"><span data-lake-id=\"u3e5336d8\" id=\"u3e5336d8\">tags: 'java'</span></p><p data-lake-id=\"ua6f7ee13\" id=\"ua6f7ee13\"><span data-lake-id=\"u59d54b7c\" id=\"u59d54b7c\">cover: </span></p><p data-lake-id=\"u228f5256\" id=\"u228f5256\"><span data-lake-id=\"u737e3c10\" id=\"u737e3c10\">description: test</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22he9lQ%22%7D\"></card><p data-lake-id=\"ue1432a9f\" id=\"ue1432a9f\"><span data-lake-id=\"uc8cb6aa5\" id=\"uc8cb6aa5\">&lt;!-- 简介 --&gt;</span></p><p data-lake-id=\"u21e002df\" id=\"u21e002df\"><span data-lake-id=\"u7dceb869\" id=\"u7dceb869\">每一行代码，都是美丽的诗句。</span></p><p data-lake-id=\"u0bfc10d6\" id=\"u0bfc10d6\"><span data-lake-id=\"uc3869b8c\" id=\"uc3869b8c\">&lt;!-- more --&gt;</span></p><h1 data-lake-id=\"GJY2B\" id=\"GJY2B\"><span data-lake-id=\"uf331818e\" id=\"uf331818e\">名称</span></h1><p data-lake-id=\"u137dc61c\" id=\"u137dc61c\"><span data-lake-id=\"u4298a55a\" id=\"u4298a55a\">java 虚拟的优化</span></p><h1 data-lake-id=\"XfT0g\" id=\"XfT0g\"><span data-lake-id=\"uab03cf0b\" id=\"uab03cf0b\">原因</span></h1><p data-lake-id=\"u86f789e6\" id=\"u86f789e6\"><span data-lake-id=\"ubbd5048f\" id=\"ubbd5048f\">java虚拟机的不好</span></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-11-18T05:42:52.000Z",
    "deleted_at": null,
    "created_at": "2021-11-18T05:25:59.000Z",
    "updated_at": "2021-11-18T05:42:52.000Z",
    "published_at": "2021-11-18T05:42:52.000Z",
    "first_published_at": "2021-11-18T05:28:30.000Z",
    "word_count": 50,
    "cover": null,
    "description": "categories: '技术'tags: 'java'cover: description: test<!-- 简介 -->每一行代码，都是美丽的诗句。<!-- more -->名称java 虚拟的优化原因java虚拟机的不好",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 57326427,
    "slug": "oxs3xw",
    "title": "技术",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "![](https://cdn.nlark.com/yuque/0/2021/jpeg/86384/1637128365460-352ce440-eea4-4092-8090-65c63c71bd6d.jpeg#id=dD1Co&originHeight=5750&originWidth=3648&originalType=binary&ratio=1&status=done&style=none)\n",
    "body_draft": "![](https://cdn.nlark.com/yuque/0/2021/jpeg/86384/1637128365460-352ce440-eea4-4092-8090-65c63c71bd6d.jpeg#id=dD1Co&originHeight=5750&originWidth=3648&originalType=binary&ratio=1&status=done&style=none)\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u67440984\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2021/jpeg/86384/1637128365460-352ce440-eea4-4092-8090-65c63c71bd6d.jpeg\" width=\"3648\" id=\"dD1Co\" class=\"ne-image\"></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u67440984\" id=\"u67440984\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fjpeg%2F86384%2F1637128365460-352ce440-eea4-4092-8090-65c63c71bd6d.jpeg%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22_blank%22%2C%22originWidth%22%3A3648%2C%22originHeight%22%3A5750%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22id%22%3A%22dD1Co%22%7D\"></card></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u67440984\" id=\"u67440984\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fjpeg%2F86384%2F1637128365460-352ce440-eea4-4092-8090-65c63c71bd6d.jpeg%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22_blank%22%2C%22originWidth%22%3A3648%2C%22originHeight%22%3A5750%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22id%22%3A%22dD1Co%22%7D\"></card></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-11-17T05:52:55.000Z",
    "deleted_at": null,
    "created_at": "2021-11-12T11:38:39.000Z",
    "updated_at": "2021-11-17T05:52:55.000Z",
    "published_at": "2021-11-17T05:52:55.000Z",
    "first_published_at": "2021-11-12T11:39:57.000Z",
    "word_count": 0,
    "cover": "https://cdn.nlark.com/yuque/0/2021/jpeg/86384/1637128365460-352ce440-eea4-4092-8090-65c63c71bd6d.jpeg",
    "description": "",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 56976810,
    "slug": "gcsgvr",
    "title": "三大难",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "重构 <br />​\n\n改造和优化<br />迁移\n",
    "body_draft": "重构 <br />​\n\n改造和优化<br />迁移\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"uc9b34c43\" class=\"ne-p\"><span class=\"ne-text\">重构 </span></p><p id=\"u266d5c76\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u63f7a834\" class=\"ne-p\"><span class=\"ne-text\">改造和优化</span></p><p id=\"uaeaad2fc\" class=\"ne-p\"><span class=\"ne-text\">迁移</span></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"uc9b34c43\" id=\"uc9b34c43\"><span data-lake-id=\"u60cc3d0a\" id=\"u60cc3d0a\">重构 </span></p><p data-lake-id=\"u266d5c76\" id=\"u266d5c76\"><span data-lake-id=\"u3fdb2f90\" id=\"u3fdb2f90\">​</span><br></p><p data-lake-id=\"u63f7a834\" id=\"u63f7a834\"><span data-lake-id=\"u919b2982\" id=\"u919b2982\">改造和优化</span></p><p data-lake-id=\"uaeaad2fc\" id=\"uaeaad2fc\"><span data-lake-id=\"u1529ef3b\" id=\"u1529ef3b\">迁移</span></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"uc9b34c43\" id=\"uc9b34c43\"><span data-lake-id=\"u60cc3d0a\" id=\"u60cc3d0a\">重构 </span></p><p data-lake-id=\"u266d5c76\" id=\"u266d5c76\"><span data-lake-id=\"u3fdb2f90\" id=\"u3fdb2f90\">​</span><br></p><p data-lake-id=\"u63f7a834\" id=\"u63f7a834\"><span data-lake-id=\"u919b2982\" id=\"u919b2982\">改造和优化</span></p><p data-lake-id=\"uaeaad2fc\" id=\"uaeaad2fc\"><span data-lake-id=\"u1529ef3b\" id=\"u1529ef3b\">迁移</span></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-11-17T05:50:37.000Z",
    "deleted_at": null,
    "created_at": "2021-11-08T08:45:12.000Z",
    "updated_at": "2021-11-17T05:50:38.000Z",
    "published_at": "2021-11-17T05:50:37.000Z",
    "first_published_at": "2021-11-08T08:45:30.000Z",
    "word_count": 9,
    "cover": null,
    "description": "重构 改造和优化迁移",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 56976789,
    "slug": "bbmzgk",
    "title": "前端",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "[https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw](https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw)<br />[https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack](https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack)<br />[https://www.yuque.com/mdh/weekly/fq162w](https://www.yuque.com/mdh/weekly/fq162w)<br />[https://modernjs.dev/](https://modernjs.dev/)<br />[https://ourai.ws/](https://ourai.ws/)<br />[https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw](https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw)<br />[https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w](https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w)<br />[https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A](https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A)<br />[https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&mid=2247484566&idx=1&sn=9dcd1d99df1aeef9e14b8fc8315c08dd&chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&token=678376780&lang=zh_CN#rd](https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&mid=2247484566&idx=1&sn=9dcd1d99df1aeef9e14b8fc8315c08dd&chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&token=678376780&lang=zh_CN#rd)<br />​\n\n[https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io](https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)<br />​\n\n",
    "body_draft": "[https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw](https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw)<br />[https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack](https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack)<br />[https://www.yuque.com/mdh/weekly/fq162w](https://www.yuque.com/mdh/weekly/fq162w)<br />[https://modernjs.dev/](https://modernjs.dev/)<br />[https://ourai.ws/](https://ourai.ws/)<br />[https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw](https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw)<br />[https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w](https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w)<br />[https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A](https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A)<br />[https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&mid=2247484566&idx=1&sn=9dcd1d99df1aeef9e14b8fc8315c08dd&chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&token=678376780&lang=zh_CN#rd](https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&mid=2247484566&idx=1&sn=9dcd1d99df1aeef9e14b8fc8315c08dd&chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&token=678376780&lang=zh_CN#rd)<br />​\n\n[https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io](https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&utm_campaign=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)<br />​\n\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u468fb7e5\" class=\"ne-p\"><a href=\"https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw\" data-href=\"https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw</span></a></p><p id=\"u45274de4\" class=\"ne-p\"><a href=\"https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack\" data-href=\"https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack</span></a></p><p id=\"uc6735c5b\" class=\"ne-p\"><a href=\"https://www.yuque.com/mdh/weekly/fq162w\" data-href=\"https://www.yuque.com/mdh/weekly/fq162w\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://www.yuque.com/mdh/weekly/fq162w</span></a></p><p id=\"u11779a97\" class=\"ne-p\"><a href=\"https://modernjs.dev/\" data-href=\"https://modernjs.dev/\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://modernjs.dev/</span></a></p><p id=\"u909d200a\" class=\"ne-p\"><a href=\"https://ourai.ws/\" data-href=\"https://ourai.ws/\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://ourai.ws/</span></a></p><p id=\"uddbf0044\" class=\"ne-p\"><a href=\"https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw\" data-href=\"https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw</span></a></p><p id=\"u7d741f69\" class=\"ne-p\"><a href=\"https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w\" data-href=\"https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w</span></a></p><p id=\"u4bc4c0ef\" class=\"ne-p\"><a href=\"https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A\" data-href=\"https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A</span></a></p><p id=\"u426fa058\" class=\"ne-p\"><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;mid=2247484566&amp;idx=1&amp;sn=9dcd1d99df1aeef9e14b8fc8315c08dd&amp;chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&amp;token=678376780&amp;lang=zh_CN#rd\" data-href=\"https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;mid=2247484566&amp;idx=1&amp;sn=9dcd1d99df1aeef9e14b8fc8315c08dd&amp;chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&amp;token=678376780&amp;lang=zh_CN#rd\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;mid=2247484566&amp;idx=1&amp;sn=9dcd1d99df1aeef9e14b8fc8315c08dd&amp;chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&amp;token=678376780&amp;lang=zh_CN#rd</span></a></p><p id=\"u0f4d2acf\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u6b3ff60c\" class=\"ne-p\"><a href=\"https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" data-href=\"https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</span></a></p><p id=\"u2c00d16a\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ubf729e8a\" class=\"ne-p\"><br></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u468fb7e5\" id=\"u468fb7e5\"><a href=\"https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw\" target=\"_blank\" data-lake-id=\"u5e173942\" id=\"u5e173942\"><span data-lake-id=\"u2fe31afd\" id=\"u2fe31afd\">https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw</span></a></p><p data-lake-id=\"u45274de4\" id=\"u45274de4\"><a href=\"https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack\" target=\"_blank\" data-lake-id=\"uc43aaf17\" id=\"uc43aaf17\"><span data-lake-id=\"u1cef0190\" id=\"u1cef0190\">https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack</span></a></p><p data-lake-id=\"uc6735c5b\" id=\"uc6735c5b\"><a href=\"https://www.yuque.com/mdh/weekly/fq162w\" target=\"_blank\" data-lake-id=\"uedd7ee09\" id=\"uedd7ee09\"><span data-lake-id=\"u396f16c5\" id=\"u396f16c5\">https://www.yuque.com/mdh/weekly/fq162w</span></a></p><p data-lake-id=\"u11779a97\" id=\"u11779a97\"><a href=\"https://modernjs.dev/\" target=\"_blank\" data-lake-id=\"u9953516f\" id=\"u9953516f\"><span data-lake-id=\"u6d2fd1ff\" id=\"u6d2fd1ff\">https://modernjs.dev/</span></a></p><p data-lake-id=\"u909d200a\" id=\"u909d200a\"><a href=\"https://ourai.ws/\" target=\"_blank\" data-lake-id=\"u2852281c\" id=\"u2852281c\"><span data-lake-id=\"ubca09064\" id=\"ubca09064\">https://ourai.ws/</span></a></p><p data-lake-id=\"uddbf0044\" id=\"uddbf0044\"><a href=\"https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw\" target=\"_blank\" data-lake-id=\"u7d9df993\" id=\"u7d9df993\"><span data-lake-id=\"ub90ab58a\" id=\"ub90ab58a\">https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw</span></a></p><p data-lake-id=\"u7d741f69\" id=\"u7d741f69\"><a href=\"https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w\" target=\"_blank\" data-lake-id=\"u6df7a95d\" id=\"u6df7a95d\"><span data-lake-id=\"u370293a8\" id=\"u370293a8\">https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w</span></a></p><p data-lake-id=\"u4bc4c0ef\" id=\"u4bc4c0ef\"><a href=\"https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A\" target=\"_blank\" data-lake-id=\"u1a7cd732\" id=\"u1a7cd732\"><span data-lake-id=\"u86b58069\" id=\"u86b58069\">https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A</span></a></p><p data-lake-id=\"u426fa058\" id=\"u426fa058\"><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;mid=2247484566&amp;idx=1&amp;sn=9dcd1d99df1aeef9e14b8fc8315c08dd&amp;chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&amp;token=678376780&amp;lang=zh_CN#rd\" target=\"_blank\" data-lake-id=\"u1b182da2\" id=\"u1b182da2\"><span data-lake-id=\"u3cb637de\" id=\"u3cb637de\">https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;mid=2247484566&amp;idx=1&amp;sn=9dcd1d99df1aeef9e14b8fc8315c08dd&amp;chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&amp;token=678376780&amp;lang=zh_CN#rd</span></a></p><p data-lake-id=\"u0f4d2acf\" id=\"u0f4d2acf\"><span data-lake-id=\"uab7daeb6\" id=\"uab7daeb6\">​</span><br></p><p data-lake-id=\"u6b3ff60c\" id=\"u6b3ff60c\"><a href=\"https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" data-lake-id=\"u1c0ea9b8\" id=\"u1c0ea9b8\"><span data-lake-id=\"u586c7575\" id=\"u586c7575\">https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</span></a></p><p data-lake-id=\"u2c00d16a\" id=\"u2c00d16a\"><span data-lake-id=\"u6fdc3658\" id=\"u6fdc3658\">​</span><br></p><p data-lake-id=\"ubf729e8a\" id=\"ubf729e8a\"><br></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u468fb7e5\" id=\"u468fb7e5\"><a href=\"https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw\" target=\"_blank\" data-lake-id=\"u5e173942\" id=\"u5e173942\"><span data-lake-id=\"u2fe31afd\" id=\"u2fe31afd\">https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Tw</span></a></p><p data-lake-id=\"u45274de4\" id=\"u45274de4\"><a href=\"https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack\" target=\"_blank\" data-lake-id=\"uc43aaf17\" id=\"uc43aaf17\"><span data-lake-id=\"u1cef0190\" id=\"u1cef0190\">https://www.thoughtworks.com/zh-cn/radar/techniques/jamstack</span></a></p><p data-lake-id=\"uc6735c5b\" id=\"uc6735c5b\"><a href=\"https://www.yuque.com/mdh/weekly/fq162w\" target=\"_blank\" data-lake-id=\"uedd7ee09\" id=\"uedd7ee09\"><span data-lake-id=\"u396f16c5\" id=\"u396f16c5\">https://www.yuque.com/mdh/weekly/fq162w</span></a></p><p data-lake-id=\"u11779a97\" id=\"u11779a97\"><a href=\"https://modernjs.dev/\" target=\"_blank\" data-lake-id=\"u9953516f\" id=\"u9953516f\"><span data-lake-id=\"u6d2fd1ff\" id=\"u6d2fd1ff\">https://modernjs.dev/</span></a></p><p data-lake-id=\"u909d200a\" id=\"u909d200a\"><a href=\"https://ourai.ws/\" target=\"_blank\" data-lake-id=\"u2852281c\" id=\"u2852281c\"><span data-lake-id=\"ubca09064\" id=\"ubca09064\">https://ourai.ws/</span></a></p><p data-lake-id=\"uddbf0044\" id=\"uddbf0044\"><a href=\"https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw\" target=\"_blank\" data-lake-id=\"u7d9df993\" id=\"u7d9df993\"><span data-lake-id=\"ub90ab58a\" id=\"ub90ab58a\">https://mp.weixin.qq.com/s/K4r31sDS2cUUoZ8gMy5KKw</span></a></p><p data-lake-id=\"u7d741f69\" id=\"u7d741f69\"><a href=\"https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w\" target=\"_blank\" data-lake-id=\"u6df7a95d\" id=\"u6df7a95d\"><span data-lake-id=\"u370293a8\" id=\"u370293a8\">https://mp.weixin.qq.com/s/BRKla_vnZi9YCsFNo2H97w</span></a></p><p data-lake-id=\"u4bc4c0ef\" id=\"u4bc4c0ef\"><a href=\"https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A\" target=\"_blank\" data-lake-id=\"u1a7cd732\" id=\"u1a7cd732\"><span data-lake-id=\"u86b58069\" id=\"u86b58069\">https://mp.weixin.qq.com/s/M9zdo0xKf4WjOZ-2EehM2A</span></a></p><p data-lake-id=\"u426fa058\" id=\"u426fa058\"><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;mid=2247484566&amp;idx=1&amp;sn=9dcd1d99df1aeef9e14b8fc8315c08dd&amp;chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&amp;token=678376780&amp;lang=zh_CN#rd\" target=\"_blank\" data-lake-id=\"u1b182da2\" id=\"u1b182da2\"><span data-lake-id=\"u3cb637de\" id=\"u3cb637de\">https://mp.weixin.qq.com/s?__biz=Mzg2NDAwMjM1NQ==&amp;mid=2247484566&amp;idx=1&amp;sn=9dcd1d99df1aeef9e14b8fc8315c08dd&amp;chksm=ce714ccaf906c5dc143e9301acdbeab1a8c3c8867066f64a0606cd7511f317b2b02d7e49a22a&amp;token=678376780&amp;lang=zh_CN#rd</span></a></p><p data-lake-id=\"u0f4d2acf\" id=\"u0f4d2acf\"><span data-lake-id=\"uab7daeb6\" id=\"uab7daeb6\">​</span><br></p><p data-lake-id=\"u6b3ff60c\" id=\"u6b3ff60c\"><a href=\"https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" data-lake-id=\"u1c0ea9b8\" id=\"u1c0ea9b8\"><span data-lake-id=\"u586c7575\" id=\"u586c7575\">https://zhuanlan.zhihu.com/p/426707646?hmsr=toutiao.io&amp;utm_campaign=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</span></a></p><p data-lake-id=\"u2c00d16a\" id=\"u2c00d16a\"><span data-lake-id=\"u6fdc3658\" id=\"u6fdc3658\">​</span><br></p><p data-lake-id=\"ubf729e8a\" id=\"ubf729e8a\"><br></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-11-09T01:22:59.000Z",
    "deleted_at": null,
    "created_at": "2021-11-08T08:44:52.000Z",
    "updated_at": "2021-11-16T06:52:06.000Z",
    "published_at": "2021-11-09T01:22:59.000Z",
    "first_published_at": "2021-11-08T08:45:14.000Z",
    "word_count": 10,
    "cover": null,
    "description": "https://mp.weixin.qq.com/s/5Ir7EoHLo37bs6W5WNa-Twhttps://www.thoughtworks.com/zh-cn/radar/techniques/jamstackhttps://www.yuque.com/mdh/weekly/fq162...",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 54146228,
    "slug": "ecpwax",
    "title": "Java即时编译器原理解析及实践",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"Cs0yO\"></a>\n## 一、导读\n常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。<br />为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。<br />即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。\n<a name=\"wnC6p\"></a>\n## 二、Java的执行过程\nJava的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。<br />怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：<br />\n<a name=\"xlpT6\"></a>\n### 1. JVM中的编译器\nJVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。<br />**Client Compiler**<br />HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：\n\n- 局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。\n- 将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。\n- 最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。\n\n**Server Compiler**<br />Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。<br />**C2 Compiler**<br />在Hotspot VM中，默认的Server Compiler是C2编译器。<br />C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。<br />Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。<br />无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：\n\n**Graal Compiler**<br />从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：\n\n- 前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。\n- 使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。\n- 更深层次的优化，比如虚函数的内联、部分逃逸分析等。\n\nGraal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。\n<a name=\"LFlag\"></a>\n### 2. 分层编译\n在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：\n\n1. 解释执行。\n1. 执行不带profiling的C1代码。\n1. 执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。\n1. 执行带所有profiling的C1代码。\n1. 执行C2代码。\n\nprofiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。<br />通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层>2层>3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：<br />\n\n- 图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。\n- 如果方法比较小（比如Java服务中常见的getter/setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。\n- 在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。\n- 前文提到C1中的执行效率是1层>2层>3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。\n- 如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。\n\n总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。\n<a name=\"NWxMz\"></a>\n### 3. 即时编译的触发\nJava虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：<br />循环回边<br />**public** **void** **nlp**(Object obj) {   **int** sum = 0;   **for** (**int** i = 0; i < 200; i++) {     sum += i;   } } <br />上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。<br />字节码<br />public void nlp(java.lang.Object);     Code:        0: iconst_0        1: istore_1        2: iconst_0        3: istore_2        4: iload_2        5: sipush        200        8: if_icmpge     21       11: iload_1       12: iload_2       13: iadd       14: istore_1       15: iinc          2, 1       18: goto          4       21: return <br />在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。<br />当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。<br />开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：\n\n- 方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。\n- 方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。\n\n分层编译触发条件公式<br />i > TierXInvocationThreshold * s **||** (i > TierXMinInvocationThreshold * s  && i + **b **> TierXCompileThreshold * s)  i为调用次数，**b是循环回边次数 **<br />上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。\n<a name=\"crUWZ\"></a>\n## 三、编译优化\n即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。\n<a name=\"IcPt7\"></a>\n### 1. 中间表达形式（Intermediate Representation）\n在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。<br />Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：<br />SSA IR<br />Plain Text {   a = 1;   a = 2;   b = a; } <br />上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。<br />上面代码的SSA IR形式的伪代码可以表示为：<br />SSA IR<br />Plain Text {   a_1 = 1;   a_2 = 2;   b_1 = a_2; } <br />由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。<br />除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子：<br />DeadCodeElimination<br />**public** **void** DeadCodeElimination{   **int** a = 2;   **int** b = 0   **if**(2 > 1){     a = 1;   } **else**{     b = 2;   }   **add**(a,b) } <br />可以得到SSA IR伪代码：<br />DeadCodeElimination<br />a_1 = 2; b_1 = 0 if true:   a_2 = 1; else   b_2 = 2; add(a,b) <br />编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：<br />DeadCodeElimination<br />**public** **void** DeadCodeElimination{   **int** a = 1;   **int** b = 0;   **add**(a,b) } <br />我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。<br />**C1中的中间表达形式**<br />前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。<br />HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：\n\n其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。<br />从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：<br />字节码构造HIR<br />        字节码                     **Local** **Value**             **operand** **stack**              **HIR**       **5**: **iload_1**                  [i1,i2]                 [i1]       **6**: **iload_2**                  [i1,i2]                 [i1,i2]                                      ................................................   **i3**: **i1** * **i2**       **7**: **imul**                                          **8**: **istore_3**                 [i1,i2，i3]              [i3] <br />可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。<br />C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。<br />**Sea-of-Nodes IR**<br />C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：<br />example<br />**public** **static** **int** **foo**(**int** count) {   **int** sum = 0;   **for** (**int** i = 0; i < count; i++) {     sum += i;   }   **return** sum; } <br />对应的IR图如下所示：\n\n图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。<br />这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。<br />依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。<br />**Phi And Region Nodes**<br />Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。<br />example<br />**int** **test**(**int** x) { **int** a = 0;   **if**(x == 1) {     a = 5;   } **else** {     a = 6;   }   **return** a; } <br />为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：\n\nPhi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：<br />Phi Nodes<br />int test(int x) {   a_1 = 0;   if(x == 1){     a_2 = 5;   }else {     a_3 = 6;   }   a_4 = Phi(a_2,a_3);   return a_4; } <br />**Global Value Numbering**<br />Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。<br />GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：<br />GVN<br />a = 1; b = 2; c = a + b; d = a + b; e = d; <br />GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。<br />可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。\n<a name=\"WjweJ\"></a>\n### 2.方法内联\n方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。<br />Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）：<br />方法内联的过程<br />**public** **static** **boolean** flag = **true**; **public** **static** **int** value0 = 0; **public** **static** **int** value1 = 1;  **public** **static** **int** **foo**(**int** value) {     **int** result = bar(flag);     **if** (result != 0) {         **return** result;     } **else** {         **return** value;     } }  **public** **static** **int** **bar**(**boolean** flag) {     **return** flag ? value0 : value1; } <br />bar方法的IR图：\n\n内联后的IR图：\n\n内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。<br />被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。<br />调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。<br />如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。<br />**方法内联的条件**<br />编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。<br />可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：\n\n**虚函数内联**<br />内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。<br />C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：<br />virtual call<br />**public** **class** **SimpleInliningTest** {     **public** **static** **void** **main**(String[] args) **throws** InterruptedException {         VirtualInvokeTest obj = **new** VirtualInvokeTest();         VirtualInvoke1 obj1 = **new** VirtualInvoke1();         **for** (**int** i = 0; i < 100000; i++) {             invokeMethod(obj);             invokeMethod(obj1);         }         Thread.sleep(1000);     }      **public** **static** **void** **invokeMethod**(VirtualInvokeTest obj) {         obj.methodCall();     }      **private** **static** **class** **VirtualInvokeTest** {         **public** **void** **methodCall**() {             System.out.println(\"virtual call\");         }     }      **private** **static** **class** **VirtualInvoke1** **extends** **VirtualInvokeTest** {         @Override         **public** **void** **methodCall**() {             **super**.methodCall();         }     } } <br />经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：<br /> 0x0000000113369d37: callq  0x00000001132950a0  ; OopMap{off=476}                                                 ;*invokevirtual methodCall  _//代表虚调用_                                                 ; - SimpleInliningTest::invokeMethod@1 (line 18)                                                 ;   {optimized virtual_call}  _//虚调用已经被优化_ <br />可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。<br />比如下面这段代码，我们增加一个实现：<br />多实现的虚调用<br />**public** **class** **SimpleInliningTest** {     **public** **static** **void** **main**(String[] args) **throws** InterruptedException {         VirtualInvokeTest obj = **new** VirtualInvokeTest();         VirtualInvoke1 obj1 = **new** VirtualInvoke1();         VirtualInvoke2 obj2 = **new** VirtualInvoke2();         **for** (**int** i = 0; i < 100000; i++) {             invokeMethod(obj);             invokeMethod(obj1);         invokeMethod(obj2);         }         Thread.sleep(1000);     }      **public** **static** **void** **invokeMethod**(VirtualInvokeTest obj) {         obj.methodCall();     }      **private** **static** **class** **VirtualInvokeTest** {         **public** **void** **methodCall**() {             System.out.println(\"virtual call\");         }     }      **private** **static** **class** **VirtualInvoke1** **extends** **VirtualInvokeTest** {         @Override         **public** **void** **methodCall**() {             **super**.methodCall();         }     }     **private** **static** **class** **VirtualInvoke2** **extends** **VirtualInvokeTest** {         @Override         **public** **void** **methodCall**() {             **super**.methodCall();         }     } } <br />经过反编译得到下面的汇编代码：<br />代码块<br /> 0x000000011f5f0a37: callq  0x000000011f4fd2e0  ; OopMap{off=28}                                                 ;*invokevirtual methodCall  _//代表虚调用_                                                 ; - SimpleInliningTest::invokeMethod@1 (line 20)                                                 ;   {virtual_call}  _//虚调用未被优化_ <br />可以看到多个实现的虚调用未被优化，依然是virtual_call。<br />Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。\n<a name=\"nTiw8\"></a>\n### 3. 逃逸分析\n逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：\n\n1. 对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。\n1. 对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。\n\n逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：<br />pulbic **class** **Example**{     **public** **static** **void** **main**(String[] args) {       example();     }     **public** **static** **void** **example**() {       Foo foo = **new** Foo();       Bar bar = **new** Bar();       bar.setFoo(foo);     }   }    **class** **Foo** {}    **class** **Bar** {     **private** Foo foo;     **public** **void** **setFoo**(Foo foo) {       **this**.foo = foo;     }   } } <br />在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。<br />**锁消除**<br />在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。<br />如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。<br />**栈上分配**<br />我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：<br />标量替换<br />**public** **class** **Example**{   @AllArgsConstructor   **class** **Cat**{     **int** age;     **int** weight;   }   **public** **static** **void** **example**(){     Cat cat = **new** Cat(1,10);     addAgeAndWeight(cat.age,Cat.weight);   } } <br />经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：<br />**public** **class** **Example**{   @AllArgsConstructor   **class** **Cat**{     **int** age;     **int** weight;   }   **public** **static** **void** **example**(){     **int** age = 1;     **int** weight = 10;     addAgeAndWeight(age,weight);   } } <br />**部分逃逸分析**<br />部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。\n<a name=\"Kz4q3\"></a>\n### 4. Loop Transformations\n在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。<br />**循环展开**<br />循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。<br />循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：<br />循环展开<br />**public** **void** **loopRolling**(){   **for**(**int** i = 0;i<200;i++){     **delete**(i);     } } <br />上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：<br />循环展开<br />**public** **void** **loopRolling**(){   **for**(**int** i = 0;i<200;i+=5){     **delete**(i);     **delete**(i+1);     **delete**(i+2);     **delete**(i+3);     **delete**(i+4);   } } <br />这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。<br />**循环分离**<br />循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：<br />循环分离<br />**int** a = 10; **for**(**int** i = 0;i<10;i++){   b[i] = **x**[i] + **x**[a];   a = i; } <br />可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：<br />循环分离<br />b[0] = x[0] + 10; for(int i = 1;i<10;i++){   b[i] = x[i] + x[i-1]; } <br />这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。\n<a name=\"ynalx\"></a>\n### 5. 窥孔优化与寄存器分配\n前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：<br />强度削减<br />y1=x1*3  经过强度削减后得到  y1=(x1<<1)+x1 <br />编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。<br />寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。<br />寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。\n<a name=\"ZSShZ\"></a>\n## 四、实践\n即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。\n<a name=\"SHpjP\"></a>\n### 1. 编译相关的重* 要参数\n\n- -XX:+TieredCompilation：开启分层编译，JDK8之后默认开启\n- -XX:+CICompilerCount=N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 = 1:2\n- -XX:TierXBackEdgeThreshold：OSR编译的阈值\n- -XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值\n- -XX:TierXCompileThreshold：开启分层编译后的编译阈值\n- -XX:ReservedCodeCacheSize：codeCache最大大小\n- -XX:InitialCodeCacheSize：codeCache初始大小\n\n-XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。<br />由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。\n<a name=\"tIo0Z\"></a>\n### 2. 通过JITwatch分析编译日志\n通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile=LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。\n\n如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：\n\n我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。<br />区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。\n<a name=\"aBz3d\"></a>\n### 3. 使用Graal编译器\n由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。<br />为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。<br />前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。<br />前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。<br />这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。<br />**使用Graal编译器后性能表现**<br />在我们的线上服务中，启用Graal编译后，TP9999从60ms -> 50ms ，下降10ms，下降幅度达16.7%。<br />运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。<br />**Graal编译器的问题**<br />Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。<br />考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。\n<a name=\"KwkdK\"></a>\n## 五、总结\n本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。\n",
    "body_draft": "<a name=\"Cs0yO\"></a>\n## 一、导读\n常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。<br />为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。<br />即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。\n<a name=\"wnC6p\"></a>\n## 二、Java的执行过程\nJava的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。<br />怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：<br />\n<a name=\"xlpT6\"></a>\n### 1. JVM中的编译器\nJVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。<br />**Client Compiler**<br />HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：\n\n- 局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。\n- 将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。\n- 最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。\n\n**Server Compiler**<br />Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。<br />**C2 Compiler**<br />在Hotspot VM中，默认的Server Compiler是C2编译器。<br />C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。<br />Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。<br />无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：\n\n**Graal Compiler**<br />从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：\n\n- 前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。\n- 使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。\n- 更深层次的优化，比如虚函数的内联、部分逃逸分析等。\n\nGraal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。\n<a name=\"LFlag\"></a>\n### 2. 分层编译\n在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：\n\n1. 解释执行。\n1. 执行不带profiling的C1代码。\n1. 执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。\n1. 执行带所有profiling的C1代码。\n1. 执行C2代码。\n\nprofiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。<br />通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层>2层>3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：<br />\n\n- 图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。\n- 如果方法比较小（比如Java服务中常见的getter/setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。\n- 在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。\n- 前文提到C1中的执行效率是1层>2层>3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。\n- 如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。\n\n总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。\n<a name=\"NWxMz\"></a>\n### 3. 即时编译的触发\nJava虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：<br />循环回边<br />**public** **void** **nlp**(Object obj) {   **int** sum = 0;   **for** (**int** i = 0; i < 200; i++) {     sum += i;   } } <br />上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。<br />字节码<br />public void nlp(java.lang.Object);     Code:        0: iconst_0        1: istore_1        2: iconst_0        3: istore_2        4: iload_2        5: sipush        200        8: if_icmpge     21       11: iload_1       12: iload_2       13: iadd       14: istore_1       15: iinc          2, 1       18: goto          4       21: return <br />在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。<br />当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。<br />开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：\n\n- 方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。\n- 方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。\n\n分层编译触发条件公式<br />i > TierXInvocationThreshold * s **||** (i > TierXMinInvocationThreshold * s  && i + **b **> TierXCompileThreshold * s)  i为调用次数，**b是循环回边次数 **<br />上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。\n<a name=\"crUWZ\"></a>\n## 三、编译优化\n即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。\n<a name=\"IcPt7\"></a>\n### 1. 中间表达形式（Intermediate Representation）\n在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。<br />Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：<br />SSA IR<br />Plain Text {   a = 1;   a = 2;   b = a; } <br />上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。<br />上面代码的SSA IR形式的伪代码可以表示为：<br />SSA IR<br />Plain Text {   a_1 = 1;   a_2 = 2;   b_1 = a_2; } <br />由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。<br />除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子：<br />DeadCodeElimination<br />**public** **void** DeadCodeElimination{   **int** a = 2;   **int** b = 0   **if**(2 > 1){     a = 1;   } **else**{     b = 2;   }   **add**(a,b) } <br />可以得到SSA IR伪代码：<br />DeadCodeElimination<br />a_1 = 2; b_1 = 0 if true:   a_2 = 1; else   b_2 = 2; add(a,b) <br />编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：<br />DeadCodeElimination<br />**public** **void** DeadCodeElimination{   **int** a = 1;   **int** b = 0;   **add**(a,b) } <br />我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。<br />**C1中的中间表达形式**<br />前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。<br />HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：\n\n其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。<br />从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：<br />字节码构造HIR<br />        字节码                     **Local** **Value**             **operand** **stack**              **HIR**       **5**: **iload_1**                  [i1,i2]                 [i1]       **6**: **iload_2**                  [i1,i2]                 [i1,i2]                                      ................................................   **i3**: **i1** * **i2**       **7**: **imul**                                          **8**: **istore_3**                 [i1,i2，i3]              [i3] <br />可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。<br />C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。<br />**Sea-of-Nodes IR**<br />C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：<br />example<br />**public** **static** **int** **foo**(**int** count) {   **int** sum = 0;   **for** (**int** i = 0; i < count; i++) {     sum += i;   }   **return** sum; } <br />对应的IR图如下所示：\n\n图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。<br />这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。<br />依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。<br />**Phi And Region Nodes**<br />Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。<br />example<br />**int** **test**(**int** x) { **int** a = 0;   **if**(x == 1) {     a = 5;   } **else** {     a = 6;   }   **return** a; } <br />为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：\n\nPhi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：<br />Phi Nodes<br />int test(int x) {   a_1 = 0;   if(x == 1){     a_2 = 5;   }else {     a_3 = 6;   }   a_4 = Phi(a_2,a_3);   return a_4; } <br />**Global Value Numbering**<br />Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。<br />GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：<br />GVN<br />a = 1; b = 2; c = a + b; d = a + b; e = d; <br />GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。<br />可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。\n<a name=\"WjweJ\"></a>\n### 2.方法内联\n方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。<br />Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）：<br />方法内联的过程<br />**public** **static** **boolean** flag = **true**; **public** **static** **int** value0 = 0; **public** **static** **int** value1 = 1;  **public** **static** **int** **foo**(**int** value) {     **int** result = bar(flag);     **if** (result != 0) {         **return** result;     } **else** {         **return** value;     } }  **public** **static** **int** **bar**(**boolean** flag) {     **return** flag ? value0 : value1; } <br />bar方法的IR图：\n\n内联后的IR图：\n\n内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。<br />被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。<br />调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。<br />如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。<br />**方法内联的条件**<br />编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。<br />可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：\n\n**虚函数内联**<br />内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。<br />C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：<br />virtual call<br />**public** **class** **SimpleInliningTest** {     **public** **static** **void** **main**(String[] args) **throws** InterruptedException {         VirtualInvokeTest obj = **new** VirtualInvokeTest();         VirtualInvoke1 obj1 = **new** VirtualInvoke1();         **for** (**int** i = 0; i < 100000; i++) {             invokeMethod(obj);             invokeMethod(obj1);         }         Thread.sleep(1000);     }      **public** **static** **void** **invokeMethod**(VirtualInvokeTest obj) {         obj.methodCall();     }      **private** **static** **class** **VirtualInvokeTest** {         **public** **void** **methodCall**() {             System.out.println(\"virtual call\");         }     }      **private** **static** **class** **VirtualInvoke1** **extends** **VirtualInvokeTest** {         @Override         **public** **void** **methodCall**() {             **super**.methodCall();         }     } } <br />经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：<br /> 0x0000000113369d37: callq  0x00000001132950a0  ; OopMap{off=476}                                                 ;*invokevirtual methodCall  _//代表虚调用_                                                 ; - SimpleInliningTest::invokeMethod@1 (line 18)                                                 ;   {optimized virtual_call}  _//虚调用已经被优化_ <br />可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。<br />比如下面这段代码，我们增加一个实现：<br />多实现的虚调用<br />**public** **class** **SimpleInliningTest** {     **public** **static** **void** **main**(String[] args) **throws** InterruptedException {         VirtualInvokeTest obj = **new** VirtualInvokeTest();         VirtualInvoke1 obj1 = **new** VirtualInvoke1();         VirtualInvoke2 obj2 = **new** VirtualInvoke2();         **for** (**int** i = 0; i < 100000; i++) {             invokeMethod(obj);             invokeMethod(obj1);         invokeMethod(obj2);         }         Thread.sleep(1000);     }      **public** **static** **void** **invokeMethod**(VirtualInvokeTest obj) {         obj.methodCall();     }      **private** **static** **class** **VirtualInvokeTest** {         **public** **void** **methodCall**() {             System.out.println(\"virtual call\");         }     }      **private** **static** **class** **VirtualInvoke1** **extends** **VirtualInvokeTest** {         @Override         **public** **void** **methodCall**() {             **super**.methodCall();         }     }     **private** **static** **class** **VirtualInvoke2** **extends** **VirtualInvokeTest** {         @Override         **public** **void** **methodCall**() {             **super**.methodCall();         }     } } <br />经过反编译得到下面的汇编代码：<br />代码块<br /> 0x000000011f5f0a37: callq  0x000000011f4fd2e0  ; OopMap{off=28}                                                 ;*invokevirtual methodCall  _//代表虚调用_                                                 ; - SimpleInliningTest::invokeMethod@1 (line 20)                                                 ;   {virtual_call}  _//虚调用未被优化_ <br />可以看到多个实现的虚调用未被优化，依然是virtual_call。<br />Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。\n<a name=\"nTiw8\"></a>\n### 3. 逃逸分析\n逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：\n\n1. 对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。\n1. 对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。\n\n逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：<br />pulbic **class** **Example**{     **public** **static** **void** **main**(String[] args) {       example();     }     **public** **static** **void** **example**() {       Foo foo = **new** Foo();       Bar bar = **new** Bar();       bar.setFoo(foo);     }   }    **class** **Foo** {}    **class** **Bar** {     **private** Foo foo;     **public** **void** **setFoo**(Foo foo) {       **this**.foo = foo;     }   } } <br />在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。<br />**锁消除**<br />在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。<br />如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。<br />**栈上分配**<br />我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：<br />标量替换<br />**public** **class** **Example**{   @AllArgsConstructor   **class** **Cat**{     **int** age;     **int** weight;   }   **public** **static** **void** **example**(){     Cat cat = **new** Cat(1,10);     addAgeAndWeight(cat.age,Cat.weight);   } } <br />经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：<br />**public** **class** **Example**{   @AllArgsConstructor   **class** **Cat**{     **int** age;     **int** weight;   }   **public** **static** **void** **example**(){     **int** age = 1;     **int** weight = 10;     addAgeAndWeight(age,weight);   } } <br />**部分逃逸分析**<br />部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。\n<a name=\"Kz4q3\"></a>\n### 4. Loop Transformations\n在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。<br />**循环展开**<br />循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。<br />循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：<br />循环展开<br />**public** **void** **loopRolling**(){   **for**(**int** i = 0;i<200;i++){     **delete**(i);     } } <br />上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：<br />循环展开<br />**public** **void** **loopRolling**(){   **for**(**int** i = 0;i<200;i+=5){     **delete**(i);     **delete**(i+1);     **delete**(i+2);     **delete**(i+3);     **delete**(i+4);   } } <br />这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。<br />**循环分离**<br />循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：<br />循环分离<br />**int** a = 10; **for**(**int** i = 0;i<10;i++){   b[i] = **x**[i] + **x**[a];   a = i; } <br />可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：<br />循环分离<br />b[0] = x[0] + 10; for(int i = 1;i<10;i++){   b[i] = x[i] + x[i-1]; } <br />这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。\n<a name=\"ynalx\"></a>\n### 5. 窥孔优化与寄存器分配\n前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：<br />强度削减<br />y1=x1*3  经过强度削减后得到  y1=(x1<<1)+x1 <br />编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。<br />寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。<br />寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。\n<a name=\"ZSShZ\"></a>\n## 四、实践\n即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。\n<a name=\"SHpjP\"></a>\n### 1. 编译相关的重* 要参数\n\n- -XX:+TieredCompilation：开启分层编译，JDK8之后默认开启\n- -XX:+CICompilerCount=N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 = 1:2\n- -XX:TierXBackEdgeThreshold：OSR编译的阈值\n- -XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值\n- -XX:TierXCompileThreshold：开启分层编译后的编译阈值\n- -XX:ReservedCodeCacheSize：codeCache最大大小\n- -XX:InitialCodeCacheSize：codeCache初始大小\n\n-XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。<br />由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。\n<a name=\"tIo0Z\"></a>\n### 2. 通过JITwatch分析编译日志\n通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile=LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。\n\n如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：\n\n我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。<br />区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。\n<a name=\"aBz3d\"></a>\n### 3. 使用Graal编译器\n由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。<br />为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。<br />前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。<br />前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。<br />这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。<br />**使用Graal编译器后性能表现**<br />在我们的线上服务中，启用Graal编译后，TP9999从60ms -> 50ms ，下降10ms，下降幅度达16.7%。<br />运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。<br />**Graal编译器的问题**<br />Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。<br />考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。\n<a name=\"KwkdK\"></a>\n## 五、总结\n本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"Cs0yO\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">一、导读</span></h2><p id=\"u9ba95b5d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。</span></p><p id=\"ued827280\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</span></p><p id=\"u7fb4cb1f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</span></p><h2 id=\"wnC6p\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">二、Java的执行过程</span></h2><p id=\"u12864b35\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。</span></p><p id=\"ubfba9b69\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：</span></p><p id=\"u1e42c372\" class=\"ne-p\"><span id=\"u31ddb444\"></span></p><h3 id=\"xlpT6\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. JVM中的编译器</span></h3><p id=\"ueb3a9486\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。</span></p><p id=\"uef50e2e1\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Client Compiler</span></strong></p><p id=\"uf03a866c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：</span></p><ul class=\"ne-ul\"><li id=\"ued9a728f\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。</span></li><li id=\"u5d1ab90b\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。</span></li></ul><ul class=\"ne-ul\"><li id=\"ubb246e87\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。</span></li></ul><p id=\"uea448329\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Server Compiler</span></strong></p><p id=\"uf2633e05\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。</span></p><p id=\"u7988657a\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">C2 Compiler</span></strong></p><p id=\"u913e7486\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在Hotspot VM中，默认的Server Compiler是C2编译器。</span></p><p id=\"ua7428ad8\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。</span></p><p id=\"uce8b62bd\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。</span></p><p id=\"u0818e196\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：</span></p><p id=\"u402a817e\" class=\"ne-p\"><span id=\"u73cf5869\"></span></p><p id=\"ub59ca60c\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Graal Compiler</span></strong></p><p id=\"u25663e3f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：</span></p><ul class=\"ne-ul\"><li id=\"u6c44c352\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。</span></li><li id=\"ufab1c16a\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。</span></li></ul><ul class=\"ne-ul\"><li id=\"ua3f4eb0c\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">更深层次的优化，比如虚函数的内联、部分逃逸分析等。</span></li></ul><p id=\"u94a3a120\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。</span></p><h3 id=\"LFlag\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2. 分层编译</span></h3><p id=\"u5d4c4162\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：</span></p><ol class=\"ne-ol\"><li id=\"u81c95631\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">解释执行。</span></li><li id=\"u7ed1d697\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">执行不带profiling的C1代码。</span></li></ol><ol start=\"3\" class=\"ne-ol\"><li id=\"u49d682cb\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。</span></li><li id=\"ube8d2bab\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">执行带所有profiling的C1代码。</span></li></ol><ol start=\"5\" class=\"ne-ol\"><li id=\"ub4dce0bc\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">执行C2代码。</span></li></ol><p id=\"u9cda71b8\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。</span></p><p id=\"u70441bfa\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层&gt;2层&gt;3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：</span></p><p id=\"uf4a98af1\" class=\"ne-p\"><span id=\"ufd64748b\"></span></p><ul class=\"ne-ul\"><li id=\"ua17cdb09\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。</span></li><li id=\"uf8c6ae96\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">如果方法比较小（比如Java服务中常见的getter/setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。</span></li></ul><ul class=\"ne-ul\"><li id=\"u0828df32\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。</span></li><li id=\"u98768a48\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">前文提到C1中的执行效率是1层&gt;2层&gt;3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。</span></li></ul><ul class=\"ne-ul\"><li id=\"u55d9b12f\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。</span></li></ul><p id=\"u806c9da6\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。</span></p><h3 id=\"NWxMz\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 即时编译的触发</span></h3><p id=\"u985084f9\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：</span></p><p id=\"ubec05133\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环回边</span></p><p id=\"u69d2defb\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">nlp</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(Object obj)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> sum = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">;   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span class=\"ne-text\"> (</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> i = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">; i &lt; </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">200</span><span class=\"ne-text\">; i++) {     sum += i;   } } </span></p><p id=\"u3c5cbea0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。</span></p><p id=\"u531c8a76\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">字节码</span></p><p id=\"u5761b682\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">public</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">void nlp(java.lang.Object);</span><span class=\"ne-text\">     </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">Code</span><span class=\"ne-text\">:</span><span class=\"ne-text\">        </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">0</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">iconst_0</span><span class=\"ne-text\">        </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">1</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">istore_1</span><span class=\"ne-text\">        </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">2</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">iconst_0</span><span class=\"ne-text\">        </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">3</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">istore_2</span><span class=\"ne-text\">        </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">4</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">iload_2</span><span class=\"ne-text\">        </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">5</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">sipush        200</span><span class=\"ne-text\">        </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">8</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">if_icmpge     21</span><span class=\"ne-text\">       </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">11</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">iload_1</span><span class=\"ne-text\">       </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">12</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">iload_2</span><span class=\"ne-text\">       </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">13</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">iadd</span><span class=\"ne-text\">       </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">14</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">istore_1</span><span class=\"ne-text\">       </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">15</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">iinc          2, 1</span><span class=\"ne-text\">       </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">18</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">goto          4</span><span class=\"ne-text\">       </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">21</span><span class=\"ne-text\">: </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">return</span><span class=\"ne-text\"> </span></p><p id=\"ue4d45031\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。</span></p><p id=\"u23b4bca4\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。</span></p><p id=\"u93e513f3\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：</span></p><ul class=\"ne-ul\"><li id=\"ud96643eb\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。</span></li><li id=\"ua10d10b6\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。</span></li></ul><p id=\"u37a28b2d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">分层编译触发条件公式</span></p><p id=\"uf3ca8d1f\" class=\"ne-p\"><span class=\"ne-text\">i &gt; TierXInvocationThreshold * s </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">||</span></strong><span class=\"ne-text\"> (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">b </span></strong><span class=\"ne-text\">&gt; TierXCompileThreshold * s)  i为调用次数，</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">b是循环回边次数 </span></strong></p><p id=\"u7ebf275b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。</span></p><h2 id=\"crUWZ\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">三、编译优化</span></h2><p id=\"ua9993f32\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。</span></p><h3 id=\"IcPt7\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. 中间表达形式（Intermediate Representation）</span></h3><p id=\"u4df43154\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</span></p><p id=\"u43d048ce\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：</span></p><p id=\"u05264e55\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">SSA IR</span></p><p id=\"u4b25be56\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">Plain</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">Text</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">{</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1;</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">2;</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">b</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">a;</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">}</span><span class=\"ne-text\"> </span></p><p id=\"u0bf689e0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。</span></p><p id=\"ud1393c2f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面代码的SSA IR形式的伪代码可以表示为：</span></p><p id=\"u4d0cf115\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">SSA IR</span></p><p id=\"uf0842f97\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">Plain</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">Text</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">{</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a_1</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1;</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a_2</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">2;</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">b_1</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">a_2;</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">}</span><span class=\"ne-text\"> </span></p><p id=\"ua3a0347a\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。</span></p><p id=\"u8edd9308\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子：</span></p><p id=\"u58545f6b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p id=\"u826f45b2\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> DeadCodeElimination{   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> a = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">2</span><span class=\"ne-text\">;   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> b = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span class=\"ne-text\">(</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">2</span><span class=\"ne-text\"> &gt; </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">){     a = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">;   } </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span class=\"ne-text\">{     b = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">2</span><span class=\"ne-text\">;   }   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">add</span></strong><span class=\"ne-text\">(a,b) } </span></p><p id=\"uf08c57dd\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以得到SSA IR伪代码：</span></p><p id=\"u3109dbb4\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p id=\"u52dca725\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a_1</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">2;</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">b_1</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">if</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">true:</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a_2</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1;</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">else</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">b_2</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">2;</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">add(a,b)</span><span class=\"ne-text\"> </span></p><p id=\"uad958982\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：</span></p><p id=\"u33e92e3c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p id=\"u400787f6\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> DeadCodeElimination{   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> a = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">;   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> b = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">;   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">add</span></strong><span class=\"ne-text\">(a,b) } </span></p><p id=\"u081d4627\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。</span></p><p id=\"ue0183cd7\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">C1中的中间表达形式</span></strong></p><p id=\"u6f3f6fc0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。</span></p><p id=\"ub69e2095\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：</span></p><p id=\"ue8bc2f53\" class=\"ne-p\"><span id=\"u949b2c2b\"></span></p><p id=\"u1c41ea34\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。</span></p><p id=\"ua8f98802\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：</span></p><p id=\"u10a459b3\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">字节码构造HIR</span></p><p id=\"u99729c37\" class=\"ne-p\"><span class=\"ne-text\">        字节码                     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">Local</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">Value</span></strong><span class=\"ne-text\">             </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">operand</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">stack</span></strong><span class=\"ne-text\">              </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">HIR</span></strong><span class=\"ne-text\">       </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">5</span></strong><span class=\"ne-text\">: </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">iload_1</span></strong><span class=\"ne-text\">                  </span><span class=\"ne-text\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span class=\"ne-text\">                 </span><span class=\"ne-text\" style=\"color: rgb(188, 96, 96)\">[i1]</span><span class=\"ne-text\">       </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">6</span></strong><span class=\"ne-text\">: </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">iload_2</span></strong><span class=\"ne-text\">                  </span><span class=\"ne-text\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span class=\"ne-text\">                 </span><span class=\"ne-text\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span class=\"ne-text\">                                      ................................................   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">i3</span></strong><span class=\"ne-text\">: </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">i1</span></strong><span class=\"ne-text\"> * </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">i2</span></strong><span class=\"ne-text\">       </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">7</span></strong><span class=\"ne-text\">: </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">imul</span></strong><span class=\"ne-text\">                                          </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">8</span></strong><span class=\"ne-text\">: </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">istore_3</span></strong><span class=\"ne-text\">                 </span><span class=\"ne-text\" style=\"color: rgb(188, 96, 96)\">[i1,i2，i3]</span><span class=\"ne-text\">              </span><span class=\"ne-text\" style=\"color: rgb(188, 96, 96)\">[i3]</span><span class=\"ne-text\"> </span></p><p id=\"u48ee5c2d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。</span></p><p id=\"u7ab70132\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。</span></p><p id=\"uaaf84acc\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Sea-of-Nodes IR</span></strong></p><p id=\"u658e25cf\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：</span></p><p id=\"u4f8ed85e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">example</span></p><p id=\"ue1b45797\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">foo</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\"> count)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> sum = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">;   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span class=\"ne-text\"> (</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> i = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">; i &lt; count; i++) {     sum += i;   }   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span class=\"ne-text\"> sum; } </span></p><p id=\"u775d6e99\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">对应的IR图如下所示：</span></p><p id=\"u849b3569\" class=\"ne-p\"><span id=\"u1cacffb7\"></span></p><p id=\"u76e878df\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。</span></p><p id=\"u74891e56\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。</span></p><p id=\"u73d21a64\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。</span></p><p id=\"u2e3b6802\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Phi And Region Nodes</span></strong></p><p id=\"u0c506ab2\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。</span></p><p id=\"uf541b8f1\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">example</span></p><p id=\"u87847572\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">test</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\"> x)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{ </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> a = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">;   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span class=\"ne-text\">(x == </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">) {     a = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">5</span><span class=\"ne-text\">;   } </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span class=\"ne-text\"> {     a = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">6</span><span class=\"ne-text\">;   }   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span class=\"ne-text\"> a; } </span></p><p id=\"u6f9997c6\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：</span></p><p id=\"u0b83d294\" class=\"ne-p\"><span id=\"u72989f7b\"></span></p><p id=\"ub73aa83d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：</span></p><p id=\"ua97940e5\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Phi Nodes</span></p><p id=\"ub7994182\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">int</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">test(int x) {</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a_1</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0;</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(155, 133, 157)\">if(x</span><span class=\"ne-text\"> =</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">= 1){</span><span class=\"ne-text\">     </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a_2</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">5;</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(155, 133, 157)\">}else</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">{</span><span class=\"ne-text\">     </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a_3</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">6;</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">}</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">a_4</span><span class=\"ne-text\"> = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">Phi(a_2,a_3);</span><span class=\"ne-text\">   </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">return</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">a_4;</span><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(109, 156, 190)\">}</span><span class=\"ne-text\"> </span></p><p id=\"uaf1df5d6\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Global Value Numbering</span></strong></p><p id=\"ua4349034\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。</span></p><p id=\"u61e5e340\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：</span></p><p id=\"u8ae7675e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN</span></p><p id=\"ube2c7230\" class=\"ne-p\"><span class=\"ne-text\">a = 1; b = 2; c = a + b; d = a + b; e = d; </span></p><p id=\"ud8bb529c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。</span></p><p id=\"u7a19670e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。</span></p><h3 id=\"WjweJ\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2.方法内联</span></h3><p id=\"uab2e34da\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。</span></p><p id=\"u17fda851\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）：</span></p><p id=\"ubcd34f92\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法内联的过程</span></p><p id=\"u95b1312b\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">boolean</span></strong><span class=\"ne-text\"> flag = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">true</span></strong><span class=\"ne-text\">; </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> value0 = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">; </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> value1 = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">;  </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">foo</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\"> value)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> result = bar(flag);     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span class=\"ne-text\"> (result != </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">) {         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span class=\"ne-text\"> result;     } </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span class=\"ne-text\"> {         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span class=\"ne-text\"> value;     } }  </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">bar</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">boolean</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\"> flag)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span class=\"ne-text\"> flag ? value0 : value1; } </span></p><p id=\"u2aa4fc90\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">bar方法的IR图：</span></p><p id=\"u275a5225\" class=\"ne-p\"><span id=\"u984ed21c\"></span></p><p id=\"u4238b547\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联后的IR图：</span></p><p id=\"ubce024a7\" class=\"ne-p\"><span id=\"u47efc8da\"></span></p><p id=\"u460869f9\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。</span></p><p id=\"ua8e7bdb2\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。</span></p><p id=\"uf7367549\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。</span></p><p id=\"udbf66164\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。</span></p><p id=\"u055fa346\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">方法内联的条件</span></strong></p><p id=\"uf48d05c2\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。</span></p><p id=\"u03641928\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：</span></p><p id=\"ue7c5cf8c\" class=\"ne-p\"><span id=\"u18d993ad\"></span></p><p id=\"u52ca4d6c\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">虚函数内联</span></strong></p><p id=\"u1df5211e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。</span></p><p id=\"u36a3a2ac\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：</span></p><p id=\"u0fe43f3b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">virtual call</span></p><p id=\"u68ea0300\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">SimpleInliningTest</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">throws</span></strong><span class=\"ne-text\"> InterruptedException </span><span class=\"ne-text\">{         VirtualInvokeTest obj = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span class=\"ne-text\"> VirtualInvokeTest();         VirtualInvoke1 obj1 = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span class=\"ne-text\"> VirtualInvoke1();         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span class=\"ne-text\"> (</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> i = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">; i &lt; </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">100000</span><span class=\"ne-text\">; i++) {             invokeMethod(obj);             invokeMethod(obj1);         }         Thread.sleep(</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1000</span><span class=\"ne-text\">);     }      </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">invokeMethod</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(VirtualInvokeTest obj)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{         obj.methodCall();     }      </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{             System.out.println(</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">&quot;virtual call&quot;</span><span class=\"ne-text\">);         }     }      </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke1</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{         </span><span class=\"ne-text\" style=\"color: rgb(155, 133, 157)\">@Override</span><span class=\"ne-text\">         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{             </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span class=\"ne-text\">.methodCall();         }     } } </span></p><p id=\"ubc53ef60\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：</span></p><p id=\"ucd58977a\" class=\"ne-p\"><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0x0000000113369d37</span><span class=\"ne-text\">: callq  </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0x00000001132950a0</span><span class=\"ne-text\">  ; OopMap{off=</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">476</span><span class=\"ne-text\">}                                                 ;*invokevirtual methodCall  </span><em><span class=\"ne-text\" style=\"color: rgb(188, 148, 88)\">//代表虚调用</span></em><span class=\"ne-text\">                                                 ; - SimpleInliningTest::invokeMethod@</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\"> (line </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">18</span><span class=\"ne-text\">)                                                 ;   {optimized virtual_call}  </span><em><span class=\"ne-text\" style=\"color: rgb(188, 148, 88)\">//虚调用已经被优化</span></em><span class=\"ne-text\"> </span></p><p id=\"u19576672\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。</span></p><p id=\"uff654061\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">比如下面这段代码，我们增加一个实现：</span></p><p id=\"u1ddb8da6\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">多实现的虚调用</span></p><p id=\"u354caeb4\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">SimpleInliningTest</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">throws</span></strong><span class=\"ne-text\"> InterruptedException </span><span class=\"ne-text\">{         VirtualInvokeTest obj = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span class=\"ne-text\"> VirtualInvokeTest();         VirtualInvoke1 obj1 = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span class=\"ne-text\"> VirtualInvoke1();         VirtualInvoke2 obj2 = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span class=\"ne-text\"> VirtualInvoke2();         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span class=\"ne-text\"> (</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> i = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">; i &lt; </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">100000</span><span class=\"ne-text\">; i++) {             invokeMethod(obj);             invokeMethod(obj1);         invokeMethod(obj2);         }         Thread.sleep(</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1000</span><span class=\"ne-text\">);     }      </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">invokeMethod</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(VirtualInvokeTest obj)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{         obj.methodCall();     }      </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{             System.out.println(</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">&quot;virtual call&quot;</span><span class=\"ne-text\">);         }     }      </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke1</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{         </span><span class=\"ne-text\" style=\"color: rgb(155, 133, 157)\">@Override</span><span class=\"ne-text\">         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{             </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span class=\"ne-text\">.methodCall();         }     }     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke2</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{         </span><span class=\"ne-text\" style=\"color: rgb(155, 133, 157)\">@Override</span><span class=\"ne-text\">         </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{             </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span class=\"ne-text\">.methodCall();         }     } } </span></p><p id=\"u0d241b7a\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过反编译得到下面的汇编代码：</span></p><p id=\"u66643733\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">代码块</span></p><p id=\"u687952ad\" class=\"ne-p\"><span class=\"ne-text\"> </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0x000000011f5f</span><span class=\"ne-text\">0a37: callq  </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0x000000011f4fd</span><span class=\"ne-text\">2e0  ; OopMap{off=</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">28</span><span class=\"ne-text\">}                                                 ;*invokevirtual methodCall  </span><em><span class=\"ne-text\" style=\"color: rgb(188, 148, 88)\">//代表虚调用</span></em><span class=\"ne-text\">                                                 ; - SimpleInliningTest::invokeMethod@</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\"> (line </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">20</span><span class=\"ne-text\">)                                                 ;   {virtual_call}  </span><em><span class=\"ne-text\" style=\"color: rgb(188, 148, 88)\">//虚调用未被优化</span></em><span class=\"ne-text\"> </span></p><p id=\"u653022cd\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看到多个实现的虚调用未被优化，依然是virtual_call。</span></p><p id=\"uf791d063\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。</span></p><h3 id=\"nTiw8\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 逃逸分析</span></h3><p id=\"ue34ecb63\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：</span></p><ol class=\"ne-ol\"><li id=\"ua34c15e7\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。</span></li><li id=\"ucade2de2\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。</span></li></ol><p id=\"u718a1567\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：</span></p><p id=\"u1b53e444\" class=\"ne-p\"><span class=\"ne-text\">pulbic </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{       example();     }     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{       Foo foo = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span class=\"ne-text\"> Foo();       Bar bar = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span class=\"ne-text\"> Bar();       bar.setFoo(foo);     }   }    </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">Foo</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{}    </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">Bar</span></strong><span class=\"ne-text\"> </span><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span class=\"ne-text\"> Foo foo;     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">setFoo</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">(Foo foo)</span><span class=\"ne-text\"> </span><span class=\"ne-text\">{       </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">this</span></strong><span class=\"ne-text\">.foo = foo;     }   } } </span></p><p id=\"u43d6822b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。</span></p><p id=\"ud1977f0f\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">锁消除</span></strong></p><p id=\"u11e106a6\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。</span></p><p id=\"uc721a5f5\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。</span></p><p id=\"u1a039201\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">栈上分配</span></strong></p><p id=\"u5355739f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：</span></p><p id=\"u81a96399\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">标量替换</span></p><p id=\"uccc85a28\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span class=\"ne-text\">{   </span><span class=\"ne-text\" style=\"color: rgb(155, 133, 157)\">@AllArgsConstructor</span><span class=\"ne-text\">   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">Cat</span></strong><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> age;     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> weight;   }   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\">{     Cat cat = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span class=\"ne-text\"> Cat(</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">,</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">10</span><span class=\"ne-text\">);     addAgeAndWeight(cat.age,Cat.weight);   } } </span></p><p id=\"u3b76328a\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：</span></p><p id=\"ub3c94f81\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span class=\"ne-text\">{   </span><span class=\"ne-text\" style=\"color: rgb(155, 133, 157)\">@AllArgsConstructor</span><span class=\"ne-text\">   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">Cat</span></strong><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> age;     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> weight;   }   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\">{     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> age = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">;     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> weight = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">10</span><span class=\"ne-text\">;     addAgeAndWeight(age,weight);   } } </span></p><p id=\"ufcc36c77\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">部分逃逸分析</span></strong></p><p id=\"u81b5df62\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。</span></p><h3 id=\"Kz4q3\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">4. Loop Transformations</span></h3><p id=\"udbc062da\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。</span></p><p id=\"u8f2ac734\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">循环展开</span></strong></p><p id=\"ue0ff70b0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。</span></p><p id=\"uc2822c8e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：</span></p><p id=\"u1210203d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开</span></p><p id=\"u051b7df7\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">loopRolling</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\">{   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span class=\"ne-text\">(</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> i = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">;i&lt;</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">200</span><span class=\"ne-text\">;i++){     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span class=\"ne-text\">(i);     } } </span></p><p id=\"u9642f87d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：</span></p><p id=\"ud8ae8594\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开</span></p><p id=\"u18a4f41c\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span class=\"ne-text\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(255, 198, 109)\">loopRolling</span></strong><span class=\"ne-text\" style=\"color: rgb(208, 208, 255)\">()</span><span class=\"ne-text\">{   </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span class=\"ne-text\">(</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> i = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">;i&lt;</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">200</span><span class=\"ne-text\">;i+=</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">5</span><span class=\"ne-text\">){     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span class=\"ne-text\">(i);     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span class=\"ne-text\">(i+</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">);     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span class=\"ne-text\">(i+</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">2</span><span class=\"ne-text\">);     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span class=\"ne-text\">(i+</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">3</span><span class=\"ne-text\">);     </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span class=\"ne-text\">(i+</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">4</span><span class=\"ne-text\">);   } } </span></p><p id=\"u3374ca41\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。</span></p><p id=\"u0c53185e\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">循环分离</span></strong></p><p id=\"ub999980d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：</span></p><p id=\"u3e518f57\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离</span></p><p id=\"ubd18aa84\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> a = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">10</span><span class=\"ne-text\">; </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span class=\"ne-text\">(</span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span class=\"ne-text\"> i = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">0</span><span class=\"ne-text\">;i&lt;</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">10</span><span class=\"ne-text\">;i++){   b[i] = </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">x</span></strong><span class=\"ne-text\">[i] + </span><strong><span class=\"ne-text\" style=\"color: rgb(194, 98, 48)\">x</span></strong><span class=\"ne-text\">[a];   a = i; } </span></p><p id=\"u19c23aad\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：</span></p><p id=\"ue547f2b2\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离</span></p><p id=\"u29e53f6f\" class=\"ne-p\"><span class=\"ne-text\">b</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">[0]</span><span class=\"ne-text\"> = x</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">[0]</span><span class=\"ne-text\"> + </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">10</span><span class=\"ne-text\">; for(int i = </span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">1</span><span class=\"ne-text\">;i&lt;</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">10</span><span class=\"ne-text\">;i++){   b</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">[i]</span><span class=\"ne-text\"> = x</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">[i]</span><span class=\"ne-text\"> + x</span><span class=\"ne-text\" style=\"color: rgb(165, 194, 97)\">[i-1]</span><span class=\"ne-text\">; } </span></p><p id=\"u553c2724\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。</span></p><h3 id=\"ynalx\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">5. 窥孔优化与寄存器分配</span></h3><p id=\"ua7c22582\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：</span></p><p id=\"ubc64dea7\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">强度削减</span></p><p id=\"ucacd35d6\" class=\"ne-p\"><span class=\"ne-text\">y1=x1*3  经过强度削减后得到  y1=(x1&lt;&lt;1)+x1 </span></p><p id=\"ube41c3ea\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。</span></p><p id=\"u42c78f5c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。</span></p><p id=\"ub13c94b4\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。</span></p><h2 id=\"ZSShZ\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">四、实践</span></h2><p id=\"u69ce8478\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。</span></p><h3 id=\"SHpjP\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. 编译相关的重* 要参数</span></h3><ul class=\"ne-ul\"><li id=\"uc435efd1\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">-XX:+TieredCompilation：开启分层编译，JDK8之后默认开启</span></li><li id=\"ub2e5b875\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">-XX:+CICompilerCount=N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 = 1:2</span></li></ul><ul class=\"ne-ul\"><li id=\"uec84e4b2\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">-XX:TierXBackEdgeThreshold：OSR编译的阈值</span></li><li id=\"uede9afc6\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">-XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值</span></li></ul><ul class=\"ne-ul\"><li id=\"ua04d67fe\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">-XX:TierXCompileThreshold：开启分层编译后的编译阈值</span></li><li id=\"u70d1c5e4\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">-XX:ReservedCodeCacheSize：codeCache最大大小</span></li></ul><ul class=\"ne-ul\"><li id=\"u6a743eef\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 12px; background-color: rgb(253, 253, 253)\">-XX:InitialCodeCacheSize：codeCache初始大小</span></li></ul><p id=\"u7314e4cf\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。</span></p><p id=\"uaf052c6c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。</span></p><h3 id=\"tIo0Z\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2. 通过JITwatch分析编译日志</span></h3><p id=\"ufec14627\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile=LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。</span></p><p id=\"u8ea668ce\" class=\"ne-p\"><span id=\"uc066bc4c\"></span><span id=\"u92756ac9\"></span></p><p id=\"u6710110f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：</span></p><p id=\"u7347bdbc\" class=\"ne-p\"><span id=\"u036811d2\"></span></p><p id=\"u3751b3a7\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。</span></p><p id=\"u086efc56\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。</span></p><h3 id=\"aBz3d\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 使用Graal编译器</span></h3><p id=\"u50282e4f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。</span></p><p id=\"uc836cb46\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。</span></p><p id=\"u836e833d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。</span></p><p id=\"ud55d64c2\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。</span></p><p id=\"u5ca3f3ab\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。</span></p><p id=\"u151f8046\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">使用Graal编译器后性能表现</span></strong></p><p id=\"ub6741c38\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在我们的线上服务中，启用Graal编译后，TP9999从60ms -&gt; 50ms ，下降10ms，下降幅度达16.7%。</span></p><p id=\"u8496a364\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。</span></p><p id=\"ue314a011\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Graal编译器的问题</span></strong></p><p id=\"uac6600aa\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。</span></p><p id=\"uf8a76620\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。</span></p><h2 id=\"KwkdK\"><span class=\"ne-text\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">五、总结</span></h2><p id=\"u281a9968\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。</span></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"Cs0yO\" id=\"Cs0yO\"><span data-lake-id=\"u79cbf014\" id=\"u79cbf014\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">一、导读</span></h2><p data-lake-id=\"u9ba95b5d\" id=\"u9ba95b5d\"><span data-lake-id=\"ucb18b4b4\" id=\"ucb18b4b4\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。</span></p><p data-lake-id=\"ued827280\" id=\"ued827280\"><span data-lake-id=\"uf574041f\" id=\"uf574041f\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</span></p><p data-lake-id=\"u7fb4cb1f\" id=\"u7fb4cb1f\"><span data-lake-id=\"u87244cdf\" id=\"u87244cdf\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</span></p><h2 data-lake-id=\"wnC6p\" id=\"wnC6p\"><span data-lake-id=\"uf7c90a1b\" id=\"uf7c90a1b\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">二、Java的执行过程</span></h2><p data-lake-id=\"u12864b35\" id=\"u12864b35\"><span data-lake-id=\"u327161a7\" id=\"u327161a7\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。</span></p><p data-lake-id=\"ubfba9b69\" id=\"ubfba9b69\"><span data-lake-id=\"uc1f7083d\" id=\"uc1f7083d\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：</span></p><p data-lake-id=\"u1e42c372\" id=\"u1e42c372\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u1d2758b1-072d-47c8-83ab-66e8e8a60fe%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u31ddb444%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h3 data-lake-id=\"xlpT6\" id=\"xlpT6\"><span data-lake-id=\"u830632a4\" id=\"u830632a4\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. JVM中的编译器</span></h3><p data-lake-id=\"ueb3a9486\" id=\"ueb3a9486\"><span data-lake-id=\"uf4cff6cf\" id=\"uf4cff6cf\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。</span></p><p data-lake-id=\"uef50e2e1\" id=\"uef50e2e1\"><strong><span data-lake-id=\"ue87a2edd\" id=\"ue87a2edd\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Client Compiler</span></strong></p><p data-lake-id=\"uf03a866c\" id=\"uf03a866c\"><span data-lake-id=\"ua03c89c9\" id=\"ua03c89c9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：</span></p><ul list=\"u4fa4615e\"><li fid=\"u760aed5d\" data-lake-id=\"ued9a728f\" id=\"ued9a728f\"><span data-lake-id=\"u5c8fc5e6\" id=\"u5c8fc5e6\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。</span></li><li fid=\"u760aed5d\" data-lake-id=\"u5d1ab90b\" id=\"u5d1ab90b\"><span data-lake-id=\"u4ff33f44\" id=\"u4ff33f44\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。</span></li><li fid=\"u760aed5d\" data-lake-id=\"ubb246e87\" id=\"ubb246e87\"><span data-lake-id=\"u5c6b057f\" id=\"u5c6b057f\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。</span></li></ul><p data-lake-id=\"uea448329\" id=\"uea448329\"><strong><span data-lake-id=\"ua1847de5\" id=\"ua1847de5\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Server Compiler</span></strong></p><p data-lake-id=\"uf2633e05\" id=\"uf2633e05\"><span data-lake-id=\"u350aa2c8\" id=\"u350aa2c8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。</span></p><p data-lake-id=\"u7988657a\" id=\"u7988657a\"><strong><span data-lake-id=\"u1d4609ac\" id=\"u1d4609ac\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">C2 Compiler</span></strong></p><p data-lake-id=\"u913e7486\" id=\"u913e7486\"><span data-lake-id=\"u05e84e83\" id=\"u05e84e83\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在Hotspot VM中，默认的Server Compiler是C2编译器。</span></p><p data-lake-id=\"ua7428ad8\" id=\"ua7428ad8\"><span data-lake-id=\"u3fc16a97\" id=\"u3fc16a97\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。</span></p><p data-lake-id=\"uce8b62bd\" id=\"uce8b62bd\"><span data-lake-id=\"u8945b616\" id=\"u8945b616\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。</span></p><p data-lake-id=\"u0818e196\" id=\"u0818e196\"><span data-lake-id=\"u5040fbc3\" id=\"u5040fbc3\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：</span></p><p data-lake-id=\"u402a817e\" id=\"u402a817e\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u5d0840bf-f90e-4525-9c6f-13f824c35af%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u73cf5869%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"ub59ca60c\" id=\"ub59ca60c\"><strong><span data-lake-id=\"u6bb5074d\" id=\"u6bb5074d\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Graal Compiler</span></strong></p><p data-lake-id=\"u25663e3f\" id=\"u25663e3f\"><span data-lake-id=\"ue68ddb9e\" id=\"ue68ddb9e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：</span></p><ul list=\"ud37cf9b9\"><li fid=\"u8d5bc934\" data-lake-id=\"u6c44c352\" id=\"u6c44c352\"><span data-lake-id=\"u8e1eeaff\" id=\"u8e1eeaff\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。</span></li><li fid=\"u8d5bc934\" data-lake-id=\"ufab1c16a\" id=\"ufab1c16a\"><span data-lake-id=\"u7a7120d7\" id=\"u7a7120d7\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。</span></li><li fid=\"u8d5bc934\" data-lake-id=\"ua3f4eb0c\" id=\"ua3f4eb0c\"><span data-lake-id=\"u7f15d197\" id=\"u7f15d197\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">更深层次的优化，比如虚函数的内联、部分逃逸分析等。</span></li></ul><p data-lake-id=\"u94a3a120\" id=\"u94a3a120\"><span data-lake-id=\"u3ba1d0d8\" id=\"u3ba1d0d8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。</span></p><h3 data-lake-id=\"LFlag\" id=\"LFlag\"><span data-lake-id=\"u92bdc542\" id=\"u92bdc542\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2. 分层编译</span></h3><p data-lake-id=\"u5d4c4162\" id=\"u5d4c4162\"><span data-lake-id=\"u77e9e587\" id=\"u77e9e587\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：</span></p><ol list=\"ufbfdc759\"><li fid=\"u7ca234d9\" data-lake-id=\"u81c95631\" id=\"u81c95631\"><span data-lake-id=\"u29ddc198\" id=\"u29ddc198\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">解释执行。</span></li><li fid=\"u7ca234d9\" data-lake-id=\"u7ed1d697\" id=\"u7ed1d697\"><span data-lake-id=\"ufcbc8d2c\" id=\"ufcbc8d2c\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">执行不带profiling的C1代码。</span></li><li fid=\"u7ca234d9\" data-lake-id=\"u49d682cb\" id=\"u49d682cb\"><span data-lake-id=\"ube90ff7c\" id=\"ube90ff7c\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。</span></li><li fid=\"u7ca234d9\" data-lake-id=\"ube8d2bab\" id=\"ube8d2bab\"><span data-lake-id=\"u022b16f1\" id=\"u022b16f1\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">执行带所有profiling的C1代码。</span></li><li fid=\"u7ca234d9\" data-lake-id=\"ub4dce0bc\" id=\"ub4dce0bc\"><span data-lake-id=\"u76cc0a04\" id=\"u76cc0a04\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">执行C2代码。</span></li></ol><p data-lake-id=\"u9cda71b8\" id=\"u9cda71b8\"><span data-lake-id=\"uc130c400\" id=\"uc130c400\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。</span></p><p data-lake-id=\"u70441bfa\" id=\"u70441bfa\"><span data-lake-id=\"u338336d1\" id=\"u338336d1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层&gt;2层&gt;3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：</span></p><p data-lake-id=\"uf4a98af1\" id=\"uf4a98af1\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u00167f2d-39df-47b8-9590-155845fd8c9%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22ufd64748b%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><ul list=\"u6d98c4b1\"><li fid=\"u677af520\" data-lake-id=\"ua17cdb09\" id=\"ua17cdb09\"><span data-lake-id=\"u5bbc3f54\" id=\"u5bbc3f54\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。</span></li><li fid=\"u677af520\" data-lake-id=\"uf8c6ae96\" id=\"uf8c6ae96\"><span data-lake-id=\"u38cb20b2\" id=\"u38cb20b2\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果方法比较小（比如Java服务中常见的getter/setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。</span></li><li fid=\"u677af520\" data-lake-id=\"u0828df32\" id=\"u0828df32\"><span data-lake-id=\"u4f2ee4f7\" id=\"u4f2ee4f7\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。</span></li><li fid=\"u677af520\" data-lake-id=\"u98768a48\" id=\"u98768a48\"><span data-lake-id=\"ua2283f6a\" id=\"ua2283f6a\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提到C1中的执行效率是1层&gt;2层&gt;3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。</span></li><li fid=\"u677af520\" data-lake-id=\"u55d9b12f\" id=\"u55d9b12f\"><span data-lake-id=\"ub10ae397\" id=\"ub10ae397\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。</span></li></ul><p data-lake-id=\"u806c9da6\" id=\"u806c9da6\"><span data-lake-id=\"u8ff221d9\" id=\"u8ff221d9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。</span></p><h3 data-lake-id=\"NWxMz\" id=\"NWxMz\"><span data-lake-id=\"u6420fe54\" id=\"u6420fe54\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 即时编译的触发</span></h3><p data-lake-id=\"u985084f9\" id=\"u985084f9\"><span data-lake-id=\"uf1e4495d\" id=\"uf1e4495d\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：</span></p><p data-lake-id=\"ubec05133\" id=\"ubec05133\"><span data-lake-id=\"ue8d7c2e3\" id=\"ue8d7c2e3\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环回边</span></p><p data-lake-id=\"u69d2defb\" id=\"u69d2defb\"><strong><span data-lake-id=\"u55fe2af1\" id=\"u55fe2af1\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"uc00f6a8c\" id=\"uc00f6a8c\"> </span><strong><span data-lake-id=\"u5c1cc453\" id=\"u5c1cc453\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u6df2c4e6\" id=\"u6df2c4e6\"> </span><strong><span data-lake-id=\"u0bfa957f\" id=\"u0bfa957f\" style=\"color: rgb(255, 198, 109)\">nlp</span></strong><span data-lake-id=\"u0b290c17\" id=\"u0b290c17\" style=\"color: rgb(208, 208, 255)\">(Object obj)</span><span data-lake-id=\"u0bc535f8\" id=\"u0bc535f8\"> </span><span data-lake-id=\"u350a87ab\" id=\"u350a87ab\">{   </span><strong><span data-lake-id=\"u351ea141\" id=\"u351ea141\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u9f9d77f8\" id=\"u9f9d77f8\"> sum = </span><span data-lake-id=\"u18c65261\" id=\"u18c65261\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u5a9c373e\" id=\"u5a9c373e\">;   </span><strong><span data-lake-id=\"u942657d9\" id=\"u942657d9\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"u6b48ca21\" id=\"u6b48ca21\"> (</span><strong><span data-lake-id=\"u4636142a\" id=\"u4636142a\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u335ced49\" id=\"u335ced49\"> i = </span><span data-lake-id=\"uc9aa9cac\" id=\"uc9aa9cac\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"ubb959ba0\" id=\"ubb959ba0\">; i &lt; </span><span data-lake-id=\"u860e984a\" id=\"u860e984a\" style=\"color: rgb(165, 194, 97)\">200</span><span data-lake-id=\"uc6ea7cf0\" id=\"uc6ea7cf0\">; i++) {     sum += i;   } } </span></p><p data-lake-id=\"u3c5cbea0\" id=\"u3c5cbea0\"><span data-lake-id=\"uc9270290\" id=\"uc9270290\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。</span></p><p data-lake-id=\"u531c8a76\" id=\"u531c8a76\"><span data-lake-id=\"u565fe87e\" id=\"u565fe87e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">字节码</span></p><p data-lake-id=\"u5761b682\" id=\"u5761b682\"><span data-lake-id=\"u7f93f361\" id=\"u7f93f361\" style=\"color: rgb(109, 156, 190)\">public</span><span data-lake-id=\"u582443c7\" id=\"u582443c7\"> </span><span data-lake-id=\"u67b9c383\" id=\"u67b9c383\" style=\"color: rgb(165, 194, 97)\">void nlp(java.lang.Object);</span><span data-lake-id=\"ue784b1c5\" id=\"ue784b1c5\">     </span><span data-lake-id=\"u26fb2adc\" id=\"u26fb2adc\" style=\"color: rgb(109, 156, 190)\">Code</span><span data-lake-id=\"ucb9f8bb3\" id=\"ucb9f8bb3\">:</span><span data-lake-id=\"ub9b9120f\" id=\"ub9b9120f\">        </span><span data-lake-id=\"ud6695f9f\" id=\"ud6695f9f\" style=\"color: rgb(109, 156, 190)\">0</span><span data-lake-id=\"u64925a66\" id=\"u64925a66\">: </span><span data-lake-id=\"ufe6e0797\" id=\"ufe6e0797\" style=\"color: rgb(165, 194, 97)\">iconst_0</span><span data-lake-id=\"u873edf41\" id=\"u873edf41\">        </span><span data-lake-id=\"u6a5ce436\" id=\"u6a5ce436\" style=\"color: rgb(109, 156, 190)\">1</span><span data-lake-id=\"u8311b4d9\" id=\"u8311b4d9\">: </span><span data-lake-id=\"ubece4e17\" id=\"ubece4e17\" style=\"color: rgb(165, 194, 97)\">istore_1</span><span data-lake-id=\"u3be804e0\" id=\"u3be804e0\">        </span><span data-lake-id=\"ud0cbfbbe\" id=\"ud0cbfbbe\" style=\"color: rgb(109, 156, 190)\">2</span><span data-lake-id=\"u3189b814\" id=\"u3189b814\">: </span><span data-lake-id=\"ubd548577\" id=\"ubd548577\" style=\"color: rgb(165, 194, 97)\">iconst_0</span><span data-lake-id=\"uc9d167a8\" id=\"uc9d167a8\">        </span><span data-lake-id=\"u6bc093ac\" id=\"u6bc093ac\" style=\"color: rgb(109, 156, 190)\">3</span><span data-lake-id=\"u6530d202\" id=\"u6530d202\">: </span><span data-lake-id=\"u8eb3cfb7\" id=\"u8eb3cfb7\" style=\"color: rgb(165, 194, 97)\">istore_2</span><span data-lake-id=\"u512410db\" id=\"u512410db\">        </span><span data-lake-id=\"ud978d5a8\" id=\"ud978d5a8\" style=\"color: rgb(109, 156, 190)\">4</span><span data-lake-id=\"u669d3e6f\" id=\"u669d3e6f\">: </span><span data-lake-id=\"ubd65be14\" id=\"ubd65be14\" style=\"color: rgb(165, 194, 97)\">iload_2</span><span data-lake-id=\"ue36f4602\" id=\"ue36f4602\">        </span><span data-lake-id=\"ud0d93c01\" id=\"ud0d93c01\" style=\"color: rgb(109, 156, 190)\">5</span><span data-lake-id=\"ubf5f0ba0\" id=\"ubf5f0ba0\">: </span><span data-lake-id=\"u3742a518\" id=\"u3742a518\" style=\"color: rgb(165, 194, 97)\">sipush        200</span><span data-lake-id=\"ucc4d8f33\" id=\"ucc4d8f33\">        </span><span data-lake-id=\"u6e7389f8\" id=\"u6e7389f8\" style=\"color: rgb(109, 156, 190)\">8</span><span data-lake-id=\"u1de88ac6\" id=\"u1de88ac6\">: </span><span data-lake-id=\"u0a5c9809\" id=\"u0a5c9809\" style=\"color: rgb(165, 194, 97)\">if_icmpge     21</span><span data-lake-id=\"ufc43bfe0\" id=\"ufc43bfe0\">       </span><span data-lake-id=\"u315975e6\" id=\"u315975e6\" style=\"color: rgb(109, 156, 190)\">11</span><span data-lake-id=\"u0572ce9a\" id=\"u0572ce9a\">: </span><span data-lake-id=\"uc7cf0197\" id=\"uc7cf0197\" style=\"color: rgb(165, 194, 97)\">iload_1</span><span data-lake-id=\"ue0d46c3d\" id=\"ue0d46c3d\">       </span><span data-lake-id=\"u5b59f5b6\" id=\"u5b59f5b6\" style=\"color: rgb(109, 156, 190)\">12</span><span data-lake-id=\"uacf67c57\" id=\"uacf67c57\">: </span><span data-lake-id=\"u6bdedcd0\" id=\"u6bdedcd0\" style=\"color: rgb(165, 194, 97)\">iload_2</span><span data-lake-id=\"u5bc49b3f\" id=\"u5bc49b3f\">       </span><span data-lake-id=\"u0fedadcf\" id=\"u0fedadcf\" style=\"color: rgb(109, 156, 190)\">13</span><span data-lake-id=\"u8ab48e29\" id=\"u8ab48e29\">: </span><span data-lake-id=\"u6dcb0ccb\" id=\"u6dcb0ccb\" style=\"color: rgb(165, 194, 97)\">iadd</span><span data-lake-id=\"ud3efc749\" id=\"ud3efc749\">       </span><span data-lake-id=\"ue1c05f62\" id=\"ue1c05f62\" style=\"color: rgb(109, 156, 190)\">14</span><span data-lake-id=\"u010bf9c0\" id=\"u010bf9c0\">: </span><span data-lake-id=\"uafd82c18\" id=\"uafd82c18\" style=\"color: rgb(165, 194, 97)\">istore_1</span><span data-lake-id=\"u459195f7\" id=\"u459195f7\">       </span><span data-lake-id=\"ucf3c2563\" id=\"ucf3c2563\" style=\"color: rgb(109, 156, 190)\">15</span><span data-lake-id=\"u698fa8ee\" id=\"u698fa8ee\">: </span><span data-lake-id=\"ucd7b3ed4\" id=\"ucd7b3ed4\" style=\"color: rgb(165, 194, 97)\">iinc          2, 1</span><span data-lake-id=\"u536fc97e\" id=\"u536fc97e\">       </span><span data-lake-id=\"u9dd7675b\" id=\"u9dd7675b\" style=\"color: rgb(109, 156, 190)\">18</span><span data-lake-id=\"u4d430574\" id=\"u4d430574\">: </span><span data-lake-id=\"ua429c894\" id=\"ua429c894\" style=\"color: rgb(165, 194, 97)\">goto          4</span><span data-lake-id=\"uc5f2fa6f\" id=\"uc5f2fa6f\">       </span><span data-lake-id=\"uc6386555\" id=\"uc6386555\" style=\"color: rgb(109, 156, 190)\">21</span><span data-lake-id=\"u8fdaa1fd\" id=\"u8fdaa1fd\">: </span><span data-lake-id=\"u3cfc3a2d\" id=\"u3cfc3a2d\" style=\"color: rgb(165, 194, 97)\">return</span><span data-lake-id=\"uf950f59b\" id=\"uf950f59b\"> </span></p><p data-lake-id=\"ue4d45031\" id=\"ue4d45031\"><span data-lake-id=\"ue3d7f7ff\" id=\"ue3d7f7ff\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。</span></p><p data-lake-id=\"u23b4bca4\" id=\"u23b4bca4\"><span data-lake-id=\"u039b2381\" id=\"u039b2381\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。</span></p><p data-lake-id=\"u93e513f3\" id=\"u93e513f3\"><span data-lake-id=\"u1e551d47\" id=\"u1e551d47\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：</span></p><ul list=\"u6ab94ad4\"><li fid=\"u57201c19\" data-lake-id=\"ud96643eb\" id=\"ud96643eb\"><span data-lake-id=\"u8a3f715b\" id=\"u8a3f715b\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。</span></li><li fid=\"u57201c19\" data-lake-id=\"ua10d10b6\" id=\"ua10d10b6\"><span data-lake-id=\"u2e4d1d1c\" id=\"u2e4d1d1c\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。</span></li></ul><p data-lake-id=\"u37a28b2d\" id=\"u37a28b2d\"><span data-lake-id=\"ua27e308b\" id=\"ua27e308b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">分层编译触发条件公式</span></p><p data-lake-id=\"uf3ca8d1f\" id=\"uf3ca8d1f\"><span data-lake-id=\"u57c335cd\" id=\"u57c335cd\">i &gt; TierXInvocationThreshold * s </span><strong><span data-lake-id=\"u9b53205d\" id=\"u9b53205d\" style=\"color: rgb(255, 198, 109)\">||</span></strong><span data-lake-id=\"ub1c5d4a5\" id=\"ub1c5d4a5\"> (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + </span><strong><span data-lake-id=\"u91b32411\" id=\"u91b32411\" style=\"color: rgb(194, 98, 48)\">b </span></strong><span data-lake-id=\"u094afc9a\" id=\"u094afc9a\">&gt; TierXCompileThreshold * s)  i为调用次数，</span><strong><span data-lake-id=\"u2afca3f1\" id=\"u2afca3f1\" style=\"color: rgb(194, 98, 48)\">b是循环回边次数 </span></strong></p><p data-lake-id=\"u7ebf275b\" id=\"u7ebf275b\"><span data-lake-id=\"u3b3b2893\" id=\"u3b3b2893\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。</span></p><h2 data-lake-id=\"crUWZ\" id=\"crUWZ\"><span data-lake-id=\"u757a4881\" id=\"u757a4881\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">三、编译优化</span></h2><p data-lake-id=\"ua9993f32\" id=\"ua9993f32\"><span data-lake-id=\"u480e6a95\" id=\"u480e6a95\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。</span></p><h3 data-lake-id=\"IcPt7\" id=\"IcPt7\"><span data-lake-id=\"uc3c2de92\" id=\"uc3c2de92\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. 中间表达形式（Intermediate Representation）</span></h3><p data-lake-id=\"u4df43154\" id=\"u4df43154\"><span data-lake-id=\"u28cc7239\" id=\"u28cc7239\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</span></p><p data-lake-id=\"u43d048ce\" id=\"u43d048ce\"><span data-lake-id=\"u40883108\" id=\"u40883108\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：</span></p><p data-lake-id=\"u05264e55\" id=\"u05264e55\"><span data-lake-id=\"u63eeae2c\" id=\"u63eeae2c\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">SSA IR</span></p><p data-lake-id=\"u4b25be56\" id=\"u4b25be56\"><span data-lake-id=\"u16477a02\" id=\"u16477a02\" style=\"color: rgb(109, 156, 190)\">Plain</span><span data-lake-id=\"ua1cdfd03\" id=\"ua1cdfd03\"> </span><span data-lake-id=\"u2fc7734c\" id=\"u2fc7734c\" style=\"color: rgb(165, 194, 97)\">Text</span><span data-lake-id=\"u72d18f97\" id=\"u72d18f97\"> </span><span data-lake-id=\"ua0fdd1bd\" id=\"ua0fdd1bd\" style=\"color: rgb(109, 156, 190)\">{</span><span data-lake-id=\"u41f35924\" id=\"u41f35924\">   </span><span data-lake-id=\"u38a5f1cd\" id=\"u38a5f1cd\" style=\"color: rgb(109, 156, 190)\">a</span><span data-lake-id=\"u90a865a5\" id=\"u90a865a5\"> = </span><span data-lake-id=\"u9e4cb04a\" id=\"u9e4cb04a\" style=\"color: rgb(165, 194, 97)\">1;</span><span data-lake-id=\"u615e2916\" id=\"u615e2916\">   </span><span data-lake-id=\"ud99a34f2\" id=\"ud99a34f2\" style=\"color: rgb(109, 156, 190)\">a</span><span data-lake-id=\"u75d45548\" id=\"u75d45548\"> = </span><span data-lake-id=\"ua5a8da49\" id=\"ua5a8da49\" style=\"color: rgb(165, 194, 97)\">2;</span><span data-lake-id=\"u315c1d85\" id=\"u315c1d85\">   </span><span data-lake-id=\"u87c53a90\" id=\"u87c53a90\" style=\"color: rgb(109, 156, 190)\">b</span><span data-lake-id=\"u6be1085a\" id=\"u6be1085a\"> = </span><span data-lake-id=\"u4630941d\" id=\"u4630941d\" style=\"color: rgb(165, 194, 97)\">a;</span><span data-lake-id=\"u2794fb0a\" id=\"u2794fb0a\"> </span><span data-lake-id=\"u5aa07399\" id=\"u5aa07399\" style=\"color: rgb(109, 156, 190)\">}</span><span data-lake-id=\"u2c995706\" id=\"u2c995706\"> </span></p><p data-lake-id=\"u0bf689e0\" id=\"u0bf689e0\"><span data-lake-id=\"u7d77a231\" id=\"u7d77a231\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。</span></p><p data-lake-id=\"ud1393c2f\" id=\"ud1393c2f\"><span data-lake-id=\"ud4adae1b\" id=\"ud4adae1b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面代码的SSA IR形式的伪代码可以表示为：</span></p><p data-lake-id=\"u4d0cf115\" id=\"u4d0cf115\"><span data-lake-id=\"u259dc5e6\" id=\"u259dc5e6\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">SSA IR</span></p><p data-lake-id=\"uf0842f97\" id=\"uf0842f97\"><span data-lake-id=\"u572d4a14\" id=\"u572d4a14\" style=\"color: rgb(109, 156, 190)\">Plain</span><span data-lake-id=\"u4f1d23a3\" id=\"u4f1d23a3\"> </span><span data-lake-id=\"uf7d6d5b8\" id=\"uf7d6d5b8\" style=\"color: rgb(165, 194, 97)\">Text</span><span data-lake-id=\"u80b7eef2\" id=\"u80b7eef2\"> </span><span data-lake-id=\"ub207a403\" id=\"ub207a403\" style=\"color: rgb(109, 156, 190)\">{</span><span data-lake-id=\"ue29793fb\" id=\"ue29793fb\">   </span><span data-lake-id=\"ufee210b1\" id=\"ufee210b1\" style=\"color: rgb(109, 156, 190)\">a_1</span><span data-lake-id=\"u1a8e9582\" id=\"u1a8e9582\"> = </span><span data-lake-id=\"u2a72aa02\" id=\"u2a72aa02\" style=\"color: rgb(165, 194, 97)\">1;</span><span data-lake-id=\"u557f0a61\" id=\"u557f0a61\">   </span><span data-lake-id=\"ufaf617f5\" id=\"ufaf617f5\" style=\"color: rgb(109, 156, 190)\">a_2</span><span data-lake-id=\"ude4b56fe\" id=\"ude4b56fe\"> = </span><span data-lake-id=\"u27bf45f4\" id=\"u27bf45f4\" style=\"color: rgb(165, 194, 97)\">2;</span><span data-lake-id=\"u5bc547a8\" id=\"u5bc547a8\">   </span><span data-lake-id=\"u751e2895\" id=\"u751e2895\" style=\"color: rgb(109, 156, 190)\">b_1</span><span data-lake-id=\"u3333e4c5\" id=\"u3333e4c5\"> = </span><span data-lake-id=\"u8dfcdeed\" id=\"u8dfcdeed\" style=\"color: rgb(165, 194, 97)\">a_2;</span><span data-lake-id=\"u8ff0fc69\" id=\"u8ff0fc69\"> </span><span data-lake-id=\"u465332f4\" id=\"u465332f4\" style=\"color: rgb(109, 156, 190)\">}</span><span data-lake-id=\"u4f4737ce\" id=\"u4f4737ce\"> </span></p><p data-lake-id=\"ua3a0347a\" id=\"ua3a0347a\"><span data-lake-id=\"u614730a7\" id=\"u614730a7\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。</span></p><p data-lake-id=\"u8edd9308\" id=\"u8edd9308\"><span data-lake-id=\"u0c9a2f5c\" id=\"u0c9a2f5c\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子：</span></p><p data-lake-id=\"u58545f6b\" id=\"u58545f6b\"><span data-lake-id=\"u6ab8150c\" id=\"u6ab8150c\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p data-lake-id=\"u826f45b2\" id=\"u826f45b2\"><strong><span data-lake-id=\"u364c2f01\" id=\"u364c2f01\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u00d696f8\" id=\"u00d696f8\"> </span><strong><span data-lake-id=\"u5567c5cb\" id=\"u5567c5cb\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u25d3765b\" id=\"u25d3765b\"> DeadCodeElimination{   </span><strong><span data-lake-id=\"u212aaa12\" id=\"u212aaa12\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ue96a69d1\" id=\"ue96a69d1\"> a = </span><span data-lake-id=\"uf55a78c4\" id=\"uf55a78c4\" style=\"color: rgb(165, 194, 97)\">2</span><span data-lake-id=\"u6f961d1e\" id=\"u6f961d1e\">;   </span><strong><span data-lake-id=\"u383c2bf6\" id=\"u383c2bf6\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ube191f15\" id=\"ube191f15\"> b = </span><span data-lake-id=\"u84a88a01\" id=\"u84a88a01\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u5fa2744b\" id=\"u5fa2744b\">   </span><strong><span data-lake-id=\"ub0ccdaa3\" id=\"ub0ccdaa3\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span data-lake-id=\"uf390c41c\" id=\"uf390c41c\">(</span><span data-lake-id=\"u8c966573\" id=\"u8c966573\" style=\"color: rgb(165, 194, 97)\">2</span><span data-lake-id=\"ufd6c78c2\" id=\"ufd6c78c2\"> &gt; </span><span data-lake-id=\"u9ecc7d8c\" id=\"u9ecc7d8c\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u96f375c5\" id=\"u96f375c5\">){     a = </span><span data-lake-id=\"ue0548af1\" id=\"ue0548af1\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"uf66f2c01\" id=\"uf66f2c01\">;   } </span><strong><span data-lake-id=\"u0e614abd\" id=\"u0e614abd\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span data-lake-id=\"u3979111b\" id=\"u3979111b\">{     b = </span><span data-lake-id=\"u30af7498\" id=\"u30af7498\" style=\"color: rgb(165, 194, 97)\">2</span><span data-lake-id=\"u71da1610\" id=\"u71da1610\">;   }   </span><strong><span data-lake-id=\"u2cd0fbf7\" id=\"u2cd0fbf7\" style=\"color: rgb(194, 98, 48)\">add</span></strong><span data-lake-id=\"u77a30b33\" id=\"u77a30b33\">(a,b) } </span></p><p data-lake-id=\"uf08c57dd\" id=\"uf08c57dd\"><span data-lake-id=\"u28ec796b\" id=\"u28ec796b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以得到SSA IR伪代码：</span></p><p data-lake-id=\"u3109dbb4\" id=\"u3109dbb4\"><span data-lake-id=\"ufcbf9746\" id=\"ufcbf9746\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p data-lake-id=\"u52dca725\" id=\"u52dca725\"><span data-lake-id=\"uac7bce66\" id=\"uac7bce66\" style=\"color: rgb(109, 156, 190)\">a_1</span><span data-lake-id=\"uc05ec985\" id=\"uc05ec985\"> = </span><span data-lake-id=\"u5d6db5d8\" id=\"u5d6db5d8\" style=\"color: rgb(165, 194, 97)\">2;</span><span data-lake-id=\"u3e677f1b\" id=\"u3e677f1b\"> </span><span data-lake-id=\"u68168940\" id=\"u68168940\" style=\"color: rgb(109, 156, 190)\">b_1</span><span data-lake-id=\"u8d476df6\" id=\"u8d476df6\"> = </span><span data-lake-id=\"u1a61cbac\" id=\"u1a61cbac\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"ub406747f\" id=\"ub406747f\"> </span><span data-lake-id=\"u681e693e\" id=\"u681e693e\" style=\"color: rgb(109, 156, 190)\">if</span><span data-lake-id=\"u9e75cef8\" id=\"u9e75cef8\"> </span><span data-lake-id=\"u6e854720\" id=\"u6e854720\" style=\"color: rgb(165, 194, 97)\">true:</span><span data-lake-id=\"u14f1c7ef\" id=\"u14f1c7ef\">   </span><span data-lake-id=\"u4fccc892\" id=\"u4fccc892\" style=\"color: rgb(109, 156, 190)\">a_2</span><span data-lake-id=\"u89f646ec\" id=\"u89f646ec\"> = </span><span data-lake-id=\"u0ef6dae4\" id=\"u0ef6dae4\" style=\"color: rgb(165, 194, 97)\">1;</span><span data-lake-id=\"u37301d3f\" id=\"u37301d3f\"> </span><span data-lake-id=\"u81b5a0cf\" id=\"u81b5a0cf\" style=\"color: rgb(109, 156, 190)\">else</span><span data-lake-id=\"u96f90b6b\" id=\"u96f90b6b\">   </span><span data-lake-id=\"u506e85a4\" id=\"u506e85a4\" style=\"color: rgb(109, 156, 190)\">b_2</span><span data-lake-id=\"u62bcbc3a\" id=\"u62bcbc3a\"> = </span><span data-lake-id=\"ua7df2aca\" id=\"ua7df2aca\" style=\"color: rgb(165, 194, 97)\">2;</span><span data-lake-id=\"u47b08e3e\" id=\"u47b08e3e\"> </span><span data-lake-id=\"u2e42ec4c\" id=\"u2e42ec4c\" style=\"color: rgb(109, 156, 190)\">add(a,b)</span><span data-lake-id=\"u1cdc0bc6\" id=\"u1cdc0bc6\"> </span></p><p data-lake-id=\"uad958982\" id=\"uad958982\"><span data-lake-id=\"u75c090ad\" id=\"u75c090ad\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：</span></p><p data-lake-id=\"u33e92e3c\" id=\"u33e92e3c\"><span data-lake-id=\"u9990105a\" id=\"u9990105a\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p data-lake-id=\"u400787f6\" id=\"u400787f6\"><strong><span data-lake-id=\"u53c02c20\" id=\"u53c02c20\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u375139ea\" id=\"u375139ea\"> </span><strong><span data-lake-id=\"ufb84641b\" id=\"ufb84641b\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uc41ce0fd\" id=\"uc41ce0fd\"> DeadCodeElimination{   </span><strong><span data-lake-id=\"u2032192a\" id=\"u2032192a\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u788c0051\" id=\"u788c0051\"> a = </span><span data-lake-id=\"u57aefc7d\" id=\"u57aefc7d\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u0eba5d05\" id=\"u0eba5d05\">;   </span><strong><span data-lake-id=\"uade5d7b1\" id=\"uade5d7b1\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u369dc94a\" id=\"u369dc94a\"> b = </span><span data-lake-id=\"ue24d7938\" id=\"ue24d7938\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"uac9a3b42\" id=\"uac9a3b42\">;   </span><strong><span data-lake-id=\"ueec6e9c2\" id=\"ueec6e9c2\" style=\"color: rgb(194, 98, 48)\">add</span></strong><span data-lake-id=\"u46a9ec7a\" id=\"u46a9ec7a\">(a,b) } </span></p><p data-lake-id=\"u081d4627\" id=\"u081d4627\"><span data-lake-id=\"u5775e595\" id=\"u5775e595\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。</span></p><p data-lake-id=\"ue0183cd7\" id=\"ue0183cd7\"><strong><span data-lake-id=\"u78e9d33a\" id=\"u78e9d33a\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">C1中的中间表达形式</span></strong></p><p data-lake-id=\"u6f3f6fc0\" id=\"u6f3f6fc0\"><span data-lake-id=\"u31f889ef\" id=\"u31f889ef\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。</span></p><p data-lake-id=\"ub69e2095\" id=\"ub69e2095\"><span data-lake-id=\"u221e6744\" id=\"u221e6744\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：</span></p><p data-lake-id=\"ue8bc2f53\" id=\"ue8bc2f53\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22ubc16084e-03ff-42f0-b180-ed37e87fe61%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u949b2c2b%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u1c41ea34\" id=\"u1c41ea34\"><span data-lake-id=\"u87a411fe\" id=\"u87a411fe\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。</span></p><p data-lake-id=\"ua8f98802\" id=\"ua8f98802\"><span data-lake-id=\"ue49917ae\" id=\"ue49917ae\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：</span></p><p data-lake-id=\"u10a459b3\" id=\"u10a459b3\"><span data-lake-id=\"u61d7aac2\" id=\"u61d7aac2\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">字节码构造HIR</span></p><p data-lake-id=\"u99729c37\" id=\"u99729c37\"><span data-lake-id=\"ufc16ae93\" id=\"ufc16ae93\">        字节码                     </span><strong><span data-lake-id=\"uf64b16e6\" id=\"uf64b16e6\" style=\"color: rgb(194, 98, 48)\">Local</span></strong><span data-lake-id=\"u62f94d54\" id=\"u62f94d54\"> </span><strong><span data-lake-id=\"u1f610ee2\" id=\"u1f610ee2\" style=\"color: rgb(194, 98, 48)\">Value</span></strong><span data-lake-id=\"uf478dbb9\" id=\"uf478dbb9\">             </span><strong><span data-lake-id=\"u4cf5d976\" id=\"u4cf5d976\" style=\"color: rgb(194, 98, 48)\">operand</span></strong><span data-lake-id=\"ufe445cfb\" id=\"ufe445cfb\"> </span><strong><span data-lake-id=\"u54e95853\" id=\"u54e95853\" style=\"color: rgb(194, 98, 48)\">stack</span></strong><span data-lake-id=\"u925cb707\" id=\"u925cb707\">              </span><strong><span data-lake-id=\"u33282acf\" id=\"u33282acf\" style=\"color: rgb(194, 98, 48)\">HIR</span></strong><span data-lake-id=\"u6ca7adae\" id=\"u6ca7adae\">       </span><strong><span data-lake-id=\"u0b758a71\" id=\"u0b758a71\" style=\"color: rgb(194, 98, 48)\">5</span></strong><span data-lake-id=\"udd8ac516\" id=\"udd8ac516\">: </span><strong><span data-lake-id=\"u4fcf12eb\" id=\"u4fcf12eb\" style=\"color: rgb(194, 98, 48)\">iload_1</span></strong><span data-lake-id=\"u3d85e76d\" id=\"u3d85e76d\">                  </span><span data-lake-id=\"ubab1ffb4\" id=\"ubab1ffb4\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span data-lake-id=\"ue1fd6489\" id=\"ue1fd6489\">                 </span><span data-lake-id=\"u3a760e98\" id=\"u3a760e98\" style=\"color: rgb(188, 96, 96)\">[i1]</span><span data-lake-id=\"ua3d4c4f3\" id=\"ua3d4c4f3\">       </span><strong><span data-lake-id=\"uc81d199a\" id=\"uc81d199a\" style=\"color: rgb(194, 98, 48)\">6</span></strong><span data-lake-id=\"uc0e0bbda\" id=\"uc0e0bbda\">: </span><strong><span data-lake-id=\"u995fed05\" id=\"u995fed05\" style=\"color: rgb(194, 98, 48)\">iload_2</span></strong><span data-lake-id=\"uaae14881\" id=\"uaae14881\">                  </span><span data-lake-id=\"u13770be7\" id=\"u13770be7\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span data-lake-id=\"u5be155d9\" id=\"u5be155d9\">                 </span><span data-lake-id=\"u2b901d28\" id=\"u2b901d28\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span data-lake-id=\"u94445e72\" id=\"u94445e72\">                                      ................................................   </span><strong><span data-lake-id=\"uda3c0483\" id=\"uda3c0483\" style=\"color: rgb(194, 98, 48)\">i3</span></strong><span data-lake-id=\"u52a7e140\" id=\"u52a7e140\">: </span><strong><span data-lake-id=\"u661373a1\" id=\"u661373a1\" style=\"color: rgb(194, 98, 48)\">i1</span></strong><span data-lake-id=\"ub926d116\" id=\"ub926d116\"> * </span><strong><span data-lake-id=\"ucf50eb8a\" id=\"ucf50eb8a\" style=\"color: rgb(194, 98, 48)\">i2</span></strong><span data-lake-id=\"u51dc5e7e\" id=\"u51dc5e7e\">       </span><strong><span data-lake-id=\"ufc9b40a6\" id=\"ufc9b40a6\" style=\"color: rgb(194, 98, 48)\">7</span></strong><span data-lake-id=\"u8e4c915c\" id=\"u8e4c915c\">: </span><strong><span data-lake-id=\"ub355de6b\" id=\"ub355de6b\" style=\"color: rgb(194, 98, 48)\">imul</span></strong><span data-lake-id=\"u6ea8f10f\" id=\"u6ea8f10f\">                                          </span><strong><span data-lake-id=\"u93db227a\" id=\"u93db227a\" style=\"color: rgb(194, 98, 48)\">8</span></strong><span data-lake-id=\"u13a60eac\" id=\"u13a60eac\">: </span><strong><span data-lake-id=\"u4f5efe93\" id=\"u4f5efe93\" style=\"color: rgb(194, 98, 48)\">istore_3</span></strong><span data-lake-id=\"u11544b13\" id=\"u11544b13\">                 </span><span data-lake-id=\"ua6315e9a\" id=\"ua6315e9a\" style=\"color: rgb(188, 96, 96)\">[i1,i2，i3]</span><span data-lake-id=\"u963f70a1\" id=\"u963f70a1\">              </span><span data-lake-id=\"uad88d1f2\" id=\"uad88d1f2\" style=\"color: rgb(188, 96, 96)\">[i3]</span><span data-lake-id=\"u912ac856\" id=\"u912ac856\"> </span></p><p data-lake-id=\"u48ee5c2d\" id=\"u48ee5c2d\"><span data-lake-id=\"ufd89f524\" id=\"ufd89f524\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。</span></p><p data-lake-id=\"u7ab70132\" id=\"u7ab70132\"><span data-lake-id=\"u6975bc12\" id=\"u6975bc12\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。</span></p><p data-lake-id=\"uaaf84acc\" id=\"uaaf84acc\"><strong><span data-lake-id=\"ub34b3383\" id=\"ub34b3383\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Sea-of-Nodes IR</span></strong></p><p data-lake-id=\"u658e25cf\" id=\"u658e25cf\"><span data-lake-id=\"ufc647c2a\" id=\"ufc647c2a\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：</span></p><p data-lake-id=\"u4f8ed85e\" id=\"u4f8ed85e\"><span data-lake-id=\"u94bcaa1c\" id=\"u94bcaa1c\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">example</span></p><p data-lake-id=\"ue1b45797\" id=\"ue1b45797\"><strong><span data-lake-id=\"u9aee24f6\" id=\"u9aee24f6\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u5d34837d\" id=\"u5d34837d\"> </span><strong><span data-lake-id=\"u7f15afba\" id=\"u7f15afba\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u5f5be873\" id=\"u5f5be873\"> </span><strong><span data-lake-id=\"uaff070ee\" id=\"uaff070ee\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ud4aca66c\" id=\"ud4aca66c\"> </span><strong><span data-lake-id=\"ua5e6911d\" id=\"ua5e6911d\" style=\"color: rgb(255, 198, 109)\">foo</span></strong><span data-lake-id=\"u4a2299c7\" id=\"u4a2299c7\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span data-lake-id=\"uc55bcd60\" id=\"uc55bcd60\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ub47afe7d\" id=\"ub47afe7d\" style=\"color: rgb(208, 208, 255)\"> count)</span><span data-lake-id=\"u060291f3\" id=\"u060291f3\"> </span><span data-lake-id=\"udb5605ef\" id=\"udb5605ef\">{   </span><strong><span data-lake-id=\"ua9b15b4b\" id=\"ua9b15b4b\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u54e5a2c3\" id=\"u54e5a2c3\"> sum = </span><span data-lake-id=\"uedcb80cb\" id=\"uedcb80cb\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u8609157a\" id=\"u8609157a\">;   </span><strong><span data-lake-id=\"ue5835280\" id=\"ue5835280\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"u06e37c3e\" id=\"u06e37c3e\"> (</span><strong><span data-lake-id=\"ud85ae5a3\" id=\"ud85ae5a3\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u56eefffb\" id=\"u56eefffb\"> i = </span><span data-lake-id=\"u4829c1a5\" id=\"u4829c1a5\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u842b5edd\" id=\"u842b5edd\">; i &lt; count; i++) {     sum += i;   }   </span><strong><span data-lake-id=\"u7d9a80c3\" id=\"u7d9a80c3\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"u1e5e2833\" id=\"u1e5e2833\"> sum; } </span></p><p data-lake-id=\"u775d6e99\" id=\"u775d6e99\"><span data-lake-id=\"u17d6ba5e\" id=\"u17d6ba5e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">对应的IR图如下所示：</span></p><p data-lake-id=\"u849b3569\" id=\"u849b3569\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u067f486a-9972-484a-992d-76c7a71887c%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u1cacffb7%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u76e878df\" id=\"u76e878df\"><span data-lake-id=\"u46e5cb88\" id=\"u46e5cb88\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。</span></p><p data-lake-id=\"u74891e56\" id=\"u74891e56\"><span data-lake-id=\"u1e8093b1\" id=\"u1e8093b1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。</span></p><p data-lake-id=\"u73d21a64\" id=\"u73d21a64\"><span data-lake-id=\"u0eead443\" id=\"u0eead443\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。</span></p><p data-lake-id=\"u2e3b6802\" id=\"u2e3b6802\"><strong><span data-lake-id=\"ua92f8989\" id=\"ua92f8989\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Phi And Region Nodes</span></strong></p><p data-lake-id=\"u0c506ab2\" id=\"u0c506ab2\"><span data-lake-id=\"uffbb353b\" id=\"uffbb353b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。</span></p><p data-lake-id=\"uf541b8f1\" id=\"uf541b8f1\"><span data-lake-id=\"u732b0e02\" id=\"u732b0e02\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">example</span></p><p data-lake-id=\"u87847572\" id=\"u87847572\"><strong><span data-lake-id=\"uc34b4b1a\" id=\"uc34b4b1a\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ub19f6fcc\" id=\"ub19f6fcc\"> </span><strong><span data-lake-id=\"uc74e5e32\" id=\"uc74e5e32\" style=\"color: rgb(255, 198, 109)\">test</span></strong><span data-lake-id=\"udd96f665\" id=\"udd96f665\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span data-lake-id=\"ud1edebf5\" id=\"ud1edebf5\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uba1c0ed3\" id=\"uba1c0ed3\" style=\"color: rgb(208, 208, 255)\"> x)</span><span data-lake-id=\"ub9afe97e\" id=\"ub9afe97e\"> </span><span data-lake-id=\"uc666a68d\" id=\"uc666a68d\">{ </span><strong><span data-lake-id=\"ucad97208\" id=\"ucad97208\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u6c0c245c\" id=\"u6c0c245c\"> a = </span><span data-lake-id=\"u77dd109f\" id=\"u77dd109f\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u2d05e045\" id=\"u2d05e045\">;   </span><strong><span data-lake-id=\"u66cf3b53\" id=\"u66cf3b53\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span data-lake-id=\"uda4bb364\" id=\"uda4bb364\">(x == </span><span data-lake-id=\"ud3e7a59d\" id=\"ud3e7a59d\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u4d148b66\" id=\"u4d148b66\">) {     a = </span><span data-lake-id=\"u2fb62d10\" id=\"u2fb62d10\" style=\"color: rgb(165, 194, 97)\">5</span><span data-lake-id=\"ue2026c0a\" id=\"ue2026c0a\">;   } </span><strong><span data-lake-id=\"u8c233fd3\" id=\"u8c233fd3\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span data-lake-id=\"uaef7f471\" id=\"uaef7f471\"> {     a = </span><span data-lake-id=\"u3ab3c711\" id=\"u3ab3c711\" style=\"color: rgb(165, 194, 97)\">6</span><span data-lake-id=\"ub92d66a3\" id=\"ub92d66a3\">;   }   </span><strong><span data-lake-id=\"u0ff97e70\" id=\"u0ff97e70\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"u0b928d02\" id=\"u0b928d02\"> a; } </span></p><p data-lake-id=\"u6f9997c6\" id=\"u6f9997c6\"><span data-lake-id=\"u17611fd4\" id=\"u17611fd4\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：</span></p><p data-lake-id=\"u0b83d294\" id=\"u0b83d294\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u02480518-993c-48df-90f1-c8051fc879d%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u72989f7b%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"ub73aa83d\" id=\"ub73aa83d\"><span data-lake-id=\"u86a997c9\" id=\"u86a997c9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：</span></p><p data-lake-id=\"ua97940e5\" id=\"ua97940e5\"><span data-lake-id=\"u07def3be\" id=\"u07def3be\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Phi Nodes</span></p><p data-lake-id=\"ub7994182\" id=\"ub7994182\"><span data-lake-id=\"u615351aa\" id=\"u615351aa\" style=\"color: rgb(109, 156, 190)\">int</span><span data-lake-id=\"u01aefd3c\" id=\"u01aefd3c\"> </span><span data-lake-id=\"u6496fa80\" id=\"u6496fa80\" style=\"color: rgb(165, 194, 97)\">test(int x) {</span><span data-lake-id=\"u14543976\" id=\"u14543976\">   </span><span data-lake-id=\"uc454b2d3\" id=\"uc454b2d3\" style=\"color: rgb(109, 156, 190)\">a_1</span><span data-lake-id=\"u791125e2\" id=\"u791125e2\"> = </span><span data-lake-id=\"u9aab53d8\" id=\"u9aab53d8\" style=\"color: rgb(165, 194, 97)\">0;</span><span data-lake-id=\"u23cc0e2a\" id=\"u23cc0e2a\">   </span><span data-lake-id=\"u9021f541\" id=\"u9021f541\" style=\"color: rgb(155, 133, 157)\">if(x</span><span data-lake-id=\"u4355efd9\" id=\"u4355efd9\"> =</span><span data-lake-id=\"ub04c14b8\" id=\"ub04c14b8\" style=\"color: rgb(165, 194, 97)\">= 1){</span><span data-lake-id=\"u08e86755\" id=\"u08e86755\">     </span><span data-lake-id=\"uf3d9dcd6\" id=\"uf3d9dcd6\" style=\"color: rgb(109, 156, 190)\">a_2</span><span data-lake-id=\"u7a28c57e\" id=\"u7a28c57e\"> = </span><span data-lake-id=\"uff1ab41e\" id=\"uff1ab41e\" style=\"color: rgb(165, 194, 97)\">5;</span><span data-lake-id=\"uc46faa40\" id=\"uc46faa40\">   </span><span data-lake-id=\"ubbee90d4\" id=\"ubbee90d4\" style=\"color: rgb(155, 133, 157)\">}else</span><span data-lake-id=\"u80bc5a74\" id=\"u80bc5a74\"> </span><span data-lake-id=\"ub328e887\" id=\"ub328e887\" style=\"color: rgb(165, 194, 97)\">{</span><span data-lake-id=\"u2d0dfbf0\" id=\"u2d0dfbf0\">     </span><span data-lake-id=\"u042b1a1a\" id=\"u042b1a1a\" style=\"color: rgb(109, 156, 190)\">a_3</span><span data-lake-id=\"u8d27e968\" id=\"u8d27e968\"> = </span><span data-lake-id=\"ue83e8280\" id=\"ue83e8280\" style=\"color: rgb(165, 194, 97)\">6;</span><span data-lake-id=\"u89a5a0ca\" id=\"u89a5a0ca\">   </span><span data-lake-id=\"ucf47ddbb\" id=\"ucf47ddbb\" style=\"color: rgb(109, 156, 190)\">}</span><span data-lake-id=\"u0452fd58\" id=\"u0452fd58\">   </span><span data-lake-id=\"ub41aa92d\" id=\"ub41aa92d\" style=\"color: rgb(109, 156, 190)\">a_4</span><span data-lake-id=\"uca00841b\" id=\"uca00841b\"> = </span><span data-lake-id=\"u9c5278e3\" id=\"u9c5278e3\" style=\"color: rgb(165, 194, 97)\">Phi(a_2,a_3);</span><span data-lake-id=\"u9fc8ef13\" id=\"u9fc8ef13\">   </span><span data-lake-id=\"ucf7ac6f8\" id=\"ucf7ac6f8\" style=\"color: rgb(109, 156, 190)\">return</span><span data-lake-id=\"ube3ae70b\" id=\"ube3ae70b\"> </span><span data-lake-id=\"uc7969287\" id=\"uc7969287\" style=\"color: rgb(165, 194, 97)\">a_4;</span><span data-lake-id=\"u2fd17a48\" id=\"u2fd17a48\"> </span><span data-lake-id=\"uf9719f09\" id=\"uf9719f09\" style=\"color: rgb(109, 156, 190)\">}</span><span data-lake-id=\"u33ac3a94\" id=\"u33ac3a94\"> </span></p><p data-lake-id=\"uaf1df5d6\" id=\"uaf1df5d6\"><strong><span data-lake-id=\"u7df85a7f\" id=\"u7df85a7f\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Global Value Numbering</span></strong></p><p data-lake-id=\"ua4349034\" id=\"ua4349034\"><span data-lake-id=\"u3bd742e4\" id=\"u3bd742e4\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。</span></p><p data-lake-id=\"u61e5e340\" id=\"u61e5e340\"><span data-lake-id=\"u62ec4488\" id=\"u62ec4488\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：</span></p><p data-lake-id=\"u8ae7675e\" id=\"u8ae7675e\"><span data-lake-id=\"uf5b6f6a8\" id=\"uf5b6f6a8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN</span></p><p data-lake-id=\"ube2c7230\" id=\"ube2c7230\"><span data-lake-id=\"u63f10904\" id=\"u63f10904\">a = 1; b = 2; c = a + b; d = a + b; e = d; </span></p><p data-lake-id=\"ud8bb529c\" id=\"ud8bb529c\"><span data-lake-id=\"u01f928f5\" id=\"u01f928f5\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。</span></p><p data-lake-id=\"u7a19670e\" id=\"u7a19670e\"><span data-lake-id=\"ue29fb4d9\" id=\"ue29fb4d9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。</span></p><h3 data-lake-id=\"WjweJ\" id=\"WjweJ\"><span data-lake-id=\"u16fdff2c\" id=\"u16fdff2c\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2.方法内联</span></h3><p data-lake-id=\"uab2e34da\" id=\"uab2e34da\"><span data-lake-id=\"u6d6a31e5\" id=\"u6d6a31e5\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。</span></p><p data-lake-id=\"u17fda851\" id=\"u17fda851\"><span data-lake-id=\"u06521531\" id=\"u06521531\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）：</span></p><p data-lake-id=\"ubcd34f92\" id=\"ubcd34f92\"><span data-lake-id=\"uac801cbb\" id=\"uac801cbb\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法内联的过程</span></p><p data-lake-id=\"u95b1312b\" id=\"u95b1312b\"><strong><span data-lake-id=\"u1d8221c4\" id=\"u1d8221c4\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u30660cd0\" id=\"u30660cd0\"> </span><strong><span data-lake-id=\"u625c404d\" id=\"u625c404d\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ud1fdea8e\" id=\"ud1fdea8e\"> </span><strong><span data-lake-id=\"u5e1500b0\" id=\"u5e1500b0\" style=\"color: rgb(194, 98, 48)\">boolean</span></strong><span data-lake-id=\"u427b95fa\" id=\"u427b95fa\"> flag = </span><strong><span data-lake-id=\"uaa53323e\" id=\"uaa53323e\" style=\"color: rgb(194, 98, 48)\">true</span></strong><span data-lake-id=\"ucf519162\" id=\"ucf519162\">; </span><strong><span data-lake-id=\"uaca2504d\" id=\"uaca2504d\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u964c63fd\" id=\"u964c63fd\"> </span><strong><span data-lake-id=\"ube2633c0\" id=\"ube2633c0\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"uf6442832\" id=\"uf6442832\"> </span><strong><span data-lake-id=\"u4be91c20\" id=\"u4be91c20\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u541865a3\" id=\"u541865a3\"> value0 = </span><span data-lake-id=\"ud292d3b1\" id=\"ud292d3b1\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u1cf3ce74\" id=\"u1cf3ce74\">; </span><strong><span data-lake-id=\"u6bb67b7f\" id=\"u6bb67b7f\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u7e1d2769\" id=\"u7e1d2769\"> </span><strong><span data-lake-id=\"u6a375e6c\" id=\"u6a375e6c\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u99e851e5\" id=\"u99e851e5\"> </span><strong><span data-lake-id=\"u0c5e5e26\" id=\"u0c5e5e26\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ufa089235\" id=\"ufa089235\"> value1 = </span><span data-lake-id=\"uab5e573f\" id=\"uab5e573f\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"udf702c1b\" id=\"udf702c1b\">;  </span><strong><span data-lake-id=\"ubb6b4ba9\" id=\"ubb6b4ba9\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ud353139b\" id=\"ud353139b\"> </span><strong><span data-lake-id=\"udd65616a\" id=\"udd65616a\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u3ef92ad9\" id=\"u3ef92ad9\"> </span><strong><span data-lake-id=\"u6eafd385\" id=\"u6eafd385\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ucf9daaff\" id=\"ucf9daaff\"> </span><strong><span data-lake-id=\"u94dac463\" id=\"u94dac463\" style=\"color: rgb(255, 198, 109)\">foo</span></strong><span data-lake-id=\"u2bbbb564\" id=\"u2bbbb564\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span data-lake-id=\"ub5c9965f\" id=\"ub5c9965f\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u1921637a\" id=\"u1921637a\" style=\"color: rgb(208, 208, 255)\"> value)</span><span data-lake-id=\"u4b24e353\" id=\"u4b24e353\"> </span><span data-lake-id=\"u1ed56f8c\" id=\"u1ed56f8c\">{     </span><strong><span data-lake-id=\"u820588d3\" id=\"u820588d3\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uc460b338\" id=\"uc460b338\"> result = bar(flag);     </span><strong><span data-lake-id=\"u5d8240f8\" id=\"u5d8240f8\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span data-lake-id=\"u462ca582\" id=\"u462ca582\"> (result != </span><span data-lake-id=\"u041af88b\" id=\"u041af88b\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u313c901f\" id=\"u313c901f\">) {         </span><strong><span data-lake-id=\"ud59fb9f7\" id=\"ud59fb9f7\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"ubd95647a\" id=\"ubd95647a\"> result;     } </span><strong><span data-lake-id=\"u6ed8e474\" id=\"u6ed8e474\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span data-lake-id=\"u04874033\" id=\"u04874033\"> {         </span><strong><span data-lake-id=\"ue34b8ba0\" id=\"ue34b8ba0\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"u3dce52c1\" id=\"u3dce52c1\"> value;     } }  </span><strong><span data-lake-id=\"u43a8c1e4\" id=\"u43a8c1e4\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ua339a9d2\" id=\"ua339a9d2\"> </span><strong><span data-lake-id=\"u36649782\" id=\"u36649782\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u0f2115bf\" id=\"u0f2115bf\"> </span><strong><span data-lake-id=\"u336d3299\" id=\"u336d3299\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ufc4e145d\" id=\"ufc4e145d\"> </span><strong><span data-lake-id=\"ub33ac8d3\" id=\"ub33ac8d3\" style=\"color: rgb(255, 198, 109)\">bar</span></strong><span data-lake-id=\"u56104afb\" id=\"u56104afb\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span data-lake-id=\"u16e17733\" id=\"u16e17733\" style=\"color: rgb(194, 98, 48)\">boolean</span></strong><span data-lake-id=\"u04ea2858\" id=\"u04ea2858\" style=\"color: rgb(208, 208, 255)\"> flag)</span><span data-lake-id=\"uaf62250f\" id=\"uaf62250f\"> </span><span data-lake-id=\"u8e3e2d89\" id=\"u8e3e2d89\">{     </span><strong><span data-lake-id=\"u13ff5104\" id=\"u13ff5104\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"u1d7ca7b1\" id=\"u1d7ca7b1\"> flag ? value0 : value1; } </span></p><p data-lake-id=\"u2aa4fc90\" id=\"u2aa4fc90\"><span data-lake-id=\"u76bd1e0b\" id=\"u76bd1e0b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">bar方法的IR图：</span></p><p data-lake-id=\"u275a5225\" id=\"u275a5225\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u00314411-872a-40d9-aea6-0ad9e202529%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u984ed21c%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u4238b547\" id=\"u4238b547\"><span data-lake-id=\"u9e041004\" id=\"u9e041004\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联后的IR图：</span></p><p data-lake-id=\"ubce024a7\" id=\"ubce024a7\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22ub3180e50-548d-46f5-bac2-5c9ff693457%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u47efc8da%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u460869f9\" id=\"u460869f9\"><span data-lake-id=\"ud3a6c924\" id=\"ud3a6c924\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。</span></p><p data-lake-id=\"ua8e7bdb2\" id=\"ua8e7bdb2\"><span data-lake-id=\"uf7e9cc7e\" id=\"uf7e9cc7e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。</span></p><p data-lake-id=\"uf7367549\" id=\"uf7367549\"><span data-lake-id=\"ua03beabe\" id=\"ua03beabe\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。</span></p><p data-lake-id=\"udbf66164\" id=\"udbf66164\"><span data-lake-id=\"u290cf962\" id=\"u290cf962\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。</span></p><p data-lake-id=\"u055fa346\" id=\"u055fa346\"><strong><span data-lake-id=\"ue0a05b4a\" id=\"ue0a05b4a\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">方法内联的条件</span></strong></p><p data-lake-id=\"uf48d05c2\" id=\"uf48d05c2\"><span data-lake-id=\"ue16d30d1\" id=\"ue16d30d1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。</span></p><p data-lake-id=\"u03641928\" id=\"u03641928\"><span data-lake-id=\"u9b130171\" id=\"u9b130171\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：</span></p><p data-lake-id=\"ue7c5cf8c\" id=\"ue7c5cf8c\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u146c8499-8b53-47a4-97fa-d6b925f995a%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u18d993ad%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u52ca4d6c\" id=\"u52ca4d6c\"><strong><span data-lake-id=\"u9b7c5e75\" id=\"u9b7c5e75\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">虚函数内联</span></strong></p><p data-lake-id=\"u1df5211e\" id=\"u1df5211e\"><span data-lake-id=\"ub1af25f5\" id=\"ub1af25f5\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。</span></p><p data-lake-id=\"u36a3a2ac\" id=\"u36a3a2ac\"><span data-lake-id=\"u9b10b641\" id=\"u9b10b641\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：</span></p><p data-lake-id=\"u0fe43f3b\" id=\"u0fe43f3b\"><span data-lake-id=\"u59071d16\" id=\"u59071d16\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">virtual call</span></p><p data-lake-id=\"u68ea0300\" id=\"u68ea0300\"><strong><span data-lake-id=\"ud89b5aaf\" id=\"ud89b5aaf\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u541f1180\" id=\"u541f1180\"> </span><strong><span data-lake-id=\"u5398353a\" id=\"u5398353a\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u084c6d45\" id=\"u084c6d45\"> </span><strong><span data-lake-id=\"ued27e0eb\" id=\"ued27e0eb\" style=\"color: rgb(255, 198, 109)\">SimpleInliningTest</span></strong><span data-lake-id=\"u756c7ded\" id=\"u756c7ded\"> </span><span data-lake-id=\"ue5e875f1\" id=\"ue5e875f1\">{     </span><strong><span data-lake-id=\"uc4225c9b\" id=\"uc4225c9b\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u4256ae25\" id=\"u4256ae25\"> </span><strong><span data-lake-id=\"uee949992\" id=\"uee949992\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u6bda16aa\" id=\"u6bda16aa\"> </span><strong><span data-lake-id=\"u2a4a217e\" id=\"u2a4a217e\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u779fc141\" id=\"u779fc141\"> </span><strong><span data-lake-id=\"u95241756\" id=\"u95241756\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span data-lake-id=\"ubdd1b8c7\" id=\"ubdd1b8c7\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span data-lake-id=\"ua34ae683\" id=\"ua34ae683\"> </span><strong><span data-lake-id=\"u23f09f00\" id=\"u23f09f00\" style=\"color: rgb(194, 98, 48)\">throws</span></strong><span data-lake-id=\"u748486f1\" id=\"u748486f1\"> InterruptedException </span><span data-lake-id=\"ue670dde8\" id=\"ue670dde8\">{         VirtualInvokeTest obj = </span><strong><span data-lake-id=\"uf28cb631\" id=\"uf28cb631\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"uf9ef91d8\" id=\"uf9ef91d8\"> VirtualInvokeTest();         VirtualInvoke1 obj1 = </span><strong><span data-lake-id=\"u6f6457df\" id=\"u6f6457df\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u489bd242\" id=\"u489bd242\"> VirtualInvoke1();         </span><strong><span data-lake-id=\"u5ec6ae86\" id=\"u5ec6ae86\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"ue5164a00\" id=\"ue5164a00\"> (</span><strong><span data-lake-id=\"u7cc179f3\" id=\"u7cc179f3\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u5db6072e\" id=\"u5db6072e\"> i = </span><span data-lake-id=\"u84ef0362\" id=\"u84ef0362\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u49d0c444\" id=\"u49d0c444\">; i &lt; </span><span data-lake-id=\"ud67b6a52\" id=\"ud67b6a52\" style=\"color: rgb(165, 194, 97)\">100000</span><span data-lake-id=\"u5830e4d7\" id=\"u5830e4d7\">; i++) {             invokeMethod(obj);             invokeMethod(obj1);         }         Thread.sleep(</span><span data-lake-id=\"ua558ec4a\" id=\"ua558ec4a\" style=\"color: rgb(165, 194, 97)\">1000</span><span data-lake-id=\"udd517c49\" id=\"udd517c49\">);     }      </span><strong><span data-lake-id=\"ucc9acb44\" id=\"ucc9acb44\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u9225fe7f\" id=\"u9225fe7f\"> </span><strong><span data-lake-id=\"u138b41f9\" id=\"u138b41f9\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u8f991a0f\" id=\"u8f991a0f\"> </span><strong><span data-lake-id=\"ub00dccb0\" id=\"ub00dccb0\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uff63ae26\" id=\"uff63ae26\"> </span><strong><span data-lake-id=\"uf4bd3929\" id=\"uf4bd3929\" style=\"color: rgb(255, 198, 109)\">invokeMethod</span></strong><span data-lake-id=\"uee8bb4db\" id=\"uee8bb4db\" style=\"color: rgb(208, 208, 255)\">(VirtualInvokeTest obj)</span><span data-lake-id=\"u3ea63ddb\" id=\"u3ea63ddb\"> </span><span data-lake-id=\"uddc7a61d\" id=\"uddc7a61d\">{         obj.methodCall();     }      </span><strong><span data-lake-id=\"u560a9880\" id=\"u560a9880\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"ub78f7ba9\" id=\"ub78f7ba9\"> </span><strong><span data-lake-id=\"ubeceb1e6\" id=\"ubeceb1e6\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ude7d9241\" id=\"ude7d9241\"> </span><strong><span data-lake-id=\"u8101accc\" id=\"u8101accc\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"ud5e1724d\" id=\"ud5e1724d\"> </span><strong><span data-lake-id=\"u66afeb4b\" id=\"u66afeb4b\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"u9da52b2a\" id=\"u9da52b2a\"> </span><span data-lake-id=\"ubfbc033b\" id=\"ubfbc033b\">{         </span><strong><span data-lake-id=\"ud68b0ed8\" id=\"ud68b0ed8\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u58b48d38\" id=\"u58b48d38\"> </span><strong><span data-lake-id=\"u39918733\" id=\"u39918733\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u8b25a8a4\" id=\"u8b25a8a4\"> </span><strong><span data-lake-id=\"u6a97a210\" id=\"u6a97a210\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"ue205dd4e\" id=\"ue205dd4e\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u3a052c7e\" id=\"u3a052c7e\"> </span><span data-lake-id=\"u36729b2a\" id=\"u36729b2a\">{             System.out.println(</span><span data-lake-id=\"u7f316a1b\" id=\"u7f316a1b\" style=\"color: rgb(165, 194, 97)\">&quot;virtual call&quot;</span><span data-lake-id=\"ua6e42742\" id=\"ua6e42742\">);         }     }      </span><strong><span data-lake-id=\"u820d3e31\" id=\"u820d3e31\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"u0ace6235\" id=\"u0ace6235\"> </span><strong><span data-lake-id=\"u7287aa9a\" id=\"u7287aa9a\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"udf2bf025\" id=\"udf2bf025\"> </span><strong><span data-lake-id=\"u400ddcce\" id=\"u400ddcce\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u34629a76\" id=\"u34629a76\"> </span><strong><span data-lake-id=\"uee06c488\" id=\"uee06c488\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke1</span></strong><span data-lake-id=\"u7a6b9278\" id=\"u7a6b9278\"> </span><strong><span data-lake-id=\"uf135860f\" id=\"uf135860f\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span data-lake-id=\"u50e3e770\" id=\"u50e3e770\"> </span><strong><span data-lake-id=\"ue4f68ec1\" id=\"ue4f68ec1\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"u8a600a63\" id=\"u8a600a63\"> </span><span data-lake-id=\"u0cf18f06\" id=\"u0cf18f06\">{         </span><span data-lake-id=\"u86e3ab51\" id=\"u86e3ab51\" style=\"color: rgb(155, 133, 157)\">@Override</span><span data-lake-id=\"u8146feaf\" id=\"u8146feaf\">         </span><strong><span data-lake-id=\"udb012ae5\" id=\"udb012ae5\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ufa91df4e\" id=\"ufa91df4e\"> </span><strong><span data-lake-id=\"u98f7c5bc\" id=\"u98f7c5bc\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u417847a4\" id=\"u417847a4\"> </span><strong><span data-lake-id=\"uf21b0762\" id=\"uf21b0762\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"u0039c290\" id=\"u0039c290\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u3d47864f\" id=\"u3d47864f\"> </span><span data-lake-id=\"u4eb36670\" id=\"u4eb36670\">{             </span><strong><span data-lake-id=\"u86b57c34\" id=\"u86b57c34\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span data-lake-id=\"u69e907c9\" id=\"u69e907c9\">.methodCall();         }     } } </span></p><p data-lake-id=\"ubc53ef60\" id=\"ubc53ef60\"><span data-lake-id=\"u7b18793a\" id=\"u7b18793a\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：</span></p><p data-lake-id=\"ucd58977a\" id=\"ucd58977a\"><span data-lake-id=\"ua7099476\" id=\"ua7099476\"> </span><span data-lake-id=\"u27a6a08c\" id=\"u27a6a08c\" style=\"color: rgb(165, 194, 97)\">0x0000000113369d37</span><span data-lake-id=\"ue7c9b198\" id=\"ue7c9b198\">: callq  </span><span data-lake-id=\"ud56d6162\" id=\"ud56d6162\" style=\"color: rgb(165, 194, 97)\">0x00000001132950a0</span><span data-lake-id=\"ucdf0d2fd\" id=\"ucdf0d2fd\">  ; OopMap{off=</span><span data-lake-id=\"u4e009243\" id=\"u4e009243\" style=\"color: rgb(165, 194, 97)\">476</span><span data-lake-id=\"ue3d4df8b\" id=\"ue3d4df8b\">}                                                 ;*invokevirtual methodCall  </span><em><span data-lake-id=\"u34fcea7e\" id=\"u34fcea7e\" style=\"color: rgb(188, 148, 88)\">//代表虚调用</span></em><span data-lake-id=\"uf53f245f\" id=\"uf53f245f\">                                                 ; - SimpleInliningTest::invokeMethod@</span><span data-lake-id=\"u4b6ea4b5\" id=\"u4b6ea4b5\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u9df32d2d\" id=\"u9df32d2d\"> (line </span><span data-lake-id=\"u5acf4641\" id=\"u5acf4641\" style=\"color: rgb(165, 194, 97)\">18</span><span data-lake-id=\"ud5d3a73f\" id=\"ud5d3a73f\">)                                                 ;   {optimized virtual_call}  </span><em><span data-lake-id=\"uf7b0033c\" id=\"uf7b0033c\" style=\"color: rgb(188, 148, 88)\">//虚调用已经被优化</span></em><span data-lake-id=\"u9917d615\" id=\"u9917d615\"> </span></p><p data-lake-id=\"u19576672\" id=\"u19576672\"><span data-lake-id=\"ub14c94e9\" id=\"ub14c94e9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。</span></p><p data-lake-id=\"uff654061\" id=\"uff654061\"><span data-lake-id=\"u03be4947\" id=\"u03be4947\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">比如下面这段代码，我们增加一个实现：</span></p><p data-lake-id=\"u1ddb8da6\" id=\"u1ddb8da6\"><span data-lake-id=\"u6e1d2bd6\" id=\"u6e1d2bd6\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">多实现的虚调用</span></p><p data-lake-id=\"u354caeb4\" id=\"u354caeb4\"><strong><span data-lake-id=\"u96e06802\" id=\"u96e06802\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"udcdd7dd8\" id=\"udcdd7dd8\"> </span><strong><span data-lake-id=\"u0aff9bae\" id=\"u0aff9bae\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u366365bd\" id=\"u366365bd\"> </span><strong><span data-lake-id=\"u585e3206\" id=\"u585e3206\" style=\"color: rgb(255, 198, 109)\">SimpleInliningTest</span></strong><span data-lake-id=\"ucd60e16a\" id=\"ucd60e16a\"> </span><span data-lake-id=\"u70558fa5\" id=\"u70558fa5\">{     </span><strong><span data-lake-id=\"uaed50c81\" id=\"uaed50c81\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u22d3f7f8\" id=\"u22d3f7f8\"> </span><strong><span data-lake-id=\"ueaa92438\" id=\"ueaa92438\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ub9e4be07\" id=\"ub9e4be07\"> </span><strong><span data-lake-id=\"u9286741c\" id=\"u9286741c\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u9b562b73\" id=\"u9b562b73\"> </span><strong><span data-lake-id=\"u3bb66e8e\" id=\"u3bb66e8e\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span data-lake-id=\"ua539e9c6\" id=\"ua539e9c6\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span data-lake-id=\"u25c575bd\" id=\"u25c575bd\"> </span><strong><span data-lake-id=\"ue3851572\" id=\"ue3851572\" style=\"color: rgb(194, 98, 48)\">throws</span></strong><span data-lake-id=\"uabf1dc25\" id=\"uabf1dc25\"> InterruptedException </span><span data-lake-id=\"u30b14254\" id=\"u30b14254\">{         VirtualInvokeTest obj = </span><strong><span data-lake-id=\"u139cae43\" id=\"u139cae43\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"ub5e6599f\" id=\"ub5e6599f\"> VirtualInvokeTest();         VirtualInvoke1 obj1 = </span><strong><span data-lake-id=\"u874f3fa6\" id=\"u874f3fa6\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"udd9af692\" id=\"udd9af692\"> VirtualInvoke1();         VirtualInvoke2 obj2 = </span><strong><span data-lake-id=\"u1aaf64f8\" id=\"u1aaf64f8\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u3af23c74\" id=\"u3af23c74\"> VirtualInvoke2();         </span><strong><span data-lake-id=\"u3390d304\" id=\"u3390d304\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"u7fd36254\" id=\"u7fd36254\"> (</span><strong><span data-lake-id=\"u43d224b4\" id=\"u43d224b4\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uabc668c6\" id=\"uabc668c6\"> i = </span><span data-lake-id=\"u3e5245df\" id=\"u3e5245df\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u811b6963\" id=\"u811b6963\">; i &lt; </span><span data-lake-id=\"u77ec7513\" id=\"u77ec7513\" style=\"color: rgb(165, 194, 97)\">100000</span><span data-lake-id=\"uddc3f5d7\" id=\"uddc3f5d7\">; i++) {             invokeMethod(obj);             invokeMethod(obj1);         invokeMethod(obj2);         }         Thread.sleep(</span><span data-lake-id=\"u464d8a10\" id=\"u464d8a10\" style=\"color: rgb(165, 194, 97)\">1000</span><span data-lake-id=\"u02b1d5da\" id=\"u02b1d5da\">);     }      </span><strong><span data-lake-id=\"ueeceba4f\" id=\"ueeceba4f\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"uecc2e41e\" id=\"uecc2e41e\"> </span><strong><span data-lake-id=\"ue59d8fd2\" id=\"ue59d8fd2\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"uff31af3a\" id=\"uff31af3a\"> </span><strong><span data-lake-id=\"u0b7d2680\" id=\"u0b7d2680\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u4067f141\" id=\"u4067f141\"> </span><strong><span data-lake-id=\"u0f45967a\" id=\"u0f45967a\" style=\"color: rgb(255, 198, 109)\">invokeMethod</span></strong><span data-lake-id=\"u64941a90\" id=\"u64941a90\" style=\"color: rgb(208, 208, 255)\">(VirtualInvokeTest obj)</span><span data-lake-id=\"ue15c6598\" id=\"ue15c6598\"> </span><span data-lake-id=\"u05757266\" id=\"u05757266\">{         obj.methodCall();     }      </span><strong><span data-lake-id=\"ua518886e\" id=\"ua518886e\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"u5b48470c\" id=\"u5b48470c\"> </span><strong><span data-lake-id=\"u728c82d1\" id=\"u728c82d1\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u6696f9bc\" id=\"u6696f9bc\"> </span><strong><span data-lake-id=\"uec718bf9\" id=\"uec718bf9\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u2c5b6264\" id=\"u2c5b6264\"> </span><strong><span data-lake-id=\"uc1f7cb33\" id=\"uc1f7cb33\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"uce13c381\" id=\"uce13c381\"> </span><span data-lake-id=\"u122031e6\" id=\"u122031e6\">{         </span><strong><span data-lake-id=\"ue4641472\" id=\"ue4641472\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u6040be2b\" id=\"u6040be2b\"> </span><strong><span data-lake-id=\"u49311887\" id=\"u49311887\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u97e24cf0\" id=\"u97e24cf0\"> </span><strong><span data-lake-id=\"udb887a1c\" id=\"udb887a1c\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"u4eadf8e6\" id=\"u4eadf8e6\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u40e62b63\" id=\"u40e62b63\"> </span><span data-lake-id=\"u851238f1\" id=\"u851238f1\">{             System.out.println(</span><span data-lake-id=\"u581b0345\" id=\"u581b0345\" style=\"color: rgb(165, 194, 97)\">&quot;virtual call&quot;</span><span data-lake-id=\"u2afb8028\" id=\"u2afb8028\">);         }     }      </span><strong><span data-lake-id=\"uf34c7e39\" id=\"uf34c7e39\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"ube8ee444\" id=\"ube8ee444\"> </span><strong><span data-lake-id=\"u8f1af71a\" id=\"u8f1af71a\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ua188ded0\" id=\"ua188ded0\"> </span><strong><span data-lake-id=\"ud8d819ad\" id=\"ud8d819ad\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u0adfdf6d\" id=\"u0adfdf6d\"> </span><strong><span data-lake-id=\"u7cb11a64\" id=\"u7cb11a64\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke1</span></strong><span data-lake-id=\"ud6e259f8\" id=\"ud6e259f8\"> </span><strong><span data-lake-id=\"u629c7da9\" id=\"u629c7da9\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span data-lake-id=\"u5caa655e\" id=\"u5caa655e\"> </span><strong><span data-lake-id=\"uf6249576\" id=\"uf6249576\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"u2764a17d\" id=\"u2764a17d\"> </span><span data-lake-id=\"u2ec13e09\" id=\"u2ec13e09\">{         </span><span data-lake-id=\"udacb9a23\" id=\"udacb9a23\" style=\"color: rgb(155, 133, 157)\">@Override</span><span data-lake-id=\"u2661397e\" id=\"u2661397e\">         </span><strong><span data-lake-id=\"u730e09b6\" id=\"u730e09b6\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u04c65198\" id=\"u04c65198\"> </span><strong><span data-lake-id=\"uc875c993\" id=\"uc875c993\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"ue7073470\" id=\"ue7073470\"> </span><strong><span data-lake-id=\"u309acfed\" id=\"u309acfed\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"u80ec7223\" id=\"u80ec7223\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u2e8cff65\" id=\"u2e8cff65\"> </span><span data-lake-id=\"u01e78681\" id=\"u01e78681\">{             </span><strong><span data-lake-id=\"uda9670d0\" id=\"uda9670d0\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span data-lake-id=\"ub776bd34\" id=\"ub776bd34\">.methodCall();         }     }     </span><strong><span data-lake-id=\"u70b26839\" id=\"u70b26839\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"u0a029624\" id=\"u0a029624\"> </span><strong><span data-lake-id=\"ua06acb39\" id=\"ua06acb39\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ud0a3b13c\" id=\"ud0a3b13c\"> </span><strong><span data-lake-id=\"ub01b8c7d\" id=\"ub01b8c7d\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u1becfab6\" id=\"u1becfab6\"> </span><strong><span data-lake-id=\"u692f8af4\" id=\"u692f8af4\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke2</span></strong><span data-lake-id=\"uf4ce46cf\" id=\"uf4ce46cf\"> </span><strong><span data-lake-id=\"uecde6dd9\" id=\"uecde6dd9\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span data-lake-id=\"ue5899bc9\" id=\"ue5899bc9\"> </span><strong><span data-lake-id=\"u973cac60\" id=\"u973cac60\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"ua382ac4d\" id=\"ua382ac4d\"> </span><span data-lake-id=\"u897e1ea4\" id=\"u897e1ea4\">{         </span><span data-lake-id=\"u721a0603\" id=\"u721a0603\" style=\"color: rgb(155, 133, 157)\">@Override</span><span data-lake-id=\"u2148fe4c\" id=\"u2148fe4c\">         </span><strong><span data-lake-id=\"ue7a7d775\" id=\"ue7a7d775\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u210a75de\" id=\"u210a75de\"> </span><strong><span data-lake-id=\"ua66f85c2\" id=\"ua66f85c2\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uf67e1b97\" id=\"uf67e1b97\"> </span><strong><span data-lake-id=\"u4ebd4754\" id=\"u4ebd4754\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"uf8dc3202\" id=\"uf8dc3202\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u028f2aac\" id=\"u028f2aac\"> </span><span data-lake-id=\"u7695bfc2\" id=\"u7695bfc2\">{             </span><strong><span data-lake-id=\"u47a928ed\" id=\"u47a928ed\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span data-lake-id=\"u04cc3055\" id=\"u04cc3055\">.methodCall();         }     } } </span></p><p data-lake-id=\"u0d241b7a\" id=\"u0d241b7a\"><span data-lake-id=\"u411b1348\" id=\"u411b1348\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过反编译得到下面的汇编代码：</span></p><p data-lake-id=\"u66643733\" id=\"u66643733\"><span data-lake-id=\"ue13e470d\" id=\"ue13e470d\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">代码块</span></p><p data-lake-id=\"u687952ad\" id=\"u687952ad\"><span data-lake-id=\"uf7de9084\" id=\"uf7de9084\"> </span><span data-lake-id=\"u578532b6\" id=\"u578532b6\" style=\"color: rgb(165, 194, 97)\">0x000000011f5f</span><span data-lake-id=\"u6bad1031\" id=\"u6bad1031\">0a37: callq  </span><span data-lake-id=\"u780903eb\" id=\"u780903eb\" style=\"color: rgb(165, 194, 97)\">0x000000011f4fd</span><span data-lake-id=\"ud1187eda\" id=\"ud1187eda\">2e0  ; OopMap{off=</span><span data-lake-id=\"u5d0ceb3a\" id=\"u5d0ceb3a\" style=\"color: rgb(165, 194, 97)\">28</span><span data-lake-id=\"u894b17a8\" id=\"u894b17a8\">}                                                 ;*invokevirtual methodCall  </span><em><span data-lake-id=\"u058af300\" id=\"u058af300\" style=\"color: rgb(188, 148, 88)\">//代表虚调用</span></em><span data-lake-id=\"u37312d1a\" id=\"u37312d1a\">                                                 ; - SimpleInliningTest::invokeMethod@</span><span data-lake-id=\"u06c9c4e0\" id=\"u06c9c4e0\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u4eca420a\" id=\"u4eca420a\"> (line </span><span data-lake-id=\"u29b7516e\" id=\"u29b7516e\" style=\"color: rgb(165, 194, 97)\">20</span><span data-lake-id=\"u2e43b761\" id=\"u2e43b761\">)                                                 ;   {virtual_call}  </span><em><span data-lake-id=\"ub18cfa09\" id=\"ub18cfa09\" style=\"color: rgb(188, 148, 88)\">//虚调用未被优化</span></em><span data-lake-id=\"uc2ab1f01\" id=\"uc2ab1f01\"> </span></p><p data-lake-id=\"u653022cd\" id=\"u653022cd\"><span data-lake-id=\"u3389a45e\" id=\"u3389a45e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看到多个实现的虚调用未被优化，依然是virtual_call。</span></p><p data-lake-id=\"uf791d063\" id=\"uf791d063\"><span data-lake-id=\"u80159ff5\" id=\"u80159ff5\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。</span></p><h3 data-lake-id=\"nTiw8\" id=\"nTiw8\"><span data-lake-id=\"u7bf98658\" id=\"u7bf98658\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 逃逸分析</span></h3><p data-lake-id=\"ue34ecb63\" id=\"ue34ecb63\"><span data-lake-id=\"u2f195bdc\" id=\"u2f195bdc\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：</span></p><ol list=\"ucda6ec24\"><li fid=\"ue87cf42c\" data-lake-id=\"ua34c15e7\" id=\"ua34c15e7\"><span data-lake-id=\"u34e94ec5\" id=\"u34e94ec5\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。</span></li><li fid=\"ue87cf42c\" data-lake-id=\"ucade2de2\" id=\"ucade2de2\"><span data-lake-id=\"uc4bf7090\" id=\"uc4bf7090\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。</span></li></ol><p data-lake-id=\"u718a1567\" id=\"u718a1567\"><span data-lake-id=\"uc137221a\" id=\"uc137221a\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：</span></p><p data-lake-id=\"u1b53e444\" id=\"u1b53e444\"><span data-lake-id=\"u29dc890d\" id=\"u29dc890d\">pulbic </span><strong><span data-lake-id=\"ud402fe30\" id=\"ud402fe30\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u89a2d6da\" id=\"u89a2d6da\"> </span><strong><span data-lake-id=\"uf36bbcd2\" id=\"uf36bbcd2\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span data-lake-id=\"u11826bfc\" id=\"u11826bfc\">{     </span><strong><span data-lake-id=\"u8d47b154\" id=\"u8d47b154\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u9dcd4f5c\" id=\"u9dcd4f5c\"> </span><strong><span data-lake-id=\"u01e5e87d\" id=\"u01e5e87d\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"uc72dc148\" id=\"uc72dc148\"> </span><strong><span data-lake-id=\"u9ce736c8\" id=\"u9ce736c8\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"ufc021844\" id=\"ufc021844\"> </span><strong><span data-lake-id=\"u8b823619\" id=\"u8b823619\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span data-lake-id=\"u1ccd50a7\" id=\"u1ccd50a7\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span data-lake-id=\"u7f42e578\" id=\"u7f42e578\"> </span><span data-lake-id=\"uad2e3cb7\" id=\"uad2e3cb7\">{       example();     }     </span><strong><span data-lake-id=\"uf9479ce2\" id=\"uf9479ce2\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u6862bf5a\" id=\"u6862bf5a\"> </span><strong><span data-lake-id=\"u6f4cd6f5\" id=\"u6f4cd6f5\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u06075618\" id=\"u06075618\"> </span><strong><span data-lake-id=\"udafa76f2\" id=\"udafa76f2\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u5b305dac\" id=\"u5b305dac\"> </span><strong><span data-lake-id=\"u97d3bb11\" id=\"u97d3bb11\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span data-lake-id=\"ub792db28\" id=\"ub792db28\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u05f6fe6b\" id=\"u05f6fe6b\"> </span><span data-lake-id=\"u7d9c662d\" id=\"u7d9c662d\">{       Foo foo = </span><strong><span data-lake-id=\"u0607d926\" id=\"u0607d926\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u9aee4453\" id=\"u9aee4453\"> Foo();       Bar bar = </span><strong><span data-lake-id=\"udd65834e\" id=\"udd65834e\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u404aa0d4\" id=\"u404aa0d4\"> Bar();       bar.setFoo(foo);     }   }    </span><strong><span data-lake-id=\"u779f64dc\" id=\"u779f64dc\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u89359f67\" id=\"u89359f67\"> </span><strong><span data-lake-id=\"u5e98a016\" id=\"u5e98a016\" style=\"color: rgb(255, 198, 109)\">Foo</span></strong><span data-lake-id=\"u465f48cc\" id=\"u465f48cc\"> </span><span data-lake-id=\"u551c7ac2\" id=\"u551c7ac2\">{}    </span><strong><span data-lake-id=\"uede2c867\" id=\"uede2c867\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u4682c427\" id=\"u4682c427\"> </span><strong><span data-lake-id=\"u86dd850f\" id=\"u86dd850f\" style=\"color: rgb(255, 198, 109)\">Bar</span></strong><span data-lake-id=\"u154af0b3\" id=\"u154af0b3\"> </span><span data-lake-id=\"ud381b6ad\" id=\"ud381b6ad\">{     </span><strong><span data-lake-id=\"u28ca0e4a\" id=\"u28ca0e4a\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"u544906f4\" id=\"u544906f4\"> Foo foo;     </span><strong><span data-lake-id=\"ud0f7ef68\" id=\"ud0f7ef68\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ub316d3cf\" id=\"ub316d3cf\"> </span><strong><span data-lake-id=\"u06da27da\" id=\"u06da27da\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u97551541\" id=\"u97551541\"> </span><strong><span data-lake-id=\"ue04a901b\" id=\"ue04a901b\" style=\"color: rgb(255, 198, 109)\">setFoo</span></strong><span data-lake-id=\"ue49742fc\" id=\"ue49742fc\" style=\"color: rgb(208, 208, 255)\">(Foo foo)</span><span data-lake-id=\"uc4d7f46d\" id=\"uc4d7f46d\"> </span><span data-lake-id=\"ucd764c05\" id=\"ucd764c05\">{       </span><strong><span data-lake-id=\"ua9ac366b\" id=\"ua9ac366b\" style=\"color: rgb(194, 98, 48)\">this</span></strong><span data-lake-id=\"ucfad544e\" id=\"ucfad544e\">.foo = foo;     }   } } </span></p><p data-lake-id=\"u43d6822b\" id=\"u43d6822b\"><span data-lake-id=\"uf8b384eb\" id=\"uf8b384eb\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。</span></p><p data-lake-id=\"ud1977f0f\" id=\"ud1977f0f\"><strong><span data-lake-id=\"u07d262b5\" id=\"u07d262b5\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">锁消除</span></strong></p><p data-lake-id=\"u11e106a6\" id=\"u11e106a6\"><span data-lake-id=\"ueb3e6285\" id=\"ueb3e6285\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。</span></p><p data-lake-id=\"uc721a5f5\" id=\"uc721a5f5\"><span data-lake-id=\"u2c6d6972\" id=\"u2c6d6972\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。</span></p><p data-lake-id=\"u1a039201\" id=\"u1a039201\"><strong><span data-lake-id=\"u685ce94e\" id=\"u685ce94e\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">栈上分配</span></strong></p><p data-lake-id=\"u5355739f\" id=\"u5355739f\"><span data-lake-id=\"u24e498a8\" id=\"u24e498a8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：</span></p><p data-lake-id=\"u81a96399\" id=\"u81a96399\"><span data-lake-id=\"ufd186981\" id=\"ufd186981\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">标量替换</span></p><p data-lake-id=\"uccc85a28\" id=\"uccc85a28\"><strong><span data-lake-id=\"uc7ad6457\" id=\"uc7ad6457\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u0527a4c9\" id=\"u0527a4c9\"> </span><strong><span data-lake-id=\"uec3d8f8b\" id=\"uec3d8f8b\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"ufaced914\" id=\"ufaced914\"> </span><strong><span data-lake-id=\"u78bb7135\" id=\"u78bb7135\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span data-lake-id=\"u76894575\" id=\"u76894575\">{   </span><span data-lake-id=\"uae7b6b09\" id=\"uae7b6b09\" style=\"color: rgb(155, 133, 157)\">@AllArgsConstructor</span><span data-lake-id=\"u45175fa9\" id=\"u45175fa9\">   </span><strong><span data-lake-id=\"u38fa68f5\" id=\"u38fa68f5\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u5c3e335d\" id=\"u5c3e335d\"> </span><strong><span data-lake-id=\"u410a482e\" id=\"u410a482e\" style=\"color: rgb(255, 198, 109)\">Cat</span></strong><span data-lake-id=\"u99bdb6a9\" id=\"u99bdb6a9\">{     </span><strong><span data-lake-id=\"udee50919\" id=\"udee50919\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ua6e11de4\" id=\"ua6e11de4\"> age;     </span><strong><span data-lake-id=\"uaec6d4c2\" id=\"uaec6d4c2\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uad9fc75b\" id=\"uad9fc75b\"> weight;   }   </span><strong><span data-lake-id=\"udb75cbb2\" id=\"udb75cbb2\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u5c88d231\" id=\"u5c88d231\"> </span><strong><span data-lake-id=\"u33364bf8\" id=\"u33364bf8\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u9dcdae5f\" id=\"u9dcdae5f\"> </span><strong><span data-lake-id=\"ua478154c\" id=\"ua478154c\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"ufa38ee20\" id=\"ufa38ee20\"> </span><strong><span data-lake-id=\"u5f9bcc39\" id=\"u5f9bcc39\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span data-lake-id=\"u8273dc02\" id=\"u8273dc02\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"ue1ed816a\" id=\"ue1ed816a\">{     Cat cat = </span><strong><span data-lake-id=\"uae9fd913\" id=\"uae9fd913\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u5840542e\" id=\"u5840542e\"> Cat(</span><span data-lake-id=\"u9ffbcf66\" id=\"u9ffbcf66\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u637a0d5a\" id=\"u637a0d5a\">,</span><span data-lake-id=\"uc972c83b\" id=\"uc972c83b\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"u139ff153\" id=\"u139ff153\">);     addAgeAndWeight(cat.age,Cat.weight);   } } </span></p><p data-lake-id=\"u3b76328a\" id=\"u3b76328a\"><span data-lake-id=\"uac25e361\" id=\"uac25e361\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：</span></p><p data-lake-id=\"ub3c94f81\" id=\"ub3c94f81\"><strong><span data-lake-id=\"u04f885be\" id=\"u04f885be\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u40afa3db\" id=\"u40afa3db\"> </span><strong><span data-lake-id=\"uab0fcc12\" id=\"uab0fcc12\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"ub436051b\" id=\"ub436051b\"> </span><strong><span data-lake-id=\"u4c6396a7\" id=\"u4c6396a7\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span data-lake-id=\"ub1763b26\" id=\"ub1763b26\">{   </span><span data-lake-id=\"u98878122\" id=\"u98878122\" style=\"color: rgb(155, 133, 157)\">@AllArgsConstructor</span><span data-lake-id=\"ucfbbd955\" id=\"ucfbbd955\">   </span><strong><span data-lake-id=\"ub20302d0\" id=\"ub20302d0\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"uf72229dc\" id=\"uf72229dc\"> </span><strong><span data-lake-id=\"u1f801f00\" id=\"u1f801f00\" style=\"color: rgb(255, 198, 109)\">Cat</span></strong><span data-lake-id=\"u88b0dc36\" id=\"u88b0dc36\">{     </span><strong><span data-lake-id=\"u4a166fc1\" id=\"u4a166fc1\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ubc0459d7\" id=\"ubc0459d7\"> age;     </span><strong><span data-lake-id=\"u592dd106\" id=\"u592dd106\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uc7ea67cd\" id=\"uc7ea67cd\"> weight;   }   </span><strong><span data-lake-id=\"ue76f36ad\" id=\"ue76f36ad\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"uad97550f\" id=\"uad97550f\"> </span><strong><span data-lake-id=\"u3787124b\" id=\"u3787124b\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"uee1acad2\" id=\"uee1acad2\"> </span><strong><span data-lake-id=\"u423dc930\" id=\"u423dc930\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uc92bdbc8\" id=\"uc92bdbc8\"> </span><strong><span data-lake-id=\"u4082419a\" id=\"u4082419a\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span data-lake-id=\"u83e81d41\" id=\"u83e81d41\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u3de2cd34\" id=\"u3de2cd34\">{     </span><strong><span data-lake-id=\"u4cf07b39\" id=\"u4cf07b39\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ue97dacc2\" id=\"ue97dacc2\"> age = </span><span data-lake-id=\"ub19cf516\" id=\"ub19cf516\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u06938186\" id=\"u06938186\">;     </span><strong><span data-lake-id=\"u63b1902e\" id=\"u63b1902e\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u94bdd122\" id=\"u94bdd122\"> weight = </span><span data-lake-id=\"ua60e8192\" id=\"ua60e8192\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"u8963fbe3\" id=\"u8963fbe3\">;     addAgeAndWeight(age,weight);   } } </span></p><p data-lake-id=\"ufcc36c77\" id=\"ufcc36c77\"><strong><span data-lake-id=\"u7a9c7ff0\" id=\"u7a9c7ff0\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">部分逃逸分析</span></strong></p><p data-lake-id=\"u81b5df62\" id=\"u81b5df62\"><span data-lake-id=\"u8c006892\" id=\"u8c006892\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。</span></p><h3 data-lake-id=\"Kz4q3\" id=\"Kz4q3\"><span data-lake-id=\"ucfa707af\" id=\"ucfa707af\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">4. Loop Transformations</span></h3><p data-lake-id=\"udbc062da\" id=\"udbc062da\"><span data-lake-id=\"ub18b591b\" id=\"ub18b591b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。</span></p><p data-lake-id=\"u8f2ac734\" id=\"u8f2ac734\"><strong><span data-lake-id=\"u0e73632c\" id=\"u0e73632c\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">循环展开</span></strong></p><p data-lake-id=\"ue0ff70b0\" id=\"ue0ff70b0\"><span data-lake-id=\"u8847a587\" id=\"u8847a587\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。</span></p><p data-lake-id=\"uc2822c8e\" id=\"uc2822c8e\"><span data-lake-id=\"u3a3fc7fa\" id=\"u3a3fc7fa\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：</span></p><p data-lake-id=\"u1210203d\" id=\"u1210203d\"><span data-lake-id=\"u1fd2be8b\" id=\"u1fd2be8b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开</span></p><p data-lake-id=\"u051b7df7\" id=\"u051b7df7\"><strong><span data-lake-id=\"uaa99973a\" id=\"uaa99973a\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ua9cd42a9\" id=\"ua9cd42a9\"> </span><strong><span data-lake-id=\"ucd4a16ad\" id=\"ucd4a16ad\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"ud85921c1\" id=\"ud85921c1\"> </span><strong><span data-lake-id=\"ub0744a59\" id=\"ub0744a59\" style=\"color: rgb(255, 198, 109)\">loopRolling</span></strong><span data-lake-id=\"u4bcb0719\" id=\"u4bcb0719\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"uf06709bf\" id=\"uf06709bf\">{   </span><strong><span data-lake-id=\"ucc30070b\" id=\"ucc30070b\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"ubd3569a9\" id=\"ubd3569a9\">(</span><strong><span data-lake-id=\"u2518207d\" id=\"u2518207d\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u36129576\" id=\"u36129576\"> i = </span><span data-lake-id=\"ub59bbe4d\" id=\"ub59bbe4d\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"ufe40351b\" id=\"ufe40351b\">;i&lt;</span><span data-lake-id=\"u36d57676\" id=\"u36d57676\" style=\"color: rgb(165, 194, 97)\">200</span><span data-lake-id=\"u707651c8\" id=\"u707651c8\">;i++){     </span><strong><span data-lake-id=\"uded723bd\" id=\"uded723bd\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"u2706178a\" id=\"u2706178a\">(i);     } } </span></p><p data-lake-id=\"u9642f87d\" id=\"u9642f87d\"><span data-lake-id=\"ub9887997\" id=\"ub9887997\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：</span></p><p data-lake-id=\"ud8ae8594\" id=\"ud8ae8594\"><span data-lake-id=\"u66567615\" id=\"u66567615\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开</span></p><p data-lake-id=\"u18a4f41c\" id=\"u18a4f41c\"><strong><span data-lake-id=\"ud951a573\" id=\"ud951a573\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ud033cf19\" id=\"ud033cf19\"> </span><strong><span data-lake-id=\"u67f4ca32\" id=\"u67f4ca32\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uf7c88090\" id=\"uf7c88090\"> </span><strong><span data-lake-id=\"ub5aafaa0\" id=\"ub5aafaa0\" style=\"color: rgb(255, 198, 109)\">loopRolling</span></strong><span data-lake-id=\"ue2560370\" id=\"ue2560370\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u960d80fb\" id=\"u960d80fb\">{   </span><strong><span data-lake-id=\"u362aca55\" id=\"u362aca55\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"u6c3661d6\" id=\"u6c3661d6\">(</span><strong><span data-lake-id=\"u5f229779\" id=\"u5f229779\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"udbbd6021\" id=\"udbbd6021\"> i = </span><span data-lake-id=\"ub7bfddd1\" id=\"ub7bfddd1\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u4885758c\" id=\"u4885758c\">;i&lt;</span><span data-lake-id=\"u7437581b\" id=\"u7437581b\" style=\"color: rgb(165, 194, 97)\">200</span><span data-lake-id=\"u6889c7b2\" id=\"u6889c7b2\">;i+=</span><span data-lake-id=\"uf2df1483\" id=\"uf2df1483\" style=\"color: rgb(165, 194, 97)\">5</span><span data-lake-id=\"ufd762619\" id=\"ufd762619\">){     </span><strong><span data-lake-id=\"u044cb254\" id=\"u044cb254\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"u31fcdbce\" id=\"u31fcdbce\">(i);     </span><strong><span data-lake-id=\"u44aa9205\" id=\"u44aa9205\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"ub57f1d5d\" id=\"ub57f1d5d\">(i+</span><span data-lake-id=\"ub840c627\" id=\"ub840c627\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"uf2e02800\" id=\"uf2e02800\">);     </span><strong><span data-lake-id=\"u0e0bfb8f\" id=\"u0e0bfb8f\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"u62fe2047\" id=\"u62fe2047\">(i+</span><span data-lake-id=\"u89e3cfc1\" id=\"u89e3cfc1\" style=\"color: rgb(165, 194, 97)\">2</span><span data-lake-id=\"u7d8341e5\" id=\"u7d8341e5\">);     </span><strong><span data-lake-id=\"u00578013\" id=\"u00578013\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"ua7bcf15f\" id=\"ua7bcf15f\">(i+</span><span data-lake-id=\"ucb9f4883\" id=\"ucb9f4883\" style=\"color: rgb(165, 194, 97)\">3</span><span data-lake-id=\"uaafbe03e\" id=\"uaafbe03e\">);     </span><strong><span data-lake-id=\"u8935f083\" id=\"u8935f083\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"u74ba8c74\" id=\"u74ba8c74\">(i+</span><span data-lake-id=\"u334ffbe3\" id=\"u334ffbe3\" style=\"color: rgb(165, 194, 97)\">4</span><span data-lake-id=\"ubf3e8234\" id=\"ubf3e8234\">);   } } </span></p><p data-lake-id=\"u3374ca41\" id=\"u3374ca41\"><span data-lake-id=\"uc18b92ed\" id=\"uc18b92ed\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。</span></p><p data-lake-id=\"u0c53185e\" id=\"u0c53185e\"><strong><span data-lake-id=\"u952d1caf\" id=\"u952d1caf\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">循环分离</span></strong></p><p data-lake-id=\"ub999980d\" id=\"ub999980d\"><span data-lake-id=\"uc2dee36b\" id=\"uc2dee36b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：</span></p><p data-lake-id=\"u3e518f57\" id=\"u3e518f57\"><span data-lake-id=\"u84c28e7e\" id=\"u84c28e7e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离</span></p><p data-lake-id=\"ubd18aa84\" id=\"ubd18aa84\"><strong><span data-lake-id=\"u711e0b2e\" id=\"u711e0b2e\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uf800fbfb\" id=\"uf800fbfb\"> a = </span><span data-lake-id=\"ud95b97dd\" id=\"ud95b97dd\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"ufee2d268\" id=\"ufee2d268\">; </span><strong><span data-lake-id=\"u8d46435d\" id=\"u8d46435d\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"uaa4d0258\" id=\"uaa4d0258\">(</span><strong><span data-lake-id=\"u8f9841c9\" id=\"u8f9841c9\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u27e14e5e\" id=\"u27e14e5e\"> i = </span><span data-lake-id=\"u3af0164a\" id=\"u3af0164a\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u3a0f5039\" id=\"u3a0f5039\">;i&lt;</span><span data-lake-id=\"u45def615\" id=\"u45def615\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"ub5c26f59\" id=\"ub5c26f59\">;i++){   b[i] = </span><strong><span data-lake-id=\"ua1b44f83\" id=\"ua1b44f83\" style=\"color: rgb(194, 98, 48)\">x</span></strong><span data-lake-id=\"u0007c79a\" id=\"u0007c79a\">[i] + </span><strong><span data-lake-id=\"uabb5b5e0\" id=\"uabb5b5e0\" style=\"color: rgb(194, 98, 48)\">x</span></strong><span data-lake-id=\"uc381841b\" id=\"uc381841b\">[a];   a = i; } </span></p><p data-lake-id=\"u19c23aad\" id=\"u19c23aad\"><span data-lake-id=\"uf5cc3ce4\" id=\"uf5cc3ce4\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：</span></p><p data-lake-id=\"ue547f2b2\" id=\"ue547f2b2\"><span data-lake-id=\"u4976b68e\" id=\"u4976b68e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离</span></p><p data-lake-id=\"u29e53f6f\" id=\"u29e53f6f\"><span data-lake-id=\"u5999ba2d\" id=\"u5999ba2d\">b</span><span data-lake-id=\"uc9279312\" id=\"uc9279312\" style=\"color: rgb(165, 194, 97)\">[0]</span><span data-lake-id=\"ua53d8c20\" id=\"ua53d8c20\"> = x</span><span data-lake-id=\"u545fb40d\" id=\"u545fb40d\" style=\"color: rgb(165, 194, 97)\">[0]</span><span data-lake-id=\"u2dc2a0e4\" id=\"u2dc2a0e4\"> + </span><span data-lake-id=\"udf9cf3a7\" id=\"udf9cf3a7\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"udd4c9f24\" id=\"udd4c9f24\">; for(int i = </span><span data-lake-id=\"uea2acca1\" id=\"uea2acca1\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u286834ef\" id=\"u286834ef\">;i&lt;</span><span data-lake-id=\"ud0d82023\" id=\"ud0d82023\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"ue8b4cfd5\" id=\"ue8b4cfd5\">;i++){   b</span><span data-lake-id=\"u02aa94cc\" id=\"u02aa94cc\" style=\"color: rgb(165, 194, 97)\">[i]</span><span data-lake-id=\"u465753e9\" id=\"u465753e9\"> = x</span><span data-lake-id=\"uba96e9e2\" id=\"uba96e9e2\" style=\"color: rgb(165, 194, 97)\">[i]</span><span data-lake-id=\"uecabdf3e\" id=\"uecabdf3e\"> + x</span><span data-lake-id=\"uda6de084\" id=\"uda6de084\" style=\"color: rgb(165, 194, 97)\">[i-1]</span><span data-lake-id=\"u2341a141\" id=\"u2341a141\">; } </span></p><p data-lake-id=\"u553c2724\" id=\"u553c2724\"><span data-lake-id=\"u1c10bfb2\" id=\"u1c10bfb2\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。</span></p><h3 data-lake-id=\"ynalx\" id=\"ynalx\"><span data-lake-id=\"u2bdd0245\" id=\"u2bdd0245\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">5. 窥孔优化与寄存器分配</span></h3><p data-lake-id=\"ua7c22582\" id=\"ua7c22582\"><span data-lake-id=\"u09a0b8d0\" id=\"u09a0b8d0\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：</span></p><p data-lake-id=\"ubc64dea7\" id=\"ubc64dea7\"><span data-lake-id=\"ufc546382\" id=\"ufc546382\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">强度削减</span></p><p data-lake-id=\"ucacd35d6\" id=\"ucacd35d6\"><span data-lake-id=\"u1922e621\" id=\"u1922e621\">y1=x1*3  经过强度削减后得到  y1=(x1&lt;&lt;1)+x1 </span></p><p data-lake-id=\"ube41c3ea\" id=\"ube41c3ea\"><span data-lake-id=\"udff6a96d\" id=\"udff6a96d\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。</span></p><p data-lake-id=\"u42c78f5c\" id=\"u42c78f5c\"><span data-lake-id=\"u73c368db\" id=\"u73c368db\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。</span></p><p data-lake-id=\"ub13c94b4\" id=\"ub13c94b4\"><span data-lake-id=\"uaea66a45\" id=\"uaea66a45\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。</span></p><h2 data-lake-id=\"ZSShZ\" id=\"ZSShZ\"><span data-lake-id=\"ud6a4b28a\" id=\"ud6a4b28a\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">四、实践</span></h2><p data-lake-id=\"u69ce8478\" id=\"u69ce8478\"><span data-lake-id=\"ud48ff173\" id=\"ud48ff173\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。</span></p><h3 data-lake-id=\"SHpjP\" id=\"SHpjP\"><span data-lake-id=\"ufbfcce82\" id=\"ufbfcce82\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. 编译相关的重* 要参数</span></h3><ul list=\"ub061ddee\"><li fid=\"u527521e3\" data-lake-id=\"uc435efd1\" id=\"uc435efd1\"><span data-lake-id=\"u842251c8\" id=\"u842251c8\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:+TieredCompilation：开启分层编译，JDK8之后默认开启</span></li><li fid=\"u527521e3\" data-lake-id=\"ub2e5b875\" id=\"ub2e5b875\"><span data-lake-id=\"u983d7032\" id=\"u983d7032\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:+CICompilerCount=N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 = 1:2</span></li><li fid=\"u527521e3\" data-lake-id=\"uec84e4b2\" id=\"uec84e4b2\"><span data-lake-id=\"u6ebf6d9c\" id=\"u6ebf6d9c\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXBackEdgeThreshold：OSR编译的阈值</span></li><li fid=\"u527521e3\" data-lake-id=\"uede9afc6\" id=\"uede9afc6\"><span data-lake-id=\"u7b3c4e01\" id=\"u7b3c4e01\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值</span></li><li fid=\"u527521e3\" data-lake-id=\"ua04d67fe\" id=\"ua04d67fe\"><span data-lake-id=\"u22239701\" id=\"u22239701\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXCompileThreshold：开启分层编译后的编译阈值</span></li><li fid=\"u527521e3\" data-lake-id=\"u70d1c5e4\" id=\"u70d1c5e4\"><span data-lake-id=\"u7de8163a\" id=\"u7de8163a\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:ReservedCodeCacheSize：codeCache最大大小</span></li><li fid=\"u527521e3\" data-lake-id=\"u6a743eef\" id=\"u6a743eef\"><span data-lake-id=\"u1ac9a1ea\" id=\"u1ac9a1ea\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:InitialCodeCacheSize：codeCache初始大小</span></li></ul><p data-lake-id=\"u7314e4cf\" id=\"u7314e4cf\"><span data-lake-id=\"u6f277364\" id=\"u6f277364\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。</span></p><p data-lake-id=\"uaf052c6c\" id=\"uaf052c6c\"><span data-lake-id=\"uc2cc0894\" id=\"uc2cc0894\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。</span></p><h3 data-lake-id=\"tIo0Z\" id=\"tIo0Z\"><span data-lake-id=\"u36f83707\" id=\"u36f83707\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2. 通过JITwatch分析编译日志</span></h3><p data-lake-id=\"ufec14627\" id=\"ufec14627\"><span data-lake-id=\"u702909cb\" id=\"u702909cb\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile=LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。</span></p><p data-lake-id=\"u8ea668ce\" id=\"u8ea668ce\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22uf9965c46-f8b5-4790-8c43-2496a253499%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22uc066bc4c%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22ub1b1c82e-1bc2-4461-92ce-52cded1cb4f%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u92756ac9%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u6710110f\" id=\"u6710110f\"><span data-lake-id=\"u5e365894\" id=\"u5e365894\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：</span></p><p data-lake-id=\"u7347bdbc\" id=\"u7347bdbc\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u466030eb-aa84-431b-afe7-39db9258d0d%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u036811d2%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u3751b3a7\" id=\"u3751b3a7\"><span data-lake-id=\"u7a308ab1\" id=\"u7a308ab1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。</span></p><p data-lake-id=\"u086efc56\" id=\"u086efc56\"><span data-lake-id=\"u029e8761\" id=\"u029e8761\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。</span></p><h3 data-lake-id=\"aBz3d\" id=\"aBz3d\"><span data-lake-id=\"udd5b89ed\" id=\"udd5b89ed\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 使用Graal编译器</span></h3><p data-lake-id=\"u50282e4f\" id=\"u50282e4f\"><span data-lake-id=\"ub5fffc56\" id=\"ub5fffc56\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。</span></p><p data-lake-id=\"uc836cb46\" id=\"uc836cb46\"><span data-lake-id=\"u6c876040\" id=\"u6c876040\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。</span></p><p data-lake-id=\"u836e833d\" id=\"u836e833d\"><span data-lake-id=\"uc09448f7\" id=\"uc09448f7\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。</span></p><p data-lake-id=\"ud55d64c2\" id=\"ud55d64c2\"><span data-lake-id=\"u871a9054\" id=\"u871a9054\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。</span></p><p data-lake-id=\"u5ca3f3ab\" id=\"u5ca3f3ab\"><span data-lake-id=\"u57536db8\" id=\"u57536db8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。</span></p><p data-lake-id=\"u151f8046\" id=\"u151f8046\"><strong><span data-lake-id=\"u5c36116b\" id=\"u5c36116b\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">使用Graal编译器后性能表现</span></strong></p><p data-lake-id=\"ub6741c38\" id=\"ub6741c38\"><span data-lake-id=\"ud05ca2ca\" id=\"ud05ca2ca\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在我们的线上服务中，启用Graal编译后，TP9999从60ms -&gt; 50ms ，下降10ms，下降幅度达16.7%。</span></p><p data-lake-id=\"u8496a364\" id=\"u8496a364\"><span data-lake-id=\"ub2107d01\" id=\"ub2107d01\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。</span></p><p data-lake-id=\"ue314a011\" id=\"ue314a011\"><strong><span data-lake-id=\"u8811d122\" id=\"u8811d122\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Graal编译器的问题</span></strong></p><p data-lake-id=\"uac6600aa\" id=\"uac6600aa\"><span data-lake-id=\"ue08faad1\" id=\"ue08faad1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。</span></p><p data-lake-id=\"uf8a76620\" id=\"uf8a76620\"><span data-lake-id=\"u1eab0bd2\" id=\"u1eab0bd2\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。</span></p><h2 data-lake-id=\"KwkdK\" id=\"KwkdK\"><span data-lake-id=\"u177616be\" id=\"u177616be\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">五、总结</span></h2><p data-lake-id=\"u281a9968\" id=\"u281a9968\"><span data-lake-id=\"u5639cc38\" id=\"u5639cc38\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。</span></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><h2 data-lake-id=\"Cs0yO\" id=\"Cs0yO\"><span data-lake-id=\"u79cbf014\" id=\"u79cbf014\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">一、导读</span></h2><p data-lake-id=\"u9ba95b5d\" id=\"u9ba95b5d\"><span data-lake-id=\"ucb18b4b4\" id=\"ucb18b4b4\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++这类编译型语言。</span></p><p data-lake-id=\"ued827280\" id=\"ued827280\"><span data-lake-id=\"uf574041f\" id=\"uf574041f\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</span></p><p data-lake-id=\"u7fb4cb1f\" id=\"u7fb4cb1f\"><span data-lake-id=\"u87244cdf\" id=\"u87244cdf\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</span></p><h2 data-lake-id=\"wnC6p\" id=\"wnC6p\"><span data-lake-id=\"uf7c90a1b\" id=\"uf7c90a1b\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">二、Java的执行过程</span></h2><p data-lake-id=\"u12864b35\" id=\"u12864b35\"><span data-lake-id=\"u327161a7\" id=\"u327161a7\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。</span></p><p data-lake-id=\"ubfba9b69\" id=\"ubfba9b69\"><span data-lake-id=\"uc1f7083d\" id=\"uc1f7083d\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">怎么样才会被认为是热点代码呢？JVM中会设置一个阈值，当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示：</span></p><p data-lake-id=\"u1e42c372\" id=\"u1e42c372\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u1d2758b1-072d-47c8-83ab-66e8e8a60fe%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u31ddb444%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><h3 data-lake-id=\"xlpT6\" id=\"xlpT6\"><span data-lake-id=\"u830632a4\" id=\"u830632a4\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. JVM中的编译器</span></h3><p data-lake-id=\"ueb3a9486\" id=\"ueb3a9486\"><span data-lake-id=\"uf4cff6cf\" id=\"uf4cff6cf\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">JVM中集成了两种编译器，Client Compiler和Server Compiler，它们的作用也不同。Client Compiler注重启动速度和局部的优化，Server Compiler则更加关注全局的优化，性能会更好，但由于会进行更多的全局分析，所以启动速度会变慢。两种编译器有着不同的应用场景，在虚拟机中同时发挥作用。</span></p><p data-lake-id=\"uef50e2e1\" id=\"uef50e2e1\"><strong><span data-lake-id=\"ue87a2edd\" id=\"ue87a2edd\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Client Compiler</span></strong></p><p data-lake-id=\"uf03a866c\" id=\"uf03a866c\"><span data-lake-id=\"ua03c89c9\" id=\"ua03c89c9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">HotSpot VM带有一个Client Compiler C1编译器。这种编译器启动速度快，但是性能比较Server Compiler来说会差一些。C1会做三件事：</span></p><ul list=\"u4fa4615e\"><li fid=\"u760aed5d\" data-lake-id=\"ued9a728f\" id=\"ued9a728f\"><span data-lake-id=\"u5c8fc5e6\" id=\"u5c8fc5e6\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">局部简单可靠的优化，比如字节码上进行的一些基础优化，方法内联、常量传播等，放弃许多耗时较长的全局优化。</span></li><li fid=\"u760aed5d\" data-lake-id=\"u5d1ab90b\" id=\"u5d1ab90b\"><span data-lake-id=\"u4ff33f44\" id=\"u4ff33f44\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">将字节码构造成高级中间表示（High-level Intermediate Representation，以下称为HIR），HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化。</span></li><li fid=\"u760aed5d\" data-lake-id=\"ubb246e87\" id=\"ubb246e87\"><span data-lake-id=\"u5c6b057f\" id=\"u5c6b057f\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">最后将HIR转换成低级中间表示（Low-level Intermediate Representation，以下称为LIR），在LIR的基础上会进行寄存器分配、窥孔优化（局部的优化方式，编译器在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体的分析，进行指令转换，来提升代码性能）等操作，最终生成机器码。</span></li></ul><p data-lake-id=\"uea448329\" id=\"uea448329\"><strong><span data-lake-id=\"ua1847de5\" id=\"ua1847de5\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Server Compiler</span></strong></p><p data-lake-id=\"uf2633e05\" id=\"uf2633e05\"><span data-lake-id=\"u350aa2c8\" id=\"u350aa2c8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Server Compiler主要关注一些编译耗时较长的全局优化，甚至会还会根据程序运行的信息进行一些不可靠的激进优化。这种编译器的启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高30%以上。目前，Hotspot虚拟机中使用的Server Compiler有两种：C2和Graal。</span></p><p data-lake-id=\"u7988657a\" id=\"u7988657a\"><strong><span data-lake-id=\"u1d4609ac\" id=\"u1d4609ac\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">C2 Compiler</span></strong></p><p data-lake-id=\"u913e7486\" id=\"u913e7486\"><span data-lake-id=\"u05e84e83\" id=\"u05e84e83\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在Hotspot VM中，默认的Server Compiler是C2编译器。</span></p><p data-lake-id=\"ua7428ad8\" id=\"ua7428ad8\"><span data-lake-id=\"u3fc16a97\" id=\"u3fc16a97\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器在进行编译优化时，会使用一种控制流与数据流结合的图数据结构，称为Ideal Graph。 Ideal Graph表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其是涉及浮动代码块的那些优化步骤）变得不那么复杂。</span></p><p data-lake-id=\"uce8b62bd\" id=\"uce8b62bd\"><span data-lake-id=\"u8945b616\" id=\"u8945b616\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令进行优化，比如Global Value Numbering、常量折叠等，解析结束后，还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局的优化，这个阶段如果JVM判断此时没有全局优化的必要，就会跳过这部分优化。</span></p><p data-lake-id=\"u0818e196\" id=\"u0818e196\"><span data-lake-id=\"u5040fbc3\" id=\"u5040fbc3\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph，最后编译的机器码就是从MachNode Graph中得的，生成机器码前还会有一些包括寄存器分配、窥孔优化等操作。关于Ideal Graph和各种全局的优化手段会在后面的章节详细介绍。Server Compiler编译优化的过程如下图所示：</span></p><p data-lake-id=\"u402a817e\" id=\"u402a817e\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u5d0840bf-f90e-4525-9c6f-13f824c35af%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u73cf5869%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"ub59ca60c\" id=\"ub59ca60c\"><strong><span data-lake-id=\"u6bb5074d\" id=\"u6bb5074d\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Graal Compiler</span></strong></p><p data-lake-id=\"u25663e3f\" id=\"u25663e3f\"><span data-lake-id=\"ue68ddb9e\" id=\"ue68ddb9e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">从JDK 9开始，Hotspot VM中集成了一种新的Server Compiler，Graal编译器。相比C2编译器，Graal有这样几种关键特性：</span></p><ul list=\"ud37cf9b9\"><li fid=\"u8d5bc934\" data-lake-id=\"u6c44c352\" id=\"u6c44c352\"><span data-lake-id=\"u8e1eeaff\" id=\"u8e1eeaff\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文有提到，JVM会在解释执行的时候收集程序运行的各种信息，然后编译器会根据这些信息进行一些基于预测的激进优化，比如分支预测，根据程序不同分支的运行概率，选择性地编译一些概率较大的分支。Graal比C2更加青睐这种优化，所以Graal的峰值性能通常要比C2更好。</span></li><li fid=\"u8d5bc934\" data-lake-id=\"ufab1c16a\" id=\"ufab1c16a\"><span data-lake-id=\"u7a7120d7\" id=\"u7a7120d7\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">使用Java编写，对于Java语言，尤其是新特性，比如Lambda、Stream等更加友好。</span></li><li fid=\"u8d5bc934\" data-lake-id=\"ua3f4eb0c\" id=\"ua3f4eb0c\"><span data-lake-id=\"u7f15d197\" id=\"u7f15d197\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">更深层次的优化，比如虚函数的内联、部分逃逸分析等。</span></li></ul><p data-lake-id=\"u94a3a120\" id=\"u94a3a120\"><span data-lake-id=\"u3ba1d0d8\" id=\"u3ba1d0d8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器可以通过Java虚拟机参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用。当启用时，它将替换掉HotSpot中的C2编译器，并响应原本由C2负责的编译请求。</span></p><h3 data-lake-id=\"LFlag\" id=\"LFlag\"><span data-lake-id=\"u92bdc542\" id=\"u92bdc542\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2. 分层编译</span></h3><p data-lake-id=\"u5d4c4162\" id=\"u5d4c4162\"><span data-lake-id=\"u77e9e587\" id=\"u77e9e587\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在Java 7以前，需要研发人员根据服务的性质去选择编译器。对于需要快速启动的，或者一些不会长期运行的服务，可以采用编译效率较高的C1，对应参数-client。长期运行的服务，或者对峰值性能有要求的后台服务，可以采用峰值性能更好的C2，对应参数-server。Java 7开始引入了分层编译的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：</span></p><ol list=\"ufbfdc759\"><li fid=\"u7ca234d9\" data-lake-id=\"u81c95631\" id=\"u81c95631\"><span data-lake-id=\"u29ddc198\" id=\"u29ddc198\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">解释执行。</span></li><li fid=\"u7ca234d9\" data-lake-id=\"u7ed1d697\" id=\"u7ed1d697\"><span data-lake-id=\"ufcbc8d2c\" id=\"ufcbc8d2c\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">执行不带profiling的C1代码。</span></li><li fid=\"u7ca234d9\" data-lake-id=\"u49d682cb\" id=\"u49d682cb\"><span data-lake-id=\"ube90ff7c\" id=\"ube90ff7c\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">执行仅带方法调用次数以及循环回边执行次数profiling的C1代码。</span></li><li fid=\"u7ca234d9\" data-lake-id=\"ube8d2bab\" id=\"ube8d2bab\"><span data-lake-id=\"u022b16f1\" id=\"u022b16f1\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">执行带所有profiling的C1代码。</span></li><li fid=\"u7ca234d9\" data-lake-id=\"ub4dce0bc\" id=\"ub4dce0bc\"><span data-lake-id=\"u76cc0a04\" id=\"u76cc0a04\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">执行C2代码。</span></li></ol><p data-lake-id=\"u9cda71b8\" id=\"u9cda71b8\"><span data-lake-id=\"uc130c400\" id=\"uc130c400\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">profiling就是收集能够反映程序执行状态的数据。其中最基本的统计数据就是方法的调用次数，以及循环回边的执行次数。</span></p><p data-lake-id=\"u70441bfa\" id=\"u70441bfa\"><span data-lake-id=\"u338336d1\" id=\"u338336d1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">通常情况下，C2代码的执行效率要比C1代码的高出30%以上。C1层执行的代码，按执行效率排序从高至低则是1层&gt;2层&gt;3层。这5个层次中，1层和4层都是终止状态，当一个方法到达终止状态后，只要编译后的代码并没有失效，那么JVM就不会再次发出该方法的编译请求的。服务实际运行时，JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。下图中就列举了几种常见的编译路径：</span></p><p data-lake-id=\"uf4a98af1\" id=\"uf4a98af1\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u00167f2d-39df-47b8-9590-155845fd8c9%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22ufd64748b%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><ul list=\"u6d98c4b1\"><li fid=\"u677af520\" data-lake-id=\"ua17cdb09\" id=\"ua17cdb09\"><span data-lake-id=\"u5bbc3f54\" id=\"u5bbc3f54\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">图中第①条路径，代表编译的一般情况，热点方法从解释执行到被3层的C1编译，最后被4层的C2编译。</span></li><li fid=\"u677af520\" data-lake-id=\"uf8c6ae96\" id=\"uf8c6ae96\"><span data-lake-id=\"u38cb20b2\" id=\"u38cb20b2\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果方法比较小（比如Java服务中常见的getter/setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译之后，放弃进入C2编译，直接选择用1层的C1编译运行。</span></li><li fid=\"u677af520\" data-lake-id=\"u0828df32\" id=\"u0828df32\"><span data-lake-id=\"u4f2ee4f7\" id=\"u4f2ee4f7\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling ，根据信息直接由第4层的C2编译。</span></li><li fid=\"u677af520\" data-lake-id=\"u98768a48\" id=\"u98768a48\"><span data-lake-id=\"ua2283f6a\" id=\"ua2283f6a\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提到C1中的执行效率是1层&gt;2层&gt;3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。</span></li><li fid=\"u677af520\" data-lake-id=\"u55d9b12f\" id=\"u55d9b12f\"><span data-lake-id=\"ub10ae397\" id=\"ub10ae397\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。</span></li></ul><p data-lake-id=\"u806c9da6\" id=\"u806c9da6\"><span data-lake-id=\"u8ff221d9\" id=\"u8ff221d9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK 8开始，JVM默认开启分层编译。</span></p><h3 data-lake-id=\"NWxMz\" id=\"NWxMz\"><span data-lake-id=\"u6420fe54\" id=\"u6420fe54\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 即时编译的触发</span></h3><p data-lake-id=\"u985084f9\" id=\"u985084f9\"><span data-lake-id=\"uf1e4495d\" id=\"uf1e4495d\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：</span></p><p data-lake-id=\"ubec05133\" id=\"ubec05133\"><span data-lake-id=\"ue8d7c2e3\" id=\"ue8d7c2e3\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环回边</span></p><p data-lake-id=\"u69d2defb\" id=\"u69d2defb\"><strong><span data-lake-id=\"u55fe2af1\" id=\"u55fe2af1\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"uc00f6a8c\" id=\"uc00f6a8c\"> </span><strong><span data-lake-id=\"u5c1cc453\" id=\"u5c1cc453\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u6df2c4e6\" id=\"u6df2c4e6\"> </span><strong><span data-lake-id=\"u0bfa957f\" id=\"u0bfa957f\" style=\"color: rgb(255, 198, 109)\">nlp</span></strong><span data-lake-id=\"u0b290c17\" id=\"u0b290c17\" style=\"color: rgb(208, 208, 255)\">(Object obj)</span><span data-lake-id=\"u0bc535f8\" id=\"u0bc535f8\"> </span><span data-lake-id=\"u350a87ab\" id=\"u350a87ab\">{   </span><strong><span data-lake-id=\"u351ea141\" id=\"u351ea141\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u9f9d77f8\" id=\"u9f9d77f8\"> sum = </span><span data-lake-id=\"u18c65261\" id=\"u18c65261\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u5a9c373e\" id=\"u5a9c373e\">;   </span><strong><span data-lake-id=\"u942657d9\" id=\"u942657d9\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"u6b48ca21\" id=\"u6b48ca21\"> (</span><strong><span data-lake-id=\"u4636142a\" id=\"u4636142a\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u335ced49\" id=\"u335ced49\"> i = </span><span data-lake-id=\"uc9aa9cac\" id=\"uc9aa9cac\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"ubb959ba0\" id=\"ubb959ba0\">; i &lt; </span><span data-lake-id=\"u860e984a\" id=\"u860e984a\" style=\"color: rgb(165, 194, 97)\">200</span><span data-lake-id=\"uc6ea7cf0\" id=\"uc6ea7cf0\">; i++) {     sum += i;   } } </span></p><p data-lake-id=\"u3c5cbea0\" id=\"u3c5cbea0\"><span data-lake-id=\"uc9270290\" id=\"uc9270290\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面这段代码经过编译生成下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为4的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。</span></p><p data-lake-id=\"u531c8a76\" id=\"u531c8a76\"><span data-lake-id=\"u565fe87e\" id=\"u565fe87e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">字节码</span></p><p data-lake-id=\"u5761b682\" id=\"u5761b682\"><span data-lake-id=\"u7f93f361\" id=\"u7f93f361\" style=\"color: rgb(109, 156, 190)\">public</span><span data-lake-id=\"u582443c7\" id=\"u582443c7\"> </span><span data-lake-id=\"u67b9c383\" id=\"u67b9c383\" style=\"color: rgb(165, 194, 97)\">void nlp(java.lang.Object);</span><span data-lake-id=\"ue784b1c5\" id=\"ue784b1c5\">     </span><span data-lake-id=\"u26fb2adc\" id=\"u26fb2adc\" style=\"color: rgb(109, 156, 190)\">Code</span><span data-lake-id=\"ucb9f8bb3\" id=\"ucb9f8bb3\">:</span><span data-lake-id=\"ub9b9120f\" id=\"ub9b9120f\">        </span><span data-lake-id=\"ud6695f9f\" id=\"ud6695f9f\" style=\"color: rgb(109, 156, 190)\">0</span><span data-lake-id=\"u64925a66\" id=\"u64925a66\">: </span><span data-lake-id=\"ufe6e0797\" id=\"ufe6e0797\" style=\"color: rgb(165, 194, 97)\">iconst_0</span><span data-lake-id=\"u873edf41\" id=\"u873edf41\">        </span><span data-lake-id=\"u6a5ce436\" id=\"u6a5ce436\" style=\"color: rgb(109, 156, 190)\">1</span><span data-lake-id=\"u8311b4d9\" id=\"u8311b4d9\">: </span><span data-lake-id=\"ubece4e17\" id=\"ubece4e17\" style=\"color: rgb(165, 194, 97)\">istore_1</span><span data-lake-id=\"u3be804e0\" id=\"u3be804e0\">        </span><span data-lake-id=\"ud0cbfbbe\" id=\"ud0cbfbbe\" style=\"color: rgb(109, 156, 190)\">2</span><span data-lake-id=\"u3189b814\" id=\"u3189b814\">: </span><span data-lake-id=\"ubd548577\" id=\"ubd548577\" style=\"color: rgb(165, 194, 97)\">iconst_0</span><span data-lake-id=\"uc9d167a8\" id=\"uc9d167a8\">        </span><span data-lake-id=\"u6bc093ac\" id=\"u6bc093ac\" style=\"color: rgb(109, 156, 190)\">3</span><span data-lake-id=\"u6530d202\" id=\"u6530d202\">: </span><span data-lake-id=\"u8eb3cfb7\" id=\"u8eb3cfb7\" style=\"color: rgb(165, 194, 97)\">istore_2</span><span data-lake-id=\"u512410db\" id=\"u512410db\">        </span><span data-lake-id=\"ud978d5a8\" id=\"ud978d5a8\" style=\"color: rgb(109, 156, 190)\">4</span><span data-lake-id=\"u669d3e6f\" id=\"u669d3e6f\">: </span><span data-lake-id=\"ubd65be14\" id=\"ubd65be14\" style=\"color: rgb(165, 194, 97)\">iload_2</span><span data-lake-id=\"ue36f4602\" id=\"ue36f4602\">        </span><span data-lake-id=\"ud0d93c01\" id=\"ud0d93c01\" style=\"color: rgb(109, 156, 190)\">5</span><span data-lake-id=\"ubf5f0ba0\" id=\"ubf5f0ba0\">: </span><span data-lake-id=\"u3742a518\" id=\"u3742a518\" style=\"color: rgb(165, 194, 97)\">sipush        200</span><span data-lake-id=\"ucc4d8f33\" id=\"ucc4d8f33\">        </span><span data-lake-id=\"u6e7389f8\" id=\"u6e7389f8\" style=\"color: rgb(109, 156, 190)\">8</span><span data-lake-id=\"u1de88ac6\" id=\"u1de88ac6\">: </span><span data-lake-id=\"u0a5c9809\" id=\"u0a5c9809\" style=\"color: rgb(165, 194, 97)\">if_icmpge     21</span><span data-lake-id=\"ufc43bfe0\" id=\"ufc43bfe0\">       </span><span data-lake-id=\"u315975e6\" id=\"u315975e6\" style=\"color: rgb(109, 156, 190)\">11</span><span data-lake-id=\"u0572ce9a\" id=\"u0572ce9a\">: </span><span data-lake-id=\"uc7cf0197\" id=\"uc7cf0197\" style=\"color: rgb(165, 194, 97)\">iload_1</span><span data-lake-id=\"ue0d46c3d\" id=\"ue0d46c3d\">       </span><span data-lake-id=\"u5b59f5b6\" id=\"u5b59f5b6\" style=\"color: rgb(109, 156, 190)\">12</span><span data-lake-id=\"uacf67c57\" id=\"uacf67c57\">: </span><span data-lake-id=\"u6bdedcd0\" id=\"u6bdedcd0\" style=\"color: rgb(165, 194, 97)\">iload_2</span><span data-lake-id=\"u5bc49b3f\" id=\"u5bc49b3f\">       </span><span data-lake-id=\"u0fedadcf\" id=\"u0fedadcf\" style=\"color: rgb(109, 156, 190)\">13</span><span data-lake-id=\"u8ab48e29\" id=\"u8ab48e29\">: </span><span data-lake-id=\"u6dcb0ccb\" id=\"u6dcb0ccb\" style=\"color: rgb(165, 194, 97)\">iadd</span><span data-lake-id=\"ud3efc749\" id=\"ud3efc749\">       </span><span data-lake-id=\"ue1c05f62\" id=\"ue1c05f62\" style=\"color: rgb(109, 156, 190)\">14</span><span data-lake-id=\"u010bf9c0\" id=\"u010bf9c0\">: </span><span data-lake-id=\"uafd82c18\" id=\"uafd82c18\" style=\"color: rgb(165, 194, 97)\">istore_1</span><span data-lake-id=\"u459195f7\" id=\"u459195f7\">       </span><span data-lake-id=\"ucf3c2563\" id=\"ucf3c2563\" style=\"color: rgb(109, 156, 190)\">15</span><span data-lake-id=\"u698fa8ee\" id=\"u698fa8ee\">: </span><span data-lake-id=\"ucd7b3ed4\" id=\"ucd7b3ed4\" style=\"color: rgb(165, 194, 97)\">iinc          2, 1</span><span data-lake-id=\"u536fc97e\" id=\"u536fc97e\">       </span><span data-lake-id=\"u9dd7675b\" id=\"u9dd7675b\" style=\"color: rgb(109, 156, 190)\">18</span><span data-lake-id=\"u4d430574\" id=\"u4d430574\">: </span><span data-lake-id=\"ua429c894\" id=\"ua429c894\" style=\"color: rgb(165, 194, 97)\">goto          4</span><span data-lake-id=\"uc5f2fa6f\" id=\"uc5f2fa6f\">       </span><span data-lake-id=\"uc6386555\" id=\"uc6386555\" style=\"color: rgb(109, 156, 190)\">21</span><span data-lake-id=\"u8fdaa1fd\" id=\"u8fdaa1fd\">: </span><span data-lake-id=\"u3cfc3a2d\" id=\"u3cfc3a2d\" style=\"color: rgb(165, 194, 97)\">return</span><span data-lake-id=\"uf950f59b\" id=\"uf950f59b\"> </span></p><p data-lake-id=\"ue4d45031\" id=\"ue4d45031\"><span data-lake-id=\"ue3d7f7ff\" id=\"ue3d7f7ff\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。</span></p><p data-lake-id=\"u23b4bca4\" id=\"u23b4bca4\"><span data-lake-id=\"u039b2381\" id=\"u039b2381\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。</span></p><p data-lake-id=\"u93e513f3\" id=\"u93e513f3\"><span data-lake-id=\"u1e551d47\" id=\"u1e551d47\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：</span></p><ul list=\"u6ab94ad4\"><li fid=\"u57201c19\" data-lake-id=\"ud96643eb\" id=\"ud96643eb\"><span data-lake-id=\"u8a3f715b\" id=\"u8a3f715b\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。</span></li><li fid=\"u57201c19\" data-lake-id=\"ua10d10b6\" id=\"ua10d10b6\"><span data-lake-id=\"u2e4d1d1c\" id=\"u2e4d1d1c\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。</span></li></ul><p data-lake-id=\"u37a28b2d\" id=\"u37a28b2d\"><span data-lake-id=\"ua27e308b\" id=\"ua27e308b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">分层编译触发条件公式</span></p><p data-lake-id=\"uf3ca8d1f\" id=\"uf3ca8d1f\"><span data-lake-id=\"u57c335cd\" id=\"u57c335cd\">i &gt; TierXInvocationThreshold * s </span><strong><span data-lake-id=\"u9b53205d\" id=\"u9b53205d\" style=\"color: rgb(255, 198, 109)\">||</span></strong><span data-lake-id=\"ub1c5d4a5\" id=\"ub1c5d4a5\"> (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + </span><strong><span data-lake-id=\"u91b32411\" id=\"u91b32411\" style=\"color: rgb(194, 98, 48)\">b </span></strong><span data-lake-id=\"u094afc9a\" id=\"u094afc9a\">&gt; TierXCompileThreshold * s)  i为调用次数，</span><strong><span data-lake-id=\"u2afca3f1\" id=\"u2afca3f1\" style=\"color: rgb(194, 98, 48)\">b是循环回边次数 </span></strong></p><p data-lake-id=\"u7ebf275b\" id=\"u7ebf275b\"><span data-lake-id=\"u3b3b2893\" id=\"u3b3b2893\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上述满足其中一个条件就会触发即时编译，并且JVM会根据当前的编译方法数以及编译线程数动态调整系数s。</span></p><h2 data-lake-id=\"crUWZ\" id=\"crUWZ\"><span data-lake-id=\"u757a4881\" id=\"u757a4881\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">三、编译优化</span></h2><p data-lake-id=\"ua9993f32\" id=\"ua9993f32\"><span data-lake-id=\"u480e6a95\" id=\"u480e6a95\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。</span></p><h3 data-lake-id=\"IcPt7\" id=\"IcPt7\"><span data-lake-id=\"uc3c2de92\" id=\"uc3c2de92\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. 中间表达形式（Intermediate Representation）</span></h3><p data-lake-id=\"u4df43154\" id=\"u4df43154\"><span data-lake-id=\"u28cc7239\" id=\"u28cc7239\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</span></p><p data-lake-id=\"u43d048ce\" id=\"u43d048ce\"><span data-lake-id=\"u40883108\" id=\"u40883108\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。举个例子：</span></p><p data-lake-id=\"u05264e55\" id=\"u05264e55\"><span data-lake-id=\"u63eeae2c\" id=\"u63eeae2c\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">SSA IR</span></p><p data-lake-id=\"u4b25be56\" id=\"u4b25be56\"><span data-lake-id=\"u16477a02\" id=\"u16477a02\" style=\"color: rgb(109, 156, 190)\">Plain</span><span data-lake-id=\"ua1cdfd03\" id=\"ua1cdfd03\"> </span><span data-lake-id=\"u2fc7734c\" id=\"u2fc7734c\" style=\"color: rgb(165, 194, 97)\">Text</span><span data-lake-id=\"u72d18f97\" id=\"u72d18f97\"> </span><span data-lake-id=\"ua0fdd1bd\" id=\"ua0fdd1bd\" style=\"color: rgb(109, 156, 190)\">{</span><span data-lake-id=\"u41f35924\" id=\"u41f35924\">   </span><span data-lake-id=\"u38a5f1cd\" id=\"u38a5f1cd\" style=\"color: rgb(109, 156, 190)\">a</span><span data-lake-id=\"u90a865a5\" id=\"u90a865a5\"> = </span><span data-lake-id=\"u9e4cb04a\" id=\"u9e4cb04a\" style=\"color: rgb(165, 194, 97)\">1;</span><span data-lake-id=\"u615e2916\" id=\"u615e2916\">   </span><span data-lake-id=\"ud99a34f2\" id=\"ud99a34f2\" style=\"color: rgb(109, 156, 190)\">a</span><span data-lake-id=\"u75d45548\" id=\"u75d45548\"> = </span><span data-lake-id=\"ua5a8da49\" id=\"ua5a8da49\" style=\"color: rgb(165, 194, 97)\">2;</span><span data-lake-id=\"u315c1d85\" id=\"u315c1d85\">   </span><span data-lake-id=\"u87c53a90\" id=\"u87c53a90\" style=\"color: rgb(109, 156, 190)\">b</span><span data-lake-id=\"u6be1085a\" id=\"u6be1085a\"> = </span><span data-lake-id=\"u4630941d\" id=\"u4630941d\" style=\"color: rgb(165, 194, 97)\">a;</span><span data-lake-id=\"u2794fb0a\" id=\"u2794fb0a\"> </span><span data-lake-id=\"u5aa07399\" id=\"u5aa07399\" style=\"color: rgb(109, 156, 190)\">}</span><span data-lake-id=\"u2c995706\" id=\"u2c995706\"> </span></p><p data-lake-id=\"u0bf689e0\" id=\"u0bf689e0\"><span data-lake-id=\"u7d77a231\" id=\"u7d77a231\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。</span></p><p data-lake-id=\"ud1393c2f\" id=\"ud1393c2f\"><span data-lake-id=\"ud4adae1b\" id=\"ud4adae1b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面代码的SSA IR形式的伪代码可以表示为：</span></p><p data-lake-id=\"u4d0cf115\" id=\"u4d0cf115\"><span data-lake-id=\"u259dc5e6\" id=\"u259dc5e6\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">SSA IR</span></p><p data-lake-id=\"uf0842f97\" id=\"uf0842f97\"><span data-lake-id=\"u572d4a14\" id=\"u572d4a14\" style=\"color: rgb(109, 156, 190)\">Plain</span><span data-lake-id=\"u4f1d23a3\" id=\"u4f1d23a3\"> </span><span data-lake-id=\"uf7d6d5b8\" id=\"uf7d6d5b8\" style=\"color: rgb(165, 194, 97)\">Text</span><span data-lake-id=\"u80b7eef2\" id=\"u80b7eef2\"> </span><span data-lake-id=\"ub207a403\" id=\"ub207a403\" style=\"color: rgb(109, 156, 190)\">{</span><span data-lake-id=\"ue29793fb\" id=\"ue29793fb\">   </span><span data-lake-id=\"ufee210b1\" id=\"ufee210b1\" style=\"color: rgb(109, 156, 190)\">a_1</span><span data-lake-id=\"u1a8e9582\" id=\"u1a8e9582\"> = </span><span data-lake-id=\"u2a72aa02\" id=\"u2a72aa02\" style=\"color: rgb(165, 194, 97)\">1;</span><span data-lake-id=\"u557f0a61\" id=\"u557f0a61\">   </span><span data-lake-id=\"ufaf617f5\" id=\"ufaf617f5\" style=\"color: rgb(109, 156, 190)\">a_2</span><span data-lake-id=\"ude4b56fe\" id=\"ude4b56fe\"> = </span><span data-lake-id=\"u27bf45f4\" id=\"u27bf45f4\" style=\"color: rgb(165, 194, 97)\">2;</span><span data-lake-id=\"u5bc547a8\" id=\"u5bc547a8\">   </span><span data-lake-id=\"u751e2895\" id=\"u751e2895\" style=\"color: rgb(109, 156, 190)\">b_1</span><span data-lake-id=\"u3333e4c5\" id=\"u3333e4c5\"> = </span><span data-lake-id=\"u8dfcdeed\" id=\"u8dfcdeed\" style=\"color: rgb(165, 194, 97)\">a_2;</span><span data-lake-id=\"u8ff0fc69\" id=\"u8ff0fc69\"> </span><span data-lake-id=\"u465332f4\" id=\"u465332f4\" style=\"color: rgb(109, 156, 190)\">}</span><span data-lake-id=\"u4f4737ce\" id=\"u4f4737ce\"> </span></p><p data-lake-id=\"ua3a0347a\" id=\"ua3a0347a\"><span data-lake-id=\"u614730a7\" id=\"u614730a7\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。</span></p><p data-lake-id=\"u8edd9308\" id=\"u8edd9308\"><span data-lake-id=\"u0c9a2f5c\" id=\"u0c9a2f5c\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">除此之外，SSA IR对其他优化方式也有很大的帮助，例如下面这个死代码删除（Dead Code Elimination）的例子：</span></p><p data-lake-id=\"u58545f6b\" id=\"u58545f6b\"><span data-lake-id=\"u6ab8150c\" id=\"u6ab8150c\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p data-lake-id=\"u826f45b2\" id=\"u826f45b2\"><strong><span data-lake-id=\"u364c2f01\" id=\"u364c2f01\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u00d696f8\" id=\"u00d696f8\"> </span><strong><span data-lake-id=\"u5567c5cb\" id=\"u5567c5cb\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u25d3765b\" id=\"u25d3765b\"> DeadCodeElimination{   </span><strong><span data-lake-id=\"u212aaa12\" id=\"u212aaa12\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ue96a69d1\" id=\"ue96a69d1\"> a = </span><span data-lake-id=\"uf55a78c4\" id=\"uf55a78c4\" style=\"color: rgb(165, 194, 97)\">2</span><span data-lake-id=\"u6f961d1e\" id=\"u6f961d1e\">;   </span><strong><span data-lake-id=\"u383c2bf6\" id=\"u383c2bf6\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ube191f15\" id=\"ube191f15\"> b = </span><span data-lake-id=\"u84a88a01\" id=\"u84a88a01\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u5fa2744b\" id=\"u5fa2744b\">   </span><strong><span data-lake-id=\"ub0ccdaa3\" id=\"ub0ccdaa3\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span data-lake-id=\"uf390c41c\" id=\"uf390c41c\">(</span><span data-lake-id=\"u8c966573\" id=\"u8c966573\" style=\"color: rgb(165, 194, 97)\">2</span><span data-lake-id=\"ufd6c78c2\" id=\"ufd6c78c2\"> &gt; </span><span data-lake-id=\"u9ecc7d8c\" id=\"u9ecc7d8c\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u96f375c5\" id=\"u96f375c5\">){     a = </span><span data-lake-id=\"ue0548af1\" id=\"ue0548af1\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"uf66f2c01\" id=\"uf66f2c01\">;   } </span><strong><span data-lake-id=\"u0e614abd\" id=\"u0e614abd\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span data-lake-id=\"u3979111b\" id=\"u3979111b\">{     b = </span><span data-lake-id=\"u30af7498\" id=\"u30af7498\" style=\"color: rgb(165, 194, 97)\">2</span><span data-lake-id=\"u71da1610\" id=\"u71da1610\">;   }   </span><strong><span data-lake-id=\"u2cd0fbf7\" id=\"u2cd0fbf7\" style=\"color: rgb(194, 98, 48)\">add</span></strong><span data-lake-id=\"u77a30b33\" id=\"u77a30b33\">(a,b) } </span></p><p data-lake-id=\"uf08c57dd\" id=\"uf08c57dd\"><span data-lake-id=\"u28ec796b\" id=\"u28ec796b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以得到SSA IR伪代码：</span></p><p data-lake-id=\"u3109dbb4\" id=\"u3109dbb4\"><span data-lake-id=\"ufcbf9746\" id=\"ufcbf9746\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p data-lake-id=\"u52dca725\" id=\"u52dca725\"><span data-lake-id=\"uac7bce66\" id=\"uac7bce66\" style=\"color: rgb(109, 156, 190)\">a_1</span><span data-lake-id=\"uc05ec985\" id=\"uc05ec985\"> = </span><span data-lake-id=\"u5d6db5d8\" id=\"u5d6db5d8\" style=\"color: rgb(165, 194, 97)\">2;</span><span data-lake-id=\"u3e677f1b\" id=\"u3e677f1b\"> </span><span data-lake-id=\"u68168940\" id=\"u68168940\" style=\"color: rgb(109, 156, 190)\">b_1</span><span data-lake-id=\"u8d476df6\" id=\"u8d476df6\"> = </span><span data-lake-id=\"u1a61cbac\" id=\"u1a61cbac\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"ub406747f\" id=\"ub406747f\"> </span><span data-lake-id=\"u681e693e\" id=\"u681e693e\" style=\"color: rgb(109, 156, 190)\">if</span><span data-lake-id=\"u9e75cef8\" id=\"u9e75cef8\"> </span><span data-lake-id=\"u6e854720\" id=\"u6e854720\" style=\"color: rgb(165, 194, 97)\">true:</span><span data-lake-id=\"u14f1c7ef\" id=\"u14f1c7ef\">   </span><span data-lake-id=\"u4fccc892\" id=\"u4fccc892\" style=\"color: rgb(109, 156, 190)\">a_2</span><span data-lake-id=\"u89f646ec\" id=\"u89f646ec\"> = </span><span data-lake-id=\"u0ef6dae4\" id=\"u0ef6dae4\" style=\"color: rgb(165, 194, 97)\">1;</span><span data-lake-id=\"u37301d3f\" id=\"u37301d3f\"> </span><span data-lake-id=\"u81b5a0cf\" id=\"u81b5a0cf\" style=\"color: rgb(109, 156, 190)\">else</span><span data-lake-id=\"u96f90b6b\" id=\"u96f90b6b\">   </span><span data-lake-id=\"u506e85a4\" id=\"u506e85a4\" style=\"color: rgb(109, 156, 190)\">b_2</span><span data-lake-id=\"u62bcbc3a\" id=\"u62bcbc3a\"> = </span><span data-lake-id=\"ua7df2aca\" id=\"ua7df2aca\" style=\"color: rgb(165, 194, 97)\">2;</span><span data-lake-id=\"u47b08e3e\" id=\"u47b08e3e\"> </span><span data-lake-id=\"u2e42ec4c\" id=\"u2e42ec4c\" style=\"color: rgb(109, 156, 190)\">add(a,b)</span><span data-lake-id=\"u1cdc0bc6\" id=\"u1cdc0bc6\"> </span></p><p data-lake-id=\"uad958982\" id=\"uad958982\"><span data-lake-id=\"u75c090ad\" id=\"u75c090ad\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行。经过死代码删除后就可以得到代码：</span></p><p data-lake-id=\"u33e92e3c\" id=\"u33e92e3c\"><span data-lake-id=\"u9990105a\" id=\"u9990105a\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">DeadCodeElimination</span></p><p data-lake-id=\"u400787f6\" id=\"u400787f6\"><strong><span data-lake-id=\"u53c02c20\" id=\"u53c02c20\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u375139ea\" id=\"u375139ea\"> </span><strong><span data-lake-id=\"ufb84641b\" id=\"ufb84641b\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uc41ce0fd\" id=\"uc41ce0fd\"> DeadCodeElimination{   </span><strong><span data-lake-id=\"u2032192a\" id=\"u2032192a\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u788c0051\" id=\"u788c0051\"> a = </span><span data-lake-id=\"u57aefc7d\" id=\"u57aefc7d\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u0eba5d05\" id=\"u0eba5d05\">;   </span><strong><span data-lake-id=\"uade5d7b1\" id=\"uade5d7b1\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u369dc94a\" id=\"u369dc94a\"> b = </span><span data-lake-id=\"ue24d7938\" id=\"ue24d7938\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"uac9a3b42\" id=\"uac9a3b42\">;   </span><strong><span data-lake-id=\"ueec6e9c2\" id=\"ueec6e9c2\" style=\"color: rgb(194, 98, 48)\">add</span></strong><span data-lake-id=\"u46a9ec7a\" id=\"u46a9ec7a\">(a,b) } </span></p><p data-lake-id=\"u081d4627\" id=\"u081d4627\"><span data-lake-id=\"u5775e595\" id=\"u5775e595\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的。</span></p><p data-lake-id=\"ue0183cd7\" id=\"ue0183cd7\"><strong><span data-lake-id=\"u78e9d33a\" id=\"u78e9d33a\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">C1中的中间表达形式</span></strong></p><p data-lake-id=\"u6f3f6fc0\" id=\"u6f3f6fc0\"><span data-lake-id=\"u31f889ef\" id=\"u31f889ef\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提及C1编译器内部使用高级中间表达形式HIR，低级中间表达形式LIR来进行各种优化，这两种IR都是SSA形式的。</span></p><p data-lake-id=\"ub69e2095\" id=\"ub69e2095\"><span data-lake-id=\"u221e6744\" id=\"u221e6744\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：</span></p><p data-lake-id=\"ue8bc2f53\" id=\"ue8bc2f53\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22ubc16084e-03ff-42f0-b180-ed37e87fe61%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u949b2c2b%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u1c41ea34\" id=\"u1c41ea34\"><span data-lake-id=\"u87a411fe\" id=\"u87a411fe\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。</span></p><p data-lake-id=\"ua8f98802\" id=\"ua8f98802\"><span data-lake-id=\"ue49917ae\" id=\"ue49917ae\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：</span></p><p data-lake-id=\"u10a459b3\" id=\"u10a459b3\"><span data-lake-id=\"u61d7aac2\" id=\"u61d7aac2\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">字节码构造HIR</span></p><p data-lake-id=\"u99729c37\" id=\"u99729c37\"><span data-lake-id=\"ufc16ae93\" id=\"ufc16ae93\">        字节码                     </span><strong><span data-lake-id=\"uf64b16e6\" id=\"uf64b16e6\" style=\"color: rgb(194, 98, 48)\">Local</span></strong><span data-lake-id=\"u62f94d54\" id=\"u62f94d54\"> </span><strong><span data-lake-id=\"u1f610ee2\" id=\"u1f610ee2\" style=\"color: rgb(194, 98, 48)\">Value</span></strong><span data-lake-id=\"uf478dbb9\" id=\"uf478dbb9\">             </span><strong><span data-lake-id=\"u4cf5d976\" id=\"u4cf5d976\" style=\"color: rgb(194, 98, 48)\">operand</span></strong><span data-lake-id=\"ufe445cfb\" id=\"ufe445cfb\"> </span><strong><span data-lake-id=\"u54e95853\" id=\"u54e95853\" style=\"color: rgb(194, 98, 48)\">stack</span></strong><span data-lake-id=\"u925cb707\" id=\"u925cb707\">              </span><strong><span data-lake-id=\"u33282acf\" id=\"u33282acf\" style=\"color: rgb(194, 98, 48)\">HIR</span></strong><span data-lake-id=\"u6ca7adae\" id=\"u6ca7adae\">       </span><strong><span data-lake-id=\"u0b758a71\" id=\"u0b758a71\" style=\"color: rgb(194, 98, 48)\">5</span></strong><span data-lake-id=\"udd8ac516\" id=\"udd8ac516\">: </span><strong><span data-lake-id=\"u4fcf12eb\" id=\"u4fcf12eb\" style=\"color: rgb(194, 98, 48)\">iload_1</span></strong><span data-lake-id=\"u3d85e76d\" id=\"u3d85e76d\">                  </span><span data-lake-id=\"ubab1ffb4\" id=\"ubab1ffb4\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span data-lake-id=\"ue1fd6489\" id=\"ue1fd6489\">                 </span><span data-lake-id=\"u3a760e98\" id=\"u3a760e98\" style=\"color: rgb(188, 96, 96)\">[i1]</span><span data-lake-id=\"ua3d4c4f3\" id=\"ua3d4c4f3\">       </span><strong><span data-lake-id=\"uc81d199a\" id=\"uc81d199a\" style=\"color: rgb(194, 98, 48)\">6</span></strong><span data-lake-id=\"uc0e0bbda\" id=\"uc0e0bbda\">: </span><strong><span data-lake-id=\"u995fed05\" id=\"u995fed05\" style=\"color: rgb(194, 98, 48)\">iload_2</span></strong><span data-lake-id=\"uaae14881\" id=\"uaae14881\">                  </span><span data-lake-id=\"u13770be7\" id=\"u13770be7\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span data-lake-id=\"u5be155d9\" id=\"u5be155d9\">                 </span><span data-lake-id=\"u2b901d28\" id=\"u2b901d28\" style=\"color: rgb(188, 96, 96)\">[i1,i2]</span><span data-lake-id=\"u94445e72\" id=\"u94445e72\">                                      ................................................   </span><strong><span data-lake-id=\"uda3c0483\" id=\"uda3c0483\" style=\"color: rgb(194, 98, 48)\">i3</span></strong><span data-lake-id=\"u52a7e140\" id=\"u52a7e140\">: </span><strong><span data-lake-id=\"u661373a1\" id=\"u661373a1\" style=\"color: rgb(194, 98, 48)\">i1</span></strong><span data-lake-id=\"ub926d116\" id=\"ub926d116\"> * </span><strong><span data-lake-id=\"ucf50eb8a\" id=\"ucf50eb8a\" style=\"color: rgb(194, 98, 48)\">i2</span></strong><span data-lake-id=\"u51dc5e7e\" id=\"u51dc5e7e\">       </span><strong><span data-lake-id=\"ufc9b40a6\" id=\"ufc9b40a6\" style=\"color: rgb(194, 98, 48)\">7</span></strong><span data-lake-id=\"u8e4c915c\" id=\"u8e4c915c\">: </span><strong><span data-lake-id=\"ub355de6b\" id=\"ub355de6b\" style=\"color: rgb(194, 98, 48)\">imul</span></strong><span data-lake-id=\"u6ea8f10f\" id=\"u6ea8f10f\">                                          </span><strong><span data-lake-id=\"u93db227a\" id=\"u93db227a\" style=\"color: rgb(194, 98, 48)\">8</span></strong><span data-lake-id=\"u13a60eac\" id=\"u13a60eac\">: </span><strong><span data-lake-id=\"u4f5efe93\" id=\"u4f5efe93\" style=\"color: rgb(194, 98, 48)\">istore_3</span></strong><span data-lake-id=\"u11544b13\" id=\"u11544b13\">                 </span><span data-lake-id=\"ua6315e9a\" id=\"ua6315e9a\" style=\"color: rgb(188, 96, 96)\">[i1,i2，i3]</span><span data-lake-id=\"u963f70a1\" id=\"u963f70a1\">              </span><span data-lake-id=\"uad88d1f2\" id=\"uad88d1f2\" style=\"color: rgb(188, 96, 96)\">[i3]</span><span data-lake-id=\"u912ac856\" id=\"u912ac856\"> </span></p><p data-lake-id=\"u48ee5c2d\" id=\"u48ee5c2d\"><span data-lake-id=\"ufd89f524\" id=\"ufd89f524\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。</span></p><p data-lake-id=\"u7ab70132\" id=\"u7ab70132\"><span data-lake-id=\"u6975bc12\" id=\"u6975bc12\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。</span></p><p data-lake-id=\"uaaf84acc\" id=\"uaaf84acc\"><strong><span data-lake-id=\"ub34b3383\" id=\"ub34b3383\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Sea-of-Nodes IR</span></strong></p><p data-lake-id=\"u658e25cf\" id=\"u658e25cf\"><span data-lake-id=\"ufc647c2a\" id=\"ufc647c2a\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：</span></p><p data-lake-id=\"u4f8ed85e\" id=\"u4f8ed85e\"><span data-lake-id=\"u94bcaa1c\" id=\"u94bcaa1c\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">example</span></p><p data-lake-id=\"ue1b45797\" id=\"ue1b45797\"><strong><span data-lake-id=\"u9aee24f6\" id=\"u9aee24f6\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u5d34837d\" id=\"u5d34837d\"> </span><strong><span data-lake-id=\"u7f15afba\" id=\"u7f15afba\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u5f5be873\" id=\"u5f5be873\"> </span><strong><span data-lake-id=\"uaff070ee\" id=\"uaff070ee\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ud4aca66c\" id=\"ud4aca66c\"> </span><strong><span data-lake-id=\"ua5e6911d\" id=\"ua5e6911d\" style=\"color: rgb(255, 198, 109)\">foo</span></strong><span data-lake-id=\"u4a2299c7\" id=\"u4a2299c7\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span data-lake-id=\"uc55bcd60\" id=\"uc55bcd60\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ub47afe7d\" id=\"ub47afe7d\" style=\"color: rgb(208, 208, 255)\"> count)</span><span data-lake-id=\"u060291f3\" id=\"u060291f3\"> </span><span data-lake-id=\"udb5605ef\" id=\"udb5605ef\">{   </span><strong><span data-lake-id=\"ua9b15b4b\" id=\"ua9b15b4b\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u54e5a2c3\" id=\"u54e5a2c3\"> sum = </span><span data-lake-id=\"uedcb80cb\" id=\"uedcb80cb\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u8609157a\" id=\"u8609157a\">;   </span><strong><span data-lake-id=\"ue5835280\" id=\"ue5835280\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"u06e37c3e\" id=\"u06e37c3e\"> (</span><strong><span data-lake-id=\"ud85ae5a3\" id=\"ud85ae5a3\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u56eefffb\" id=\"u56eefffb\"> i = </span><span data-lake-id=\"u4829c1a5\" id=\"u4829c1a5\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u842b5edd\" id=\"u842b5edd\">; i &lt; count; i++) {     sum += i;   }   </span><strong><span data-lake-id=\"u7d9a80c3\" id=\"u7d9a80c3\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"u1e5e2833\" id=\"u1e5e2833\"> sum; } </span></p><p data-lake-id=\"u775d6e99\" id=\"u775d6e99\"><span data-lake-id=\"u17d6ba5e\" id=\"u17d6ba5e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">对应的IR图如下所示：</span></p><p data-lake-id=\"u849b3569\" id=\"u849b3569\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u067f486a-9972-484a-992d-76c7a71887c%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u1cacffb7%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u76e878df\" id=\"u76e878df\"><span data-lake-id=\"u46e5cb88\" id=\"u46e5cb88\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。</span></p><p data-lake-id=\"u74891e56\" id=\"u74891e56\"><span data-lake-id=\"u1e8093b1\" id=\"u1e8093b1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这种图具有轻量级的边结构。 图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。</span></p><p data-lake-id=\"u73d21a64\" id=\"u73d21a64\"><span data-lake-id=\"u0eead443\" id=\"u0eead443\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。</span></p><p data-lake-id=\"u2e3b6802\" id=\"u2e3b6802\"><strong><span data-lake-id=\"ua92f8989\" id=\"ua92f8989\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Phi And Region Nodes</span></strong></p><p data-lake-id=\"u0c506ab2\" id=\"u0c506ab2\"><span data-lake-id=\"uffbb353b\" id=\"uffbb353b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Ideal Graph是SSA IR。 由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。</span></p><p data-lake-id=\"uf541b8f1\" id=\"uf541b8f1\"><span data-lake-id=\"u732b0e02\" id=\"u732b0e02\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">example</span></p><p data-lake-id=\"u87847572\" id=\"u87847572\"><strong><span data-lake-id=\"uc34b4b1a\" id=\"uc34b4b1a\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ub19f6fcc\" id=\"ub19f6fcc\"> </span><strong><span data-lake-id=\"uc74e5e32\" id=\"uc74e5e32\" style=\"color: rgb(255, 198, 109)\">test</span></strong><span data-lake-id=\"udd96f665\" id=\"udd96f665\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span data-lake-id=\"ud1edebf5\" id=\"ud1edebf5\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uba1c0ed3\" id=\"uba1c0ed3\" style=\"color: rgb(208, 208, 255)\"> x)</span><span data-lake-id=\"ub9afe97e\" id=\"ub9afe97e\"> </span><span data-lake-id=\"uc666a68d\" id=\"uc666a68d\">{ </span><strong><span data-lake-id=\"ucad97208\" id=\"ucad97208\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u6c0c245c\" id=\"u6c0c245c\"> a = </span><span data-lake-id=\"u77dd109f\" id=\"u77dd109f\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u2d05e045\" id=\"u2d05e045\">;   </span><strong><span data-lake-id=\"u66cf3b53\" id=\"u66cf3b53\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span data-lake-id=\"uda4bb364\" id=\"uda4bb364\">(x == </span><span data-lake-id=\"ud3e7a59d\" id=\"ud3e7a59d\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u4d148b66\" id=\"u4d148b66\">) {     a = </span><span data-lake-id=\"u2fb62d10\" id=\"u2fb62d10\" style=\"color: rgb(165, 194, 97)\">5</span><span data-lake-id=\"ue2026c0a\" id=\"ue2026c0a\">;   } </span><strong><span data-lake-id=\"u8c233fd3\" id=\"u8c233fd3\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span data-lake-id=\"uaef7f471\" id=\"uaef7f471\"> {     a = </span><span data-lake-id=\"u3ab3c711\" id=\"u3ab3c711\" style=\"color: rgb(165, 194, 97)\">6</span><span data-lake-id=\"ub92d66a3\" id=\"ub92d66a3\">;   }   </span><strong><span data-lake-id=\"u0ff97e70\" id=\"u0ff97e70\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"u0b928d02\" id=\"u0b928d02\"> a; } </span></p><p data-lake-id=\"u6f9997c6\" id=\"u6f9997c6\"><span data-lake-id=\"u17611fd4\" id=\"u17611fd4\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：</span></p><p data-lake-id=\"u0b83d294\" id=\"u0b83d294\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u02480518-993c-48df-90f1-c8051fc879d%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u72989f7b%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"ub73aa83d\" id=\"ub73aa83d\"><span data-lake-id=\"u86a997c9\" id=\"u86a997c9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：</span></p><p data-lake-id=\"ua97940e5\" id=\"ua97940e5\"><span data-lake-id=\"u07def3be\" id=\"u07def3be\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Phi Nodes</span></p><p data-lake-id=\"ub7994182\" id=\"ub7994182\"><span data-lake-id=\"u615351aa\" id=\"u615351aa\" style=\"color: rgb(109, 156, 190)\">int</span><span data-lake-id=\"u01aefd3c\" id=\"u01aefd3c\"> </span><span data-lake-id=\"u6496fa80\" id=\"u6496fa80\" style=\"color: rgb(165, 194, 97)\">test(int x) {</span><span data-lake-id=\"u14543976\" id=\"u14543976\">   </span><span data-lake-id=\"uc454b2d3\" id=\"uc454b2d3\" style=\"color: rgb(109, 156, 190)\">a_1</span><span data-lake-id=\"u791125e2\" id=\"u791125e2\"> = </span><span data-lake-id=\"u9aab53d8\" id=\"u9aab53d8\" style=\"color: rgb(165, 194, 97)\">0;</span><span data-lake-id=\"u23cc0e2a\" id=\"u23cc0e2a\">   </span><span data-lake-id=\"u9021f541\" id=\"u9021f541\" style=\"color: rgb(155, 133, 157)\">if(x</span><span data-lake-id=\"u4355efd9\" id=\"u4355efd9\"> =</span><span data-lake-id=\"ub04c14b8\" id=\"ub04c14b8\" style=\"color: rgb(165, 194, 97)\">= 1){</span><span data-lake-id=\"u08e86755\" id=\"u08e86755\">     </span><span data-lake-id=\"uf3d9dcd6\" id=\"uf3d9dcd6\" style=\"color: rgb(109, 156, 190)\">a_2</span><span data-lake-id=\"u7a28c57e\" id=\"u7a28c57e\"> = </span><span data-lake-id=\"uff1ab41e\" id=\"uff1ab41e\" style=\"color: rgb(165, 194, 97)\">5;</span><span data-lake-id=\"uc46faa40\" id=\"uc46faa40\">   </span><span data-lake-id=\"ubbee90d4\" id=\"ubbee90d4\" style=\"color: rgb(155, 133, 157)\">}else</span><span data-lake-id=\"u80bc5a74\" id=\"u80bc5a74\"> </span><span data-lake-id=\"ub328e887\" id=\"ub328e887\" style=\"color: rgb(165, 194, 97)\">{</span><span data-lake-id=\"u2d0dfbf0\" id=\"u2d0dfbf0\">     </span><span data-lake-id=\"u042b1a1a\" id=\"u042b1a1a\" style=\"color: rgb(109, 156, 190)\">a_3</span><span data-lake-id=\"u8d27e968\" id=\"u8d27e968\"> = </span><span data-lake-id=\"ue83e8280\" id=\"ue83e8280\" style=\"color: rgb(165, 194, 97)\">6;</span><span data-lake-id=\"u89a5a0ca\" id=\"u89a5a0ca\">   </span><span data-lake-id=\"ucf47ddbb\" id=\"ucf47ddbb\" style=\"color: rgb(109, 156, 190)\">}</span><span data-lake-id=\"u0452fd58\" id=\"u0452fd58\">   </span><span data-lake-id=\"ub41aa92d\" id=\"ub41aa92d\" style=\"color: rgb(109, 156, 190)\">a_4</span><span data-lake-id=\"uca00841b\" id=\"uca00841b\"> = </span><span data-lake-id=\"u9c5278e3\" id=\"u9c5278e3\" style=\"color: rgb(165, 194, 97)\">Phi(a_2,a_3);</span><span data-lake-id=\"u9fc8ef13\" id=\"u9fc8ef13\">   </span><span data-lake-id=\"ucf7ac6f8\" id=\"ucf7ac6f8\" style=\"color: rgb(109, 156, 190)\">return</span><span data-lake-id=\"ube3ae70b\" id=\"ube3ae70b\"> </span><span data-lake-id=\"uc7969287\" id=\"uc7969287\" style=\"color: rgb(165, 194, 97)\">a_4;</span><span data-lake-id=\"u2fd17a48\" id=\"u2fd17a48\"> </span><span data-lake-id=\"uf9719f09\" id=\"uf9719f09\" style=\"color: rgb(109, 156, 190)\">}</span><span data-lake-id=\"u33ac3a94\" id=\"u33ac3a94\"> </span></p><p data-lake-id=\"uaf1df5d6\" id=\"uaf1df5d6\"><strong><span data-lake-id=\"u7df85a7f\" id=\"u7df85a7f\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Global Value Numbering</span></strong></p><p data-lake-id=\"ua4349034\" id=\"ua4349034\"><span data-lake-id=\"u3bd742e4\" id=\"u3bd742e4\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。</span></p><p data-lake-id=\"u61e5e340\" id=\"u61e5e340\"><span data-lake-id=\"u62ec4488\" id=\"u62ec4488\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：</span></p><p data-lake-id=\"u8ae7675e\" id=\"u8ae7675e\"><span data-lake-id=\"uf5b6f6a8\" id=\"uf5b6f6a8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN</span></p><p data-lake-id=\"ube2c7230\" id=\"ube2c7230\"><span data-lake-id=\"u63f10904\" id=\"u63f10904\">a = 1; b = 2; c = a + b; d = a + b; e = d; </span></p><p data-lake-id=\"ud8bb529c\" id=\"ud8bb529c\"><span data-lake-id=\"u01f928f5\" id=\"u01f928f5\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。</span></p><p data-lake-id=\"u7a19670e\" id=\"u7a19670e\"><span data-lake-id=\"ue29fb4d9\" id=\"ue29fb4d9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。</span></p><h3 data-lake-id=\"WjweJ\" id=\"WjweJ\"><span data-lake-id=\"u16fdff2c\" id=\"u16fdff2c\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2.方法内联</span></h3><p data-lake-id=\"uab2e34da\" id=\"uab2e34da\"><span data-lake-id=\"u6d6a31e5\" id=\"u6d6a31e5\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。</span></p><p data-lake-id=\"u17fda851\" id=\"u17fda851\"><span data-lake-id=\"u06521531\" id=\"u06521531\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例（来源于网络）：</span></p><p data-lake-id=\"ubcd34f92\" id=\"ubcd34f92\"><span data-lake-id=\"uac801cbb\" id=\"uac801cbb\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">方法内联的过程</span></p><p data-lake-id=\"u95b1312b\" id=\"u95b1312b\"><strong><span data-lake-id=\"u1d8221c4\" id=\"u1d8221c4\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u30660cd0\" id=\"u30660cd0\"> </span><strong><span data-lake-id=\"u625c404d\" id=\"u625c404d\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ud1fdea8e\" id=\"ud1fdea8e\"> </span><strong><span data-lake-id=\"u5e1500b0\" id=\"u5e1500b0\" style=\"color: rgb(194, 98, 48)\">boolean</span></strong><span data-lake-id=\"u427b95fa\" id=\"u427b95fa\"> flag = </span><strong><span data-lake-id=\"uaa53323e\" id=\"uaa53323e\" style=\"color: rgb(194, 98, 48)\">true</span></strong><span data-lake-id=\"ucf519162\" id=\"ucf519162\">; </span><strong><span data-lake-id=\"uaca2504d\" id=\"uaca2504d\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u964c63fd\" id=\"u964c63fd\"> </span><strong><span data-lake-id=\"ube2633c0\" id=\"ube2633c0\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"uf6442832\" id=\"uf6442832\"> </span><strong><span data-lake-id=\"u4be91c20\" id=\"u4be91c20\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u541865a3\" id=\"u541865a3\"> value0 = </span><span data-lake-id=\"ud292d3b1\" id=\"ud292d3b1\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u1cf3ce74\" id=\"u1cf3ce74\">; </span><strong><span data-lake-id=\"u6bb67b7f\" id=\"u6bb67b7f\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u7e1d2769\" id=\"u7e1d2769\"> </span><strong><span data-lake-id=\"u6a375e6c\" id=\"u6a375e6c\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u99e851e5\" id=\"u99e851e5\"> </span><strong><span data-lake-id=\"u0c5e5e26\" id=\"u0c5e5e26\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ufa089235\" id=\"ufa089235\"> value1 = </span><span data-lake-id=\"uab5e573f\" id=\"uab5e573f\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"udf702c1b\" id=\"udf702c1b\">;  </span><strong><span data-lake-id=\"ubb6b4ba9\" id=\"ubb6b4ba9\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ud353139b\" id=\"ud353139b\"> </span><strong><span data-lake-id=\"udd65616a\" id=\"udd65616a\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u3ef92ad9\" id=\"u3ef92ad9\"> </span><strong><span data-lake-id=\"u6eafd385\" id=\"u6eafd385\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ucf9daaff\" id=\"ucf9daaff\"> </span><strong><span data-lake-id=\"u94dac463\" id=\"u94dac463\" style=\"color: rgb(255, 198, 109)\">foo</span></strong><span data-lake-id=\"u2bbbb564\" id=\"u2bbbb564\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span data-lake-id=\"ub5c9965f\" id=\"ub5c9965f\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u1921637a\" id=\"u1921637a\" style=\"color: rgb(208, 208, 255)\"> value)</span><span data-lake-id=\"u4b24e353\" id=\"u4b24e353\"> </span><span data-lake-id=\"u1ed56f8c\" id=\"u1ed56f8c\">{     </span><strong><span data-lake-id=\"u820588d3\" id=\"u820588d3\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uc460b338\" id=\"uc460b338\"> result = bar(flag);     </span><strong><span data-lake-id=\"u5d8240f8\" id=\"u5d8240f8\" style=\"color: rgb(194, 98, 48)\">if</span></strong><span data-lake-id=\"u462ca582\" id=\"u462ca582\"> (result != </span><span data-lake-id=\"u041af88b\" id=\"u041af88b\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u313c901f\" id=\"u313c901f\">) {         </span><strong><span data-lake-id=\"ud59fb9f7\" id=\"ud59fb9f7\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"ubd95647a\" id=\"ubd95647a\"> result;     } </span><strong><span data-lake-id=\"u6ed8e474\" id=\"u6ed8e474\" style=\"color: rgb(194, 98, 48)\">else</span></strong><span data-lake-id=\"u04874033\" id=\"u04874033\"> {         </span><strong><span data-lake-id=\"ue34b8ba0\" id=\"ue34b8ba0\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"u3dce52c1\" id=\"u3dce52c1\"> value;     } }  </span><strong><span data-lake-id=\"u43a8c1e4\" id=\"u43a8c1e4\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ua339a9d2\" id=\"ua339a9d2\"> </span><strong><span data-lake-id=\"u36649782\" id=\"u36649782\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u0f2115bf\" id=\"u0f2115bf\"> </span><strong><span data-lake-id=\"u336d3299\" id=\"u336d3299\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ufc4e145d\" id=\"ufc4e145d\"> </span><strong><span data-lake-id=\"ub33ac8d3\" id=\"ub33ac8d3\" style=\"color: rgb(255, 198, 109)\">bar</span></strong><span data-lake-id=\"u56104afb\" id=\"u56104afb\" style=\"color: rgb(208, 208, 255)\">(</span><strong><span data-lake-id=\"u16e17733\" id=\"u16e17733\" style=\"color: rgb(194, 98, 48)\">boolean</span></strong><span data-lake-id=\"u04ea2858\" id=\"u04ea2858\" style=\"color: rgb(208, 208, 255)\"> flag)</span><span data-lake-id=\"uaf62250f\" id=\"uaf62250f\"> </span><span data-lake-id=\"u8e3e2d89\" id=\"u8e3e2d89\">{     </span><strong><span data-lake-id=\"u13ff5104\" id=\"u13ff5104\" style=\"color: rgb(194, 98, 48)\">return</span></strong><span data-lake-id=\"u1d7ca7b1\" id=\"u1d7ca7b1\"> flag ? value0 : value1; } </span></p><p data-lake-id=\"u2aa4fc90\" id=\"u2aa4fc90\"><span data-lake-id=\"u76bd1e0b\" id=\"u76bd1e0b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">bar方法的IR图：</span></p><p data-lake-id=\"u275a5225\" id=\"u275a5225\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u00314411-872a-40d9-aea6-0ad9e202529%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u984ed21c%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u4238b547\" id=\"u4238b547\"><span data-lake-id=\"u9e041004\" id=\"u9e041004\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联后的IR图：</span></p><p data-lake-id=\"ubce024a7\" id=\"ubce024a7\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22ub3180e50-548d-46f5-bac2-5c9ff693457%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u47efc8da%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u460869f9\" id=\"u460869f9\"><span data-lake-id=\"ud3a6c924\" id=\"ud3a6c924\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。</span></p><p data-lake-id=\"ua8e7bdb2\" id=\"ua8e7bdb2\"><span data-lake-id=\"uf7e9cc7e\" id=\"uf7e9cc7e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。</span></p><p data-lake-id=\"uf7367549\" id=\"uf7367549\"><span data-lake-id=\"ua03beabe\" id=\"ua03beabe\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。</span></p><p data-lake-id=\"udbf66164\" id=\"udbf66164\"><span data-lake-id=\"u290cf962\" id=\"u290cf962\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。</span></p><p data-lake-id=\"u055fa346\" id=\"u055fa346\"><strong><span data-lake-id=\"ue0a05b4a\" id=\"ue0a05b4a\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">方法内联的条件</span></strong></p><p data-lake-id=\"uf48d05c2\" id=\"uf48d05c2\"><span data-lake-id=\"ue16d30d1\" id=\"ue16d30d1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。</span></p><p data-lake-id=\"u03641928\" id=\"u03641928\"><span data-lake-id=\"u9b130171\" id=\"u9b130171\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：</span></p><p data-lake-id=\"ue7c5cf8c\" id=\"ue7c5cf8c\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u146c8499-8b53-47a4-97fa-d6b925f995a%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u18d993ad%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u52ca4d6c\" id=\"u52ca4d6c\"><strong><span data-lake-id=\"u9b7c5e75\" id=\"u9b7c5e75\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">虚函数内联</span></strong></p><p data-lake-id=\"u1df5211e\" id=\"u1df5211e\"><span data-lake-id=\"ub1af25f5\" id=\"ub1af25f5\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。</span></p><p data-lake-id=\"u36a3a2ac\" id=\"u36a3a2ac\"><span data-lake-id=\"u9b10b641\" id=\"u9b10b641\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：</span></p><p data-lake-id=\"u0fe43f3b\" id=\"u0fe43f3b\"><span data-lake-id=\"u59071d16\" id=\"u59071d16\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">virtual call</span></p><p data-lake-id=\"u68ea0300\" id=\"u68ea0300\"><strong><span data-lake-id=\"ud89b5aaf\" id=\"ud89b5aaf\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u541f1180\" id=\"u541f1180\"> </span><strong><span data-lake-id=\"u5398353a\" id=\"u5398353a\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u084c6d45\" id=\"u084c6d45\"> </span><strong><span data-lake-id=\"ued27e0eb\" id=\"ued27e0eb\" style=\"color: rgb(255, 198, 109)\">SimpleInliningTest</span></strong><span data-lake-id=\"u756c7ded\" id=\"u756c7ded\"> </span><span data-lake-id=\"ue5e875f1\" id=\"ue5e875f1\">{     </span><strong><span data-lake-id=\"uc4225c9b\" id=\"uc4225c9b\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u4256ae25\" id=\"u4256ae25\"> </span><strong><span data-lake-id=\"uee949992\" id=\"uee949992\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u6bda16aa\" id=\"u6bda16aa\"> </span><strong><span data-lake-id=\"u2a4a217e\" id=\"u2a4a217e\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u779fc141\" id=\"u779fc141\"> </span><strong><span data-lake-id=\"u95241756\" id=\"u95241756\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span data-lake-id=\"ubdd1b8c7\" id=\"ubdd1b8c7\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span data-lake-id=\"ua34ae683\" id=\"ua34ae683\"> </span><strong><span data-lake-id=\"u23f09f00\" id=\"u23f09f00\" style=\"color: rgb(194, 98, 48)\">throws</span></strong><span data-lake-id=\"u748486f1\" id=\"u748486f1\"> InterruptedException </span><span data-lake-id=\"ue670dde8\" id=\"ue670dde8\">{         VirtualInvokeTest obj = </span><strong><span data-lake-id=\"uf28cb631\" id=\"uf28cb631\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"uf9ef91d8\" id=\"uf9ef91d8\"> VirtualInvokeTest();         VirtualInvoke1 obj1 = </span><strong><span data-lake-id=\"u6f6457df\" id=\"u6f6457df\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u489bd242\" id=\"u489bd242\"> VirtualInvoke1();         </span><strong><span data-lake-id=\"u5ec6ae86\" id=\"u5ec6ae86\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"ue5164a00\" id=\"ue5164a00\"> (</span><strong><span data-lake-id=\"u7cc179f3\" id=\"u7cc179f3\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u5db6072e\" id=\"u5db6072e\"> i = </span><span data-lake-id=\"u84ef0362\" id=\"u84ef0362\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u49d0c444\" id=\"u49d0c444\">; i &lt; </span><span data-lake-id=\"ud67b6a52\" id=\"ud67b6a52\" style=\"color: rgb(165, 194, 97)\">100000</span><span data-lake-id=\"u5830e4d7\" id=\"u5830e4d7\">; i++) {             invokeMethod(obj);             invokeMethod(obj1);         }         Thread.sleep(</span><span data-lake-id=\"ua558ec4a\" id=\"ua558ec4a\" style=\"color: rgb(165, 194, 97)\">1000</span><span data-lake-id=\"udd517c49\" id=\"udd517c49\">);     }      </span><strong><span data-lake-id=\"ucc9acb44\" id=\"ucc9acb44\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u9225fe7f\" id=\"u9225fe7f\"> </span><strong><span data-lake-id=\"u138b41f9\" id=\"u138b41f9\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u8f991a0f\" id=\"u8f991a0f\"> </span><strong><span data-lake-id=\"ub00dccb0\" id=\"ub00dccb0\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uff63ae26\" id=\"uff63ae26\"> </span><strong><span data-lake-id=\"uf4bd3929\" id=\"uf4bd3929\" style=\"color: rgb(255, 198, 109)\">invokeMethod</span></strong><span data-lake-id=\"uee8bb4db\" id=\"uee8bb4db\" style=\"color: rgb(208, 208, 255)\">(VirtualInvokeTest obj)</span><span data-lake-id=\"u3ea63ddb\" id=\"u3ea63ddb\"> </span><span data-lake-id=\"uddc7a61d\" id=\"uddc7a61d\">{         obj.methodCall();     }      </span><strong><span data-lake-id=\"u560a9880\" id=\"u560a9880\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"ub78f7ba9\" id=\"ub78f7ba9\"> </span><strong><span data-lake-id=\"ubeceb1e6\" id=\"ubeceb1e6\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ude7d9241\" id=\"ude7d9241\"> </span><strong><span data-lake-id=\"u8101accc\" id=\"u8101accc\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"ud5e1724d\" id=\"ud5e1724d\"> </span><strong><span data-lake-id=\"u66afeb4b\" id=\"u66afeb4b\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"u9da52b2a\" id=\"u9da52b2a\"> </span><span data-lake-id=\"ubfbc033b\" id=\"ubfbc033b\">{         </span><strong><span data-lake-id=\"ud68b0ed8\" id=\"ud68b0ed8\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u58b48d38\" id=\"u58b48d38\"> </span><strong><span data-lake-id=\"u39918733\" id=\"u39918733\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u8b25a8a4\" id=\"u8b25a8a4\"> </span><strong><span data-lake-id=\"u6a97a210\" id=\"u6a97a210\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"ue205dd4e\" id=\"ue205dd4e\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u3a052c7e\" id=\"u3a052c7e\"> </span><span data-lake-id=\"u36729b2a\" id=\"u36729b2a\">{             System.out.println(</span><span data-lake-id=\"u7f316a1b\" id=\"u7f316a1b\" style=\"color: rgb(165, 194, 97)\">&quot;virtual call&quot;</span><span data-lake-id=\"ua6e42742\" id=\"ua6e42742\">);         }     }      </span><strong><span data-lake-id=\"u820d3e31\" id=\"u820d3e31\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"u0ace6235\" id=\"u0ace6235\"> </span><strong><span data-lake-id=\"u7287aa9a\" id=\"u7287aa9a\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"udf2bf025\" id=\"udf2bf025\"> </span><strong><span data-lake-id=\"u400ddcce\" id=\"u400ddcce\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u34629a76\" id=\"u34629a76\"> </span><strong><span data-lake-id=\"uee06c488\" id=\"uee06c488\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke1</span></strong><span data-lake-id=\"u7a6b9278\" id=\"u7a6b9278\"> </span><strong><span data-lake-id=\"uf135860f\" id=\"uf135860f\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span data-lake-id=\"u50e3e770\" id=\"u50e3e770\"> </span><strong><span data-lake-id=\"ue4f68ec1\" id=\"ue4f68ec1\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"u8a600a63\" id=\"u8a600a63\"> </span><span data-lake-id=\"u0cf18f06\" id=\"u0cf18f06\">{         </span><span data-lake-id=\"u86e3ab51\" id=\"u86e3ab51\" style=\"color: rgb(155, 133, 157)\">@Override</span><span data-lake-id=\"u8146feaf\" id=\"u8146feaf\">         </span><strong><span data-lake-id=\"udb012ae5\" id=\"udb012ae5\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ufa91df4e\" id=\"ufa91df4e\"> </span><strong><span data-lake-id=\"u98f7c5bc\" id=\"u98f7c5bc\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u417847a4\" id=\"u417847a4\"> </span><strong><span data-lake-id=\"uf21b0762\" id=\"uf21b0762\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"u0039c290\" id=\"u0039c290\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u3d47864f\" id=\"u3d47864f\"> </span><span data-lake-id=\"u4eb36670\" id=\"u4eb36670\">{             </span><strong><span data-lake-id=\"u86b57c34\" id=\"u86b57c34\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span data-lake-id=\"u69e907c9\" id=\"u69e907c9\">.methodCall();         }     } } </span></p><p data-lake-id=\"ubc53ef60\" id=\"ubc53ef60\"><span data-lake-id=\"u7b18793a\" id=\"u7b18793a\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：</span></p><p data-lake-id=\"ucd58977a\" id=\"ucd58977a\"><span data-lake-id=\"ua7099476\" id=\"ua7099476\"> </span><span data-lake-id=\"u27a6a08c\" id=\"u27a6a08c\" style=\"color: rgb(165, 194, 97)\">0x0000000113369d37</span><span data-lake-id=\"ue7c9b198\" id=\"ue7c9b198\">: callq  </span><span data-lake-id=\"ud56d6162\" id=\"ud56d6162\" style=\"color: rgb(165, 194, 97)\">0x00000001132950a0</span><span data-lake-id=\"ucdf0d2fd\" id=\"ucdf0d2fd\">  ; OopMap{off=</span><span data-lake-id=\"u4e009243\" id=\"u4e009243\" style=\"color: rgb(165, 194, 97)\">476</span><span data-lake-id=\"ue3d4df8b\" id=\"ue3d4df8b\">}                                                 ;*invokevirtual methodCall  </span><em><span data-lake-id=\"u34fcea7e\" id=\"u34fcea7e\" style=\"color: rgb(188, 148, 88)\">//代表虚调用</span></em><span data-lake-id=\"uf53f245f\" id=\"uf53f245f\">                                                 ; - SimpleInliningTest::invokeMethod@</span><span data-lake-id=\"u4b6ea4b5\" id=\"u4b6ea4b5\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u9df32d2d\" id=\"u9df32d2d\"> (line </span><span data-lake-id=\"u5acf4641\" id=\"u5acf4641\" style=\"color: rgb(165, 194, 97)\">18</span><span data-lake-id=\"ud5d3a73f\" id=\"ud5d3a73f\">)                                                 ;   {optimized virtual_call}  </span><em><span data-lake-id=\"uf7b0033c\" id=\"uf7b0033c\" style=\"color: rgb(188, 148, 88)\">//虚调用已经被优化</span></em><span data-lake-id=\"u9917d615\" id=\"u9917d615\"> </span></p><p data-lake-id=\"u19576672\" id=\"u19576672\"><span data-lake-id=\"ub14c94e9\" id=\"ub14c94e9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。</span></p><p data-lake-id=\"uff654061\" id=\"uff654061\"><span data-lake-id=\"u03be4947\" id=\"u03be4947\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">比如下面这段代码，我们增加一个实现：</span></p><p data-lake-id=\"u1ddb8da6\" id=\"u1ddb8da6\"><span data-lake-id=\"u6e1d2bd6\" id=\"u6e1d2bd6\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">多实现的虚调用</span></p><p data-lake-id=\"u354caeb4\" id=\"u354caeb4\"><strong><span data-lake-id=\"u96e06802\" id=\"u96e06802\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"udcdd7dd8\" id=\"udcdd7dd8\"> </span><strong><span data-lake-id=\"u0aff9bae\" id=\"u0aff9bae\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u366365bd\" id=\"u366365bd\"> </span><strong><span data-lake-id=\"u585e3206\" id=\"u585e3206\" style=\"color: rgb(255, 198, 109)\">SimpleInliningTest</span></strong><span data-lake-id=\"ucd60e16a\" id=\"ucd60e16a\"> </span><span data-lake-id=\"u70558fa5\" id=\"u70558fa5\">{     </span><strong><span data-lake-id=\"uaed50c81\" id=\"uaed50c81\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u22d3f7f8\" id=\"u22d3f7f8\"> </span><strong><span data-lake-id=\"ueaa92438\" id=\"ueaa92438\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ub9e4be07\" id=\"ub9e4be07\"> </span><strong><span data-lake-id=\"u9286741c\" id=\"u9286741c\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u9b562b73\" id=\"u9b562b73\"> </span><strong><span data-lake-id=\"u3bb66e8e\" id=\"u3bb66e8e\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span data-lake-id=\"ua539e9c6\" id=\"ua539e9c6\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span data-lake-id=\"u25c575bd\" id=\"u25c575bd\"> </span><strong><span data-lake-id=\"ue3851572\" id=\"ue3851572\" style=\"color: rgb(194, 98, 48)\">throws</span></strong><span data-lake-id=\"uabf1dc25\" id=\"uabf1dc25\"> InterruptedException </span><span data-lake-id=\"u30b14254\" id=\"u30b14254\">{         VirtualInvokeTest obj = </span><strong><span data-lake-id=\"u139cae43\" id=\"u139cae43\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"ub5e6599f\" id=\"ub5e6599f\"> VirtualInvokeTest();         VirtualInvoke1 obj1 = </span><strong><span data-lake-id=\"u874f3fa6\" id=\"u874f3fa6\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"udd9af692\" id=\"udd9af692\"> VirtualInvoke1();         VirtualInvoke2 obj2 = </span><strong><span data-lake-id=\"u1aaf64f8\" id=\"u1aaf64f8\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u3af23c74\" id=\"u3af23c74\"> VirtualInvoke2();         </span><strong><span data-lake-id=\"u3390d304\" id=\"u3390d304\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"u7fd36254\" id=\"u7fd36254\"> (</span><strong><span data-lake-id=\"u43d224b4\" id=\"u43d224b4\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uabc668c6\" id=\"uabc668c6\"> i = </span><span data-lake-id=\"u3e5245df\" id=\"u3e5245df\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u811b6963\" id=\"u811b6963\">; i &lt; </span><span data-lake-id=\"u77ec7513\" id=\"u77ec7513\" style=\"color: rgb(165, 194, 97)\">100000</span><span data-lake-id=\"uddc3f5d7\" id=\"uddc3f5d7\">; i++) {             invokeMethod(obj);             invokeMethod(obj1);         invokeMethod(obj2);         }         Thread.sleep(</span><span data-lake-id=\"u464d8a10\" id=\"u464d8a10\" style=\"color: rgb(165, 194, 97)\">1000</span><span data-lake-id=\"u02b1d5da\" id=\"u02b1d5da\">);     }      </span><strong><span data-lake-id=\"ueeceba4f\" id=\"ueeceba4f\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"uecc2e41e\" id=\"uecc2e41e\"> </span><strong><span data-lake-id=\"ue59d8fd2\" id=\"ue59d8fd2\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"uff31af3a\" id=\"uff31af3a\"> </span><strong><span data-lake-id=\"u0b7d2680\" id=\"u0b7d2680\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u4067f141\" id=\"u4067f141\"> </span><strong><span data-lake-id=\"u0f45967a\" id=\"u0f45967a\" style=\"color: rgb(255, 198, 109)\">invokeMethod</span></strong><span data-lake-id=\"u64941a90\" id=\"u64941a90\" style=\"color: rgb(208, 208, 255)\">(VirtualInvokeTest obj)</span><span data-lake-id=\"ue15c6598\" id=\"ue15c6598\"> </span><span data-lake-id=\"u05757266\" id=\"u05757266\">{         obj.methodCall();     }      </span><strong><span data-lake-id=\"ua518886e\" id=\"ua518886e\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"u5b48470c\" id=\"u5b48470c\"> </span><strong><span data-lake-id=\"u728c82d1\" id=\"u728c82d1\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u6696f9bc\" id=\"u6696f9bc\"> </span><strong><span data-lake-id=\"uec718bf9\" id=\"uec718bf9\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u2c5b6264\" id=\"u2c5b6264\"> </span><strong><span data-lake-id=\"uc1f7cb33\" id=\"uc1f7cb33\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"uce13c381\" id=\"uce13c381\"> </span><span data-lake-id=\"u122031e6\" id=\"u122031e6\">{         </span><strong><span data-lake-id=\"ue4641472\" id=\"ue4641472\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u6040be2b\" id=\"u6040be2b\"> </span><strong><span data-lake-id=\"u49311887\" id=\"u49311887\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u97e24cf0\" id=\"u97e24cf0\"> </span><strong><span data-lake-id=\"udb887a1c\" id=\"udb887a1c\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"u4eadf8e6\" id=\"u4eadf8e6\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u40e62b63\" id=\"u40e62b63\"> </span><span data-lake-id=\"u851238f1\" id=\"u851238f1\">{             System.out.println(</span><span data-lake-id=\"u581b0345\" id=\"u581b0345\" style=\"color: rgb(165, 194, 97)\">&quot;virtual call&quot;</span><span data-lake-id=\"u2afb8028\" id=\"u2afb8028\">);         }     }      </span><strong><span data-lake-id=\"uf34c7e39\" id=\"uf34c7e39\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"ube8ee444\" id=\"ube8ee444\"> </span><strong><span data-lake-id=\"u8f1af71a\" id=\"u8f1af71a\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ua188ded0\" id=\"ua188ded0\"> </span><strong><span data-lake-id=\"ud8d819ad\" id=\"ud8d819ad\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u0adfdf6d\" id=\"u0adfdf6d\"> </span><strong><span data-lake-id=\"u7cb11a64\" id=\"u7cb11a64\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke1</span></strong><span data-lake-id=\"ud6e259f8\" id=\"ud6e259f8\"> </span><strong><span data-lake-id=\"u629c7da9\" id=\"u629c7da9\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span data-lake-id=\"u5caa655e\" id=\"u5caa655e\"> </span><strong><span data-lake-id=\"uf6249576\" id=\"uf6249576\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"u2764a17d\" id=\"u2764a17d\"> </span><span data-lake-id=\"u2ec13e09\" id=\"u2ec13e09\">{         </span><span data-lake-id=\"udacb9a23\" id=\"udacb9a23\" style=\"color: rgb(155, 133, 157)\">@Override</span><span data-lake-id=\"u2661397e\" id=\"u2661397e\">         </span><strong><span data-lake-id=\"u730e09b6\" id=\"u730e09b6\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u04c65198\" id=\"u04c65198\"> </span><strong><span data-lake-id=\"uc875c993\" id=\"uc875c993\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"ue7073470\" id=\"ue7073470\"> </span><strong><span data-lake-id=\"u309acfed\" id=\"u309acfed\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"u80ec7223\" id=\"u80ec7223\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u2e8cff65\" id=\"u2e8cff65\"> </span><span data-lake-id=\"u01e78681\" id=\"u01e78681\">{             </span><strong><span data-lake-id=\"uda9670d0\" id=\"uda9670d0\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span data-lake-id=\"ub776bd34\" id=\"ub776bd34\">.methodCall();         }     }     </span><strong><span data-lake-id=\"u70b26839\" id=\"u70b26839\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"u0a029624\" id=\"u0a029624\"> </span><strong><span data-lake-id=\"ua06acb39\" id=\"ua06acb39\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"ud0a3b13c\" id=\"ud0a3b13c\"> </span><strong><span data-lake-id=\"ub01b8c7d\" id=\"ub01b8c7d\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u1becfab6\" id=\"u1becfab6\"> </span><strong><span data-lake-id=\"u692f8af4\" id=\"u692f8af4\" style=\"color: rgb(255, 198, 109)\">VirtualInvoke2</span></strong><span data-lake-id=\"uf4ce46cf\" id=\"uf4ce46cf\"> </span><strong><span data-lake-id=\"uecde6dd9\" id=\"uecde6dd9\" style=\"color: rgb(194, 98, 48)\">extends</span></strong><span data-lake-id=\"ue5899bc9\" id=\"ue5899bc9\"> </span><strong><span data-lake-id=\"u973cac60\" id=\"u973cac60\" style=\"color: rgb(255, 198, 109)\">VirtualInvokeTest</span></strong><span data-lake-id=\"ua382ac4d\" id=\"ua382ac4d\"> </span><span data-lake-id=\"u897e1ea4\" id=\"u897e1ea4\">{         </span><span data-lake-id=\"u721a0603\" id=\"u721a0603\" style=\"color: rgb(155, 133, 157)\">@Override</span><span data-lake-id=\"u2148fe4c\" id=\"u2148fe4c\">         </span><strong><span data-lake-id=\"ue7a7d775\" id=\"ue7a7d775\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u210a75de\" id=\"u210a75de\"> </span><strong><span data-lake-id=\"ua66f85c2\" id=\"ua66f85c2\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uf67e1b97\" id=\"uf67e1b97\"> </span><strong><span data-lake-id=\"u4ebd4754\" id=\"u4ebd4754\" style=\"color: rgb(255, 198, 109)\">methodCall</span></strong><span data-lake-id=\"uf8dc3202\" id=\"uf8dc3202\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u028f2aac\" id=\"u028f2aac\"> </span><span data-lake-id=\"u7695bfc2\" id=\"u7695bfc2\">{             </span><strong><span data-lake-id=\"u47a928ed\" id=\"u47a928ed\" style=\"color: rgb(194, 98, 48)\">super</span></strong><span data-lake-id=\"u04cc3055\" id=\"u04cc3055\">.methodCall();         }     } } </span></p><p data-lake-id=\"u0d241b7a\" id=\"u0d241b7a\"><span data-lake-id=\"u411b1348\" id=\"u411b1348\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过反编译得到下面的汇编代码：</span></p><p data-lake-id=\"u66643733\" id=\"u66643733\"><span data-lake-id=\"ue13e470d\" id=\"ue13e470d\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">代码块</span></p><p data-lake-id=\"u687952ad\" id=\"u687952ad\"><span data-lake-id=\"uf7de9084\" id=\"uf7de9084\"> </span><span data-lake-id=\"u578532b6\" id=\"u578532b6\" style=\"color: rgb(165, 194, 97)\">0x000000011f5f</span><span data-lake-id=\"u6bad1031\" id=\"u6bad1031\">0a37: callq  </span><span data-lake-id=\"u780903eb\" id=\"u780903eb\" style=\"color: rgb(165, 194, 97)\">0x000000011f4fd</span><span data-lake-id=\"ud1187eda\" id=\"ud1187eda\">2e0  ; OopMap{off=</span><span data-lake-id=\"u5d0ceb3a\" id=\"u5d0ceb3a\" style=\"color: rgb(165, 194, 97)\">28</span><span data-lake-id=\"u894b17a8\" id=\"u894b17a8\">}                                                 ;*invokevirtual methodCall  </span><em><span data-lake-id=\"u058af300\" id=\"u058af300\" style=\"color: rgb(188, 148, 88)\">//代表虚调用</span></em><span data-lake-id=\"u37312d1a\" id=\"u37312d1a\">                                                 ; - SimpleInliningTest::invokeMethod@</span><span data-lake-id=\"u06c9c4e0\" id=\"u06c9c4e0\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u4eca420a\" id=\"u4eca420a\"> (line </span><span data-lake-id=\"u29b7516e\" id=\"u29b7516e\" style=\"color: rgb(165, 194, 97)\">20</span><span data-lake-id=\"u2e43b761\" id=\"u2e43b761\">)                                                 ;   {virtual_call}  </span><em><span data-lake-id=\"ub18cfa09\" id=\"ub18cfa09\" style=\"color: rgb(188, 148, 88)\">//虚调用未被优化</span></em><span data-lake-id=\"uc2ab1f01\" id=\"uc2ab1f01\"> </span></p><p data-lake-id=\"u653022cd\" id=\"u653022cd\"><span data-lake-id=\"u3389a45e\" id=\"u3389a45e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看到多个实现的虚调用未被优化，依然是virtual_call。</span></p><p data-lake-id=\"uf791d063\" id=\"uf791d063\"><span data-lake-id=\"u80159ff5\" id=\"u80159ff5\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器针对这种情况，会去收集这部分执行的信息，比如在一段时间，发现前面的接口方法的调用add和sub是各占50%的几率，那么JVM就会在每次运行时，遇到add就把add内联进来，遇到sub的情况再把sub函数内联进来，这样这两个路径的执行效率就会提升。在后续如果遇到其他不常见的情况，JVM就会进行去优化的操作，在那个位置做标记，再遇到这种情况时切换回解释执行。</span></p><h3 data-lake-id=\"nTiw8\" id=\"nTiw8\"><span data-lake-id=\"u7bf98658\" id=\"u7bf98658\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 逃逸分析</span></h3><p data-lake-id=\"ue34ecb63\" id=\"ue34ecb63\"><span data-lake-id=\"u2f195bdc\" id=\"u2f195bdc\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：</span></p><ol list=\"ucda6ec24\"><li fid=\"ue87cf42c\" data-lake-id=\"ua34c15e7\" id=\"ua34c15e7\"><span data-lake-id=\"u34e94ec5\" id=\"u34e94ec5\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。</span></li><li fid=\"ue87cf42c\" data-lake-id=\"ucade2de2\" id=\"ucade2de2\"><span data-lake-id=\"uc4bf7090\" id=\"uc4bf7090\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。</span></li></ol><p data-lake-id=\"u718a1567\" id=\"u718a1567\"><span data-lake-id=\"uc137221a\" id=\"uc137221a\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：</span></p><p data-lake-id=\"u1b53e444\" id=\"u1b53e444\"><span data-lake-id=\"u29dc890d\" id=\"u29dc890d\">pulbic </span><strong><span data-lake-id=\"ud402fe30\" id=\"ud402fe30\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u89a2d6da\" id=\"u89a2d6da\"> </span><strong><span data-lake-id=\"uf36bbcd2\" id=\"uf36bbcd2\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span data-lake-id=\"u11826bfc\" id=\"u11826bfc\">{     </span><strong><span data-lake-id=\"u8d47b154\" id=\"u8d47b154\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u9dcd4f5c\" id=\"u9dcd4f5c\"> </span><strong><span data-lake-id=\"u01e5e87d\" id=\"u01e5e87d\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"uc72dc148\" id=\"uc72dc148\"> </span><strong><span data-lake-id=\"u9ce736c8\" id=\"u9ce736c8\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"ufc021844\" id=\"ufc021844\"> </span><strong><span data-lake-id=\"u8b823619\" id=\"u8b823619\" style=\"color: rgb(255, 198, 109)\">main</span></strong><span data-lake-id=\"u1ccd50a7\" id=\"u1ccd50a7\" style=\"color: rgb(208, 208, 255)\">(String[] args)</span><span data-lake-id=\"u7f42e578\" id=\"u7f42e578\"> </span><span data-lake-id=\"uad2e3cb7\" id=\"uad2e3cb7\">{       example();     }     </span><strong><span data-lake-id=\"uf9479ce2\" id=\"uf9479ce2\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u6862bf5a\" id=\"u6862bf5a\"> </span><strong><span data-lake-id=\"u6f4cd6f5\" id=\"u6f4cd6f5\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u06075618\" id=\"u06075618\"> </span><strong><span data-lake-id=\"udafa76f2\" id=\"udafa76f2\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u5b305dac\" id=\"u5b305dac\"> </span><strong><span data-lake-id=\"u97d3bb11\" id=\"u97d3bb11\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span data-lake-id=\"ub792db28\" id=\"ub792db28\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u05f6fe6b\" id=\"u05f6fe6b\"> </span><span data-lake-id=\"u7d9c662d\" id=\"u7d9c662d\">{       Foo foo = </span><strong><span data-lake-id=\"u0607d926\" id=\"u0607d926\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u9aee4453\" id=\"u9aee4453\"> Foo();       Bar bar = </span><strong><span data-lake-id=\"udd65834e\" id=\"udd65834e\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u404aa0d4\" id=\"u404aa0d4\"> Bar();       bar.setFoo(foo);     }   }    </span><strong><span data-lake-id=\"u779f64dc\" id=\"u779f64dc\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u89359f67\" id=\"u89359f67\"> </span><strong><span data-lake-id=\"u5e98a016\" id=\"u5e98a016\" style=\"color: rgb(255, 198, 109)\">Foo</span></strong><span data-lake-id=\"u465f48cc\" id=\"u465f48cc\"> </span><span data-lake-id=\"u551c7ac2\" id=\"u551c7ac2\">{}    </span><strong><span data-lake-id=\"uede2c867\" id=\"uede2c867\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u4682c427\" id=\"u4682c427\"> </span><strong><span data-lake-id=\"u86dd850f\" id=\"u86dd850f\" style=\"color: rgb(255, 198, 109)\">Bar</span></strong><span data-lake-id=\"u154af0b3\" id=\"u154af0b3\"> </span><span data-lake-id=\"ud381b6ad\" id=\"ud381b6ad\">{     </span><strong><span data-lake-id=\"u28ca0e4a\" id=\"u28ca0e4a\" style=\"color: rgb(194, 98, 48)\">private</span></strong><span data-lake-id=\"u544906f4\" id=\"u544906f4\"> Foo foo;     </span><strong><span data-lake-id=\"ud0f7ef68\" id=\"ud0f7ef68\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ub316d3cf\" id=\"ub316d3cf\"> </span><strong><span data-lake-id=\"u06da27da\" id=\"u06da27da\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"u97551541\" id=\"u97551541\"> </span><strong><span data-lake-id=\"ue04a901b\" id=\"ue04a901b\" style=\"color: rgb(255, 198, 109)\">setFoo</span></strong><span data-lake-id=\"ue49742fc\" id=\"ue49742fc\" style=\"color: rgb(208, 208, 255)\">(Foo foo)</span><span data-lake-id=\"uc4d7f46d\" id=\"uc4d7f46d\"> </span><span data-lake-id=\"ucd764c05\" id=\"ucd764c05\">{       </span><strong><span data-lake-id=\"ua9ac366b\" id=\"ua9ac366b\" style=\"color: rgb(194, 98, 48)\">this</span></strong><span data-lake-id=\"ucfad544e\" id=\"ucfad544e\">.foo = foo;     }   } } </span></p><p data-lake-id=\"u43d6822b\" id=\"u43d6822b\"><span data-lake-id=\"uf8b384eb\" id=\"uf8b384eb\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。</span></p><p data-lake-id=\"ud1977f0f\" id=\"ud1977f0f\"><strong><span data-lake-id=\"u07d262b5\" id=\"u07d262b5\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">锁消除</span></strong></p><p data-lake-id=\"u11e106a6\" id=\"u11e106a6\"><span data-lake-id=\"ueb3e6285\" id=\"ueb3e6285\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。</span></p><p data-lake-id=\"uc721a5f5\" id=\"uc721a5f5\"><span data-lake-id=\"u2c6d6972\" id=\"u2c6d6972\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。</span></p><p data-lake-id=\"u1a039201\" id=\"u1a039201\"><strong><span data-lake-id=\"u685ce94e\" id=\"u685ce94e\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">栈上分配</span></strong></p><p data-lake-id=\"u5355739f\" id=\"u5355739f\"><span data-lake-id=\"u24e498a8\" id=\"u24e498a8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：</span></p><p data-lake-id=\"u81a96399\" id=\"u81a96399\"><span data-lake-id=\"ufd186981\" id=\"ufd186981\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">标量替换</span></p><p data-lake-id=\"uccc85a28\" id=\"uccc85a28\"><strong><span data-lake-id=\"uc7ad6457\" id=\"uc7ad6457\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u0527a4c9\" id=\"u0527a4c9\"> </span><strong><span data-lake-id=\"uec3d8f8b\" id=\"uec3d8f8b\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"ufaced914\" id=\"ufaced914\"> </span><strong><span data-lake-id=\"u78bb7135\" id=\"u78bb7135\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span data-lake-id=\"u76894575\" id=\"u76894575\">{   </span><span data-lake-id=\"uae7b6b09\" id=\"uae7b6b09\" style=\"color: rgb(155, 133, 157)\">@AllArgsConstructor</span><span data-lake-id=\"u45175fa9\" id=\"u45175fa9\">   </span><strong><span data-lake-id=\"u38fa68f5\" id=\"u38fa68f5\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"u5c3e335d\" id=\"u5c3e335d\"> </span><strong><span data-lake-id=\"u410a482e\" id=\"u410a482e\" style=\"color: rgb(255, 198, 109)\">Cat</span></strong><span data-lake-id=\"u99bdb6a9\" id=\"u99bdb6a9\">{     </span><strong><span data-lake-id=\"udee50919\" id=\"udee50919\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ua6e11de4\" id=\"ua6e11de4\"> age;     </span><strong><span data-lake-id=\"uaec6d4c2\" id=\"uaec6d4c2\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uad9fc75b\" id=\"uad9fc75b\"> weight;   }   </span><strong><span data-lake-id=\"udb75cbb2\" id=\"udb75cbb2\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u5c88d231\" id=\"u5c88d231\"> </span><strong><span data-lake-id=\"u33364bf8\" id=\"u33364bf8\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"u9dcdae5f\" id=\"u9dcdae5f\"> </span><strong><span data-lake-id=\"ua478154c\" id=\"ua478154c\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"ufa38ee20\" id=\"ufa38ee20\"> </span><strong><span data-lake-id=\"u5f9bcc39\" id=\"u5f9bcc39\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span data-lake-id=\"u8273dc02\" id=\"u8273dc02\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"ue1ed816a\" id=\"ue1ed816a\">{     Cat cat = </span><strong><span data-lake-id=\"uae9fd913\" id=\"uae9fd913\" style=\"color: rgb(194, 98, 48)\">new</span></strong><span data-lake-id=\"u5840542e\" id=\"u5840542e\"> Cat(</span><span data-lake-id=\"u9ffbcf66\" id=\"u9ffbcf66\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u637a0d5a\" id=\"u637a0d5a\">,</span><span data-lake-id=\"uc972c83b\" id=\"uc972c83b\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"u139ff153\" id=\"u139ff153\">);     addAgeAndWeight(cat.age,Cat.weight);   } } </span></p><p data-lake-id=\"u3b76328a\" id=\"u3b76328a\"><span data-lake-id=\"uac25e361\" id=\"uac25e361\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：</span></p><p data-lake-id=\"ub3c94f81\" id=\"ub3c94f81\"><strong><span data-lake-id=\"u04f885be\" id=\"u04f885be\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"u40afa3db\" id=\"u40afa3db\"> </span><strong><span data-lake-id=\"uab0fcc12\" id=\"uab0fcc12\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"ub436051b\" id=\"ub436051b\"> </span><strong><span data-lake-id=\"u4c6396a7\" id=\"u4c6396a7\" style=\"color: rgb(255, 198, 109)\">Example</span></strong><span data-lake-id=\"ub1763b26\" id=\"ub1763b26\">{   </span><span data-lake-id=\"u98878122\" id=\"u98878122\" style=\"color: rgb(155, 133, 157)\">@AllArgsConstructor</span><span data-lake-id=\"ucfbbd955\" id=\"ucfbbd955\">   </span><strong><span data-lake-id=\"ub20302d0\" id=\"ub20302d0\" style=\"color: rgb(194, 98, 48)\">class</span></strong><span data-lake-id=\"uf72229dc\" id=\"uf72229dc\"> </span><strong><span data-lake-id=\"u1f801f00\" id=\"u1f801f00\" style=\"color: rgb(255, 198, 109)\">Cat</span></strong><span data-lake-id=\"u88b0dc36\" id=\"u88b0dc36\">{     </span><strong><span data-lake-id=\"u4a166fc1\" id=\"u4a166fc1\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ubc0459d7\" id=\"ubc0459d7\"> age;     </span><strong><span data-lake-id=\"u592dd106\" id=\"u592dd106\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uc7ea67cd\" id=\"uc7ea67cd\"> weight;   }   </span><strong><span data-lake-id=\"ue76f36ad\" id=\"ue76f36ad\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"uad97550f\" id=\"uad97550f\"> </span><strong><span data-lake-id=\"u3787124b\" id=\"u3787124b\" style=\"color: rgb(194, 98, 48)\">static</span></strong><span data-lake-id=\"uee1acad2\" id=\"uee1acad2\"> </span><strong><span data-lake-id=\"u423dc930\" id=\"u423dc930\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uc92bdbc8\" id=\"uc92bdbc8\"> </span><strong><span data-lake-id=\"u4082419a\" id=\"u4082419a\" style=\"color: rgb(255, 198, 109)\">example</span></strong><span data-lake-id=\"u83e81d41\" id=\"u83e81d41\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u3de2cd34\" id=\"u3de2cd34\">{     </span><strong><span data-lake-id=\"u4cf07b39\" id=\"u4cf07b39\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"ue97dacc2\" id=\"ue97dacc2\"> age = </span><span data-lake-id=\"ub19cf516\" id=\"ub19cf516\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u06938186\" id=\"u06938186\">;     </span><strong><span data-lake-id=\"u63b1902e\" id=\"u63b1902e\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u94bdd122\" id=\"u94bdd122\"> weight = </span><span data-lake-id=\"ua60e8192\" id=\"ua60e8192\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"u8963fbe3\" id=\"u8963fbe3\">;     addAgeAndWeight(age,weight);   } } </span></p><p data-lake-id=\"ufcc36c77\" id=\"ufcc36c77\"><strong><span data-lake-id=\"u7a9c7ff0\" id=\"u7a9c7ff0\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">部分逃逸分析</span></strong></p><p data-lake-id=\"u81b5df62\" id=\"u81b5df62\"><span data-lake-id=\"u8c006892\" id=\"u8c006892\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。</span></p><h3 data-lake-id=\"Kz4q3\" id=\"Kz4q3\"><span data-lake-id=\"ucfa707af\" id=\"ucfa707af\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">4. Loop Transformations</span></h3><p data-lake-id=\"udbc062da\" id=\"udbc062da\"><span data-lake-id=\"ub18b591b\" id=\"ub18b591b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在文章中介绍C2编译器的部分有提及到，C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离。</span></p><p data-lake-id=\"u8f2ac734\" id=\"u8f2ac734\"><strong><span data-lake-id=\"u0e73632c\" id=\"u0e73632c\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">循环展开</span></strong></p><p data-lake-id=\"ue0ff70b0\" id=\"ue0ff70b0\"><span data-lake-id=\"u8847a587\" id=\"u8847a587\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段。</span></p><p data-lake-id=\"uc2822c8e\" id=\"uc2822c8e\"><span data-lake-id=\"u3a3fc7fa\" id=\"u3a3fc7fa\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：</span></p><p data-lake-id=\"u1210203d\" id=\"u1210203d\"><span data-lake-id=\"u1fd2be8b\" id=\"u1fd2be8b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开</span></p><p data-lake-id=\"u051b7df7\" id=\"u051b7df7\"><strong><span data-lake-id=\"uaa99973a\" id=\"uaa99973a\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ua9cd42a9\" id=\"ua9cd42a9\"> </span><strong><span data-lake-id=\"ucd4a16ad\" id=\"ucd4a16ad\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"ud85921c1\" id=\"ud85921c1\"> </span><strong><span data-lake-id=\"ub0744a59\" id=\"ub0744a59\" style=\"color: rgb(255, 198, 109)\">loopRolling</span></strong><span data-lake-id=\"u4bcb0719\" id=\"u4bcb0719\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"uf06709bf\" id=\"uf06709bf\">{   </span><strong><span data-lake-id=\"ucc30070b\" id=\"ucc30070b\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"ubd3569a9\" id=\"ubd3569a9\">(</span><strong><span data-lake-id=\"u2518207d\" id=\"u2518207d\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u36129576\" id=\"u36129576\"> i = </span><span data-lake-id=\"ub59bbe4d\" id=\"ub59bbe4d\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"ufe40351b\" id=\"ufe40351b\">;i&lt;</span><span data-lake-id=\"u36d57676\" id=\"u36d57676\" style=\"color: rgb(165, 194, 97)\">200</span><span data-lake-id=\"u707651c8\" id=\"u707651c8\">;i++){     </span><strong><span data-lake-id=\"uded723bd\" id=\"uded723bd\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"u2706178a\" id=\"u2706178a\">(i);     } } </span></p><p data-lake-id=\"u9642f87d\" id=\"u9642f87d\"><span data-lake-id=\"ub9887997\" id=\"ub9887997\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：</span></p><p data-lake-id=\"ud8ae8594\" id=\"ud8ae8594\"><span data-lake-id=\"u66567615\" id=\"u66567615\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环展开</span></p><p data-lake-id=\"u18a4f41c\" id=\"u18a4f41c\"><strong><span data-lake-id=\"ud951a573\" id=\"ud951a573\" style=\"color: rgb(194, 98, 48)\">public</span></strong><span data-lake-id=\"ud033cf19\" id=\"ud033cf19\"> </span><strong><span data-lake-id=\"u67f4ca32\" id=\"u67f4ca32\" style=\"color: rgb(194, 98, 48)\">void</span></strong><span data-lake-id=\"uf7c88090\" id=\"uf7c88090\"> </span><strong><span data-lake-id=\"ub5aafaa0\" id=\"ub5aafaa0\" style=\"color: rgb(255, 198, 109)\">loopRolling</span></strong><span data-lake-id=\"ue2560370\" id=\"ue2560370\" style=\"color: rgb(208, 208, 255)\">()</span><span data-lake-id=\"u960d80fb\" id=\"u960d80fb\">{   </span><strong><span data-lake-id=\"u362aca55\" id=\"u362aca55\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"u6c3661d6\" id=\"u6c3661d6\">(</span><strong><span data-lake-id=\"u5f229779\" id=\"u5f229779\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"udbbd6021\" id=\"udbbd6021\"> i = </span><span data-lake-id=\"ub7bfddd1\" id=\"ub7bfddd1\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u4885758c\" id=\"u4885758c\">;i&lt;</span><span data-lake-id=\"u7437581b\" id=\"u7437581b\" style=\"color: rgb(165, 194, 97)\">200</span><span data-lake-id=\"u6889c7b2\" id=\"u6889c7b2\">;i+=</span><span data-lake-id=\"uf2df1483\" id=\"uf2df1483\" style=\"color: rgb(165, 194, 97)\">5</span><span data-lake-id=\"ufd762619\" id=\"ufd762619\">){     </span><strong><span data-lake-id=\"u044cb254\" id=\"u044cb254\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"u31fcdbce\" id=\"u31fcdbce\">(i);     </span><strong><span data-lake-id=\"u44aa9205\" id=\"u44aa9205\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"ub57f1d5d\" id=\"ub57f1d5d\">(i+</span><span data-lake-id=\"ub840c627\" id=\"ub840c627\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"uf2e02800\" id=\"uf2e02800\">);     </span><strong><span data-lake-id=\"u0e0bfb8f\" id=\"u0e0bfb8f\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"u62fe2047\" id=\"u62fe2047\">(i+</span><span data-lake-id=\"u89e3cfc1\" id=\"u89e3cfc1\" style=\"color: rgb(165, 194, 97)\">2</span><span data-lake-id=\"u7d8341e5\" id=\"u7d8341e5\">);     </span><strong><span data-lake-id=\"u00578013\" id=\"u00578013\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"ua7bcf15f\" id=\"ua7bcf15f\">(i+</span><span data-lake-id=\"ucb9f4883\" id=\"ucb9f4883\" style=\"color: rgb(165, 194, 97)\">3</span><span data-lake-id=\"uaafbe03e\" id=\"uaafbe03e\">);     </span><strong><span data-lake-id=\"u8935f083\" id=\"u8935f083\" style=\"color: rgb(194, 98, 48)\">delete</span></strong><span data-lake-id=\"u74ba8c74\" id=\"u74ba8c74\">(i+</span><span data-lake-id=\"u334ffbe3\" id=\"u334ffbe3\" style=\"color: rgb(165, 194, 97)\">4</span><span data-lake-id=\"ubf3e8234\" id=\"ubf3e8234\">);   } } </span></p><p data-lake-id=\"u3374ca41\" id=\"u3374ca41\"><span data-lake-id=\"uc18b92ed\" id=\"uc18b92ed\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。</span></p><p data-lake-id=\"u0c53185e\" id=\"u0c53185e\"><strong><span data-lake-id=\"u952d1caf\" id=\"u952d1caf\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">循环分离</span></strong></p><p data-lake-id=\"ub999980d\" id=\"ub999980d\"><span data-lake-id=\"uc2dee36b\" id=\"uc2dee36b\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：</span></p><p data-lake-id=\"u3e518f57\" id=\"u3e518f57\"><span data-lake-id=\"u84c28e7e\" id=\"u84c28e7e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离</span></p><p data-lake-id=\"ubd18aa84\" id=\"ubd18aa84\"><strong><span data-lake-id=\"u711e0b2e\" id=\"u711e0b2e\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"uf800fbfb\" id=\"uf800fbfb\"> a = </span><span data-lake-id=\"ud95b97dd\" id=\"ud95b97dd\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"ufee2d268\" id=\"ufee2d268\">; </span><strong><span data-lake-id=\"u8d46435d\" id=\"u8d46435d\" style=\"color: rgb(194, 98, 48)\">for</span></strong><span data-lake-id=\"uaa4d0258\" id=\"uaa4d0258\">(</span><strong><span data-lake-id=\"u8f9841c9\" id=\"u8f9841c9\" style=\"color: rgb(194, 98, 48)\">int</span></strong><span data-lake-id=\"u27e14e5e\" id=\"u27e14e5e\"> i = </span><span data-lake-id=\"u3af0164a\" id=\"u3af0164a\" style=\"color: rgb(165, 194, 97)\">0</span><span data-lake-id=\"u3a0f5039\" id=\"u3a0f5039\">;i&lt;</span><span data-lake-id=\"u45def615\" id=\"u45def615\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"ub5c26f59\" id=\"ub5c26f59\">;i++){   b[i] = </span><strong><span data-lake-id=\"ua1b44f83\" id=\"ua1b44f83\" style=\"color: rgb(194, 98, 48)\">x</span></strong><span data-lake-id=\"u0007c79a\" id=\"u0007c79a\">[i] + </span><strong><span data-lake-id=\"uabb5b5e0\" id=\"uabb5b5e0\" style=\"color: rgb(194, 98, 48)\">x</span></strong><span data-lake-id=\"uc381841b\" id=\"uc381841b\">[a];   a = i; } </span></p><p data-lake-id=\"u19c23aad\" id=\"u19c23aad\"><span data-lake-id=\"uf5cc3ce4\" id=\"uf5cc3ce4\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码：</span></p><p data-lake-id=\"ue547f2b2\" id=\"ue547f2b2\"><span data-lake-id=\"u4976b68e\" id=\"u4976b68e\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">循环分离</span></p><p data-lake-id=\"u29e53f6f\" id=\"u29e53f6f\"><span data-lake-id=\"u5999ba2d\" id=\"u5999ba2d\">b</span><span data-lake-id=\"uc9279312\" id=\"uc9279312\" style=\"color: rgb(165, 194, 97)\">[0]</span><span data-lake-id=\"ua53d8c20\" id=\"ua53d8c20\"> = x</span><span data-lake-id=\"u545fb40d\" id=\"u545fb40d\" style=\"color: rgb(165, 194, 97)\">[0]</span><span data-lake-id=\"u2dc2a0e4\" id=\"u2dc2a0e4\"> + </span><span data-lake-id=\"udf9cf3a7\" id=\"udf9cf3a7\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"udd4c9f24\" id=\"udd4c9f24\">; for(int i = </span><span data-lake-id=\"uea2acca1\" id=\"uea2acca1\" style=\"color: rgb(165, 194, 97)\">1</span><span data-lake-id=\"u286834ef\" id=\"u286834ef\">;i&lt;</span><span data-lake-id=\"ud0d82023\" id=\"ud0d82023\" style=\"color: rgb(165, 194, 97)\">10</span><span data-lake-id=\"ue8b4cfd5\" id=\"ue8b4cfd5\">;i++){   b</span><span data-lake-id=\"u02aa94cc\" id=\"u02aa94cc\" style=\"color: rgb(165, 194, 97)\">[i]</span><span data-lake-id=\"u465753e9\" id=\"u465753e9\"> = x</span><span data-lake-id=\"uba96e9e2\" id=\"uba96e9e2\" style=\"color: rgb(165, 194, 97)\">[i]</span><span data-lake-id=\"uecabdf3e\" id=\"uecabdf3e\"> + x</span><span data-lake-id=\"uda6de084\" id=\"uda6de084\" style=\"color: rgb(165, 194, 97)\">[i-1]</span><span data-lake-id=\"u2341a141\" id=\"u2341a141\">; } </span></p><p data-lake-id=\"u553c2724\" id=\"u553c2724\"><span data-lake-id=\"u1c10bfb2\" id=\"u1c10bfb2\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。</span></p><h3 data-lake-id=\"ynalx\" id=\"ynalx\"><span data-lake-id=\"u2bdd0245\" id=\"u2bdd0245\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">5. 窥孔优化与寄存器分配</span></h3><p data-lake-id=\"ua7c22582\" id=\"ua7c22582\"><span data-lake-id=\"u09a0b8d0\" id=\"u09a0b8d0\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提到的窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：</span></p><p data-lake-id=\"ubc64dea7\" id=\"ubc64dea7\"><span data-lake-id=\"ufc546382\" id=\"ufc546382\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">强度削减</span></p><p data-lake-id=\"ucacd35d6\" id=\"ucacd35d6\"><span data-lake-id=\"u1922e621\" id=\"u1922e621\">y1=x1*3  经过强度削减后得到  y1=(x1&lt;&lt;1)+x1 </span></p><p data-lake-id=\"ube41c3ea\" id=\"ube41c3ea\"><span data-lake-id=\"udff6a96d\" id=\"udff6a96d\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。</span></p><p data-lake-id=\"u42c78f5c\" id=\"u42c78f5c\"><span data-lake-id=\"u73c368db\" id=\"u73c368db\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。</span></p><p data-lake-id=\"ub13c94b4\" id=\"ub13c94b4\"><span data-lake-id=\"uaea66a45\" id=\"uaea66a45\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。</span></p><h2 data-lake-id=\"ZSShZ\" id=\"ZSShZ\"><span data-lake-id=\"ud6a4b28a\" id=\"ud6a4b28a\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">四、实践</span></h2><p data-lake-id=\"u69ce8478\" id=\"u69ce8478\"><span data-lake-id=\"ud48ff173\" id=\"ud48ff173\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">即时编译器情况复杂，同时网络上也很少有实战经验，以下是我们团队的一些调整经验。</span></p><h3 data-lake-id=\"SHpjP\" id=\"SHpjP\"><span data-lake-id=\"ufbfcce82\" id=\"ufbfcce82\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">1. 编译相关的重* 要参数</span></h3><ul list=\"ub061ddee\"><li fid=\"u527521e3\" data-lake-id=\"uc435efd1\" id=\"uc435efd1\"><span data-lake-id=\"u842251c8\" id=\"u842251c8\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:+TieredCompilation：开启分层编译，JDK8之后默认开启</span></li><li fid=\"u527521e3\" data-lake-id=\"ub2e5b875\" id=\"ub2e5b875\"><span data-lake-id=\"u983d7032\" id=\"u983d7032\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:+CICompilerCount=N：编译线程数，设置数量后，JVM会自动分配线程数，C1:C2 = 1:2</span></li><li fid=\"u527521e3\" data-lake-id=\"uec84e4b2\" id=\"uec84e4b2\"><span data-lake-id=\"u6ebf6d9c\" id=\"u6ebf6d9c\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXBackEdgeThreshold：OSR编译的阈值</span></li><li fid=\"u527521e3\" data-lake-id=\"uede9afc6\" id=\"uede9afc6\"><span data-lake-id=\"u7b3c4e01\" id=\"u7b3c4e01\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXMinInvocationThreshold：开启分层编译后各层调用的阈值</span></li><li fid=\"u527521e3\" data-lake-id=\"ua04d67fe\" id=\"ua04d67fe\"><span data-lake-id=\"u22239701\" id=\"u22239701\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXCompileThreshold：开启分层编译后的编译阈值</span></li><li fid=\"u527521e3\" data-lake-id=\"u70d1c5e4\" id=\"u70d1c5e4\"><span data-lake-id=\"u7de8163a\" id=\"u7de8163a\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:ReservedCodeCacheSize：codeCache最大大小</span></li><li fid=\"u527521e3\" data-lake-id=\"u6a743eef\" id=\"u6a743eef\"><span data-lake-id=\"u1ac9a1ea\" id=\"u1ac9a1ea\" class=\"lake-fontsize-9\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:InitialCodeCacheSize：codeCache初始大小</span></li></ul><p data-lake-id=\"u7314e4cf\" id=\"u7314e4cf\"><span data-lake-id=\"u6f277364\" id=\"u6f277364\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">-XX:TierXMinInvocationThreshold是开启分层编译的情况下，触发编译的阈值参数，当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。分层编译开启下会乘以一个系数，系数根据当前编译的方法和编译线程数确定，降低阈值可以提升编译方法数，一些常用但是不能编译的方法可以编译优化提升性能。</span></p><p data-lake-id=\"uaf052c6c\" id=\"uaf052c6c\"><span data-lake-id=\"uc2cc0894\" id=\"uc2cc0894\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于编译情况复杂，JVM也会动态调整相关的阈值来保证JVM的性能，所以不建议手动调整编译相关的参数。除非一些特定的Case，比如codeCache满了停止了编译，可以适当增加codeCache大小，或者一些非常常用的方法，未被内联到，拖累了性能，可以调整内敛层数或者内联方法的大小来解决。</span></p><h3 data-lake-id=\"tIo0Z\" id=\"tIo0Z\"><span data-lake-id=\"u36f83707\" id=\"u36f83707\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">2. 通过JITwatch分析编译日志</span></h3><p data-lake-id=\"ufec14627\" id=\"ufec14627\"><span data-lake-id=\"u702909cb\" id=\"u702909cb\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">通过增加-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining -XX:+PrintCodeCache -XX:+PrintCodeCacheOnCompilation -XX:+TraceClassLoading -XX:+LogCompilation -XX:LogFile=LogPath参数可以输出编译、内联、codeCache信息到文件。但是打印的编译日志多且复杂很难直接从其中得到信息，可以使用JITwatch的工具来分析编译日志。JITwatch首页的Open Log选中日志文件，点击Start就可以开始分析日志。</span></p><p data-lake-id=\"u8ea668ce\" id=\"u8ea668ce\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22uf9965c46-f8b5-4790-8c43-2496a253499%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22uc066bc4c%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22ub1b1c82e-1bc2-4461-92ce-52cded1cb4f%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u92756ac9%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u6710110f\" id=\"u6710110f\"><span data-lake-id=\"u5e365894\" id=\"u5e365894\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">如上图所示，区域1中是整个项目Java Class包括引入的第三方依赖；区域2是功能区Timeline以图形的形式展示JIT编译的时间轴，Histo是直方图展示一些信息，TopList里面是编译中产生的一些对象和数据的排序，Cache是空闲codeCache空间，NMethod是Native方法，Threads是JIT编译的线程；区域3是JITwatch对日志分析结果的展示，其中Suggestions中会给出一些代码优化的建议，举个例子，如下图中：</span></p><p data-lake-id=\"u7347bdbc\" id=\"u7347bdbc\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3Anull%2C%22taskId%22%3A%22u466030eb-aa84-431b-afe7-39db9258d0d%22%2C%22clientId%22%3A%22uda87cb41-0cb8-4%22%2C%22originalType%22%3A%22url%22%2C%22linkTarget%22%3A%22_blank%22%2C%22from%22%3A%22paste%22%2C%22ratio%22%3A1%2C%22status%22%3A%22error%22%2C%22style%22%3A%22none%22%2C%22errorMessage%22%3A%22picture%20dump%20failure%22%2C%22id%22%3A%22u036811d2%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card></p><p data-lake-id=\"u3751b3a7\" id=\"u3751b3a7\"><span data-lake-id=\"u7a308ab1\" id=\"u7a308ab1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">我们可以看到在调用ZipInputStream的read方法时，因为该方法没有被标记为热点方法，同时又“太大了”，导致无法被内联到。使用-XX:CompileCommand中inline指令可以强制方法进行内联，不过还是建议谨慎使用，除非确定某个方法内联会带来不少的性能提升，否则不建议使用，并且过多使用对编译线程和codeCache都会带来不小的压力。</span></p><p data-lake-id=\"u086efc56\" id=\"u086efc56\"><span data-lake-id=\"u029e8761\" id=\"u029e8761\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">区域3中的-Allocs和-Locks逃逸分析后JVM对代码做的优化，包括栈上分配、锁消除等。</span></p><h3 data-lake-id=\"aBz3d\" id=\"aBz3d\"><span data-lake-id=\"udd5b89ed\" id=\"udd5b89ed\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">3. 使用Graal编译器</span></h3><p data-lake-id=\"u50282e4f\" id=\"u50282e4f\"><span data-lake-id=\"ub5fffc56\" id=\"ub5fffc56\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">由于JVM会去根据当前的编译方法数和编译线程数对编译阈值进行动态的调整，所以实际服务中对这一部分的调整空间是不大的，JVM做的已经足够多了。</span></p><p data-lake-id=\"uc836cb46\" id=\"uc836cb46\"><span data-lake-id=\"u6c876040\" id=\"u6c876040\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">为了提升性能，在服务中尝试了最新的Graal编译器。只需要使用-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler就可以启动Graal编译器来代替C2编译器，并且响应C2的编译请求，不过要注意的是，Graal编译器与ZGC不兼容，只能与G1搭配使用。</span></p><p data-lake-id=\"u836e833d\" id=\"u836e833d\"><span data-lake-id=\"uc09448f7\" id=\"uc09448f7\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文有提到过，Graal是一个用Java写的即时编译器，它从Java 9开始便被集成自JDK中，作为实验性质的即时编译器。Graal编译器就是脱身于GraalVM，GraalVM是一个高性能的、支持多种编程语言的执行环境。它既可以在传统的 OpenJDK上运行，也可以通过AOT（Ahead-Of-Time）编译成可执行文件单独运行，甚至可以集成至数据库中运行。</span></p><p data-lake-id=\"ud55d64c2\" id=\"ud55d64c2\"><span data-lake-id=\"u871a9054\" id=\"u871a9054\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">前文提到过数次，Graal的优化都基于某种假设（Assumption）。当假设出错的情况下，Java虚拟机会借助去优化（Deoptimization）这项机制，从执行即时编译器生成的机器码切换回解释执行，在必要情况下，它甚至会废弃这份机器码，并在重新收集程序profile之后，再进行编译。</span></p><p data-lake-id=\"u5ca3f3ab\" id=\"u5ca3f3ab\"><span data-lake-id=\"u57536db8\" id=\"u57536db8\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">这些中激进的手段使得Graal的峰值性能要好于C2，而且在Scale、Ruby这种语言Graal表现更加出色，Twitter目前已经在服务中大量的使用Graal来提升性能，企业版的GraalVM使得Twitter服务性能提升了22%。</span></p><p data-lake-id=\"u151f8046\" id=\"u151f8046\"><strong><span data-lake-id=\"u5c36116b\" id=\"u5c36116b\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">使用Graal编译器后性能表现</span></strong></p><p data-lake-id=\"ub6741c38\" id=\"ub6741c38\"><span data-lake-id=\"ud05ca2ca\" id=\"ud05ca2ca\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">在我们的线上服务中，启用Graal编译后，TP9999从60ms -&gt; 50ms ，下降10ms，下降幅度达16.7%。</span></p><p data-lake-id=\"u8496a364\" id=\"u8496a364\"><span data-lake-id=\"ub2107d01\" id=\"ub2107d01\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">运行过程中的峰值性能会更高。可以看出对于该服务，Graal编译器带来了一定的性能提升。</span></p><p data-lake-id=\"ue314a011\" id=\"ue314a011\"><strong><span data-lake-id=\"u8811d122\" id=\"u8811d122\" style=\"color: rgb(0, 0, 0); background-color: rgb(253, 253, 253)\">Graal编译器的问题</span></strong></p><p data-lake-id=\"uac6600aa\" id=\"uac6600aa\"><span data-lake-id=\"ue08faad1\" id=\"ue08faad1\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">Graal编译器的优化方式更加激进，因此在启动时会进行更多的编译，Graal编译器本身也需要被即时编译，所以服务刚启动时性能会比较差。</span></p><p data-lake-id=\"uf8a76620\" id=\"uf8a76620\"><span data-lake-id=\"u1eab0bd2\" id=\"u1eab0bd2\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">考虑的解决办法：JDK 9开始提供工具jaotc，同时GraalVM的Native Image都是可以通过静态编译，极大地提升服务的启动速度的方式，但是GraalVM会使用自己的垃圾回收，这是一种很原始的基于复制算法的垃圾回收，相比G1、ZGC这些优秀的新型垃圾回收器，它的性能并不好。同时GraalVM对Java的一些特性支持也不够，比如基于配置的支持，比如反射就需要把所有需要反射的类配置一个JSON文件，在大量使用反射的服务，这样的配置会是很大的工作量。我们也在做这方面的调研。</span></p><h2 data-lake-id=\"KwkdK\" id=\"KwkdK\"><span data-lake-id=\"u177616be\" id=\"u177616be\" style=\"color: rgb(42, 41, 53); background-color: rgb(253, 253, 253)\">五、总结</span></h2><p data-lake-id=\"u281a9968\" id=\"u281a9968\"><span data-lake-id=\"u5639cc38\" id=\"u5639cc38\" style=\"color: rgb(51, 51, 51); background-color: rgb(253, 253, 253)\">本文主要介绍了JIT即时编译的原理以及在美团一些实践的经验，还有最前沿的即时编译器的使用效果。作为一项解释型语言中提升性能的技术，JIT已经比较成熟了，在很多语言中都有使用。对于Java服务，JVM本身已经做了足够多，但是我们还应该不断深入了解JIT的优化原理和最新的编译技术，从而弥补JIT的劣势，提升Java服务的性能，不断追求卓越。</span></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-09-26T03:41:04.000Z",
    "deleted_at": null,
    "created_at": "2021-09-26T03:40:38.000Z",
    "updated_at": "2021-11-16T06:52:06.000Z",
    "published_at": "2021-09-26T03:41:04.000Z",
    "first_published_at": "2021-09-26T03:41:04.000Z",
    "word_count": 12020,
    "cover": null,
    "description": "一、导读常见的编译型语言如C++，通常会把代码直接编译成CPU所能理解的机器码来运行。而Java为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由javac编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java通常不如C++...",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 54035878,
    "slug": "gs6s32",
    "title": "data",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "2   查cpu升高的问题<br />2、在Cacheable的使用过程中，一定要注意同个cacheName中key值相同的可能覆盖的问题。\n",
    "body_draft": "2   查cpu升高的问题<br />2、在Cacheable的使用过程中，一定要注意同个cacheName中key值相同的可能覆盖的问题。\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u680f27c5\" class=\"ne-p\"><span class=\"ne-text\">2   查cpu升高的问题</span></p><p id=\"u0e4a1b53\" class=\"ne-p\"><span class=\"ne-text\">2、在Cacheable的使用过程中，一定要注意同个cacheName中key值相同的可能覆盖的问题。</span></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u680f27c5\" id=\"u680f27c5\"><span data-lake-id=\"u4dda7702\" id=\"u4dda7702\">2   查cpu升高的问题</span></p><p data-lake-id=\"u0e4a1b53\" id=\"u0e4a1b53\"><span data-lake-id=\"u333d0549\" id=\"u333d0549\">2、在Cacheable的使用过程中，一定要注意同个cacheName中key值相同的可能覆盖的问题。</span></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u680f27c5\" id=\"u680f27c5\"><span data-lake-id=\"u4dda7702\" id=\"u4dda7702\">2   查cpu升高的问题</span></p><p data-lake-id=\"u0e4a1b53\" id=\"u0e4a1b53\"><span data-lake-id=\"u333d0549\" id=\"u333d0549\">2、在Cacheable的使用过程中，一定要注意同个cacheName中key值相同的可能覆盖的问题。</span></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-09-24T06:27:47.000Z",
    "deleted_at": null,
    "created_at": "2021-09-24T06:26:55.000Z",
    "updated_at": "2021-11-16T06:52:06.000Z",
    "published_at": "2021-09-24T06:27:47.000Z",
    "first_published_at": "2021-09-24T06:27:47.000Z",
    "word_count": 41,
    "cover": null,
    "description": "2   查cpu升高的问题2、在Cacheable的使用过程中，一定要注意同个cacheName中key值相同的可能覆盖的问题。",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 54034174,
    "slug": "ogd5iu",
    "title": "java启动性能优化",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "JIT的Profile神器JITWatch <br />[https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ](https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ)<br />​\n\n作者：kelthuzadx<br />链接：https://www.zhihu.com/question/478887438/answer/2054092011<br />来源：知乎<br />著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\nAOT编译即jaotc，可以将Java代码编成二进制，然后虚拟机直接用这些二进制，而不是在运行时花费时间用JIT编译。JDK10还尝试使用AOT背后的Graal代替HotSpot VM原有的C2 JIT编译器。但是它们两个的探索不算成功，首先用的不多，成功实践不多，关于这点可以问问自己有没有听过或者实际用过jaotc或者Graal JIT。<br />其次Graal主要是Oracle Labs那边做开发，他们有一个[仓库](https://link.zhihu.com/?target=https%3A//github.com/oracle/graal)，相当于它们是JDK里面的Graal和AOT的上游，但是它们在JDK中的测试挂了没人修，也不太活跃，对JDK的代码演进会照成一定的困扰（小道消息可能还有派系斗争。。），基于总总原因，OpenJDK社区决定在JDK17中移除它们，由Oracle Labs在独立的仓库中维护。所以，**OpenJDK社区确实已经彻底放弃基于Graal的AOT了，**但是彻底放弃AOT这个技术本身也不一定，没准哪天就有个基于C2的AOT呢：P.<br />是不是听起来感觉还有救？反正还有Oracle Labs仓库的继续维护，不慌。<br />相关用户还是要慌一下，因为Oracle Labs也在它们的主线上[移除了AOT](https://link.zhihu.com/?target=https%3A//github.com/oracle/graal/commit/2850e2ea3d47f0ac81a740f4ac48bf0e27135a11)，我们未来可能要永远告别jaotc了。至于Graal短时间内肯定还是有的，因为它是GraalVM安身立命的基础。<br />但是对于函数计算、Serverless甚至更广阔的应用场景，快速启动、内存低占用这些仍然是刚需，我们仍然需要解决。<br />---- 探索1<br />很多应用启动性能Profiling显示JVM启动慢的主要原因是类的**加载-链接-初始化**这一套，它们占据了启动的绝大部分时间，JVM本身的启动是非常快的（-Xlog:startuptime)。对于类的三部曲，一个解决方案是[AppCDS](https://link.zhihu.com/?target=http%3A//openjdk.java.net/jeps/310)技术，OpenJDK对它做了很多工作，阿里JDK也对快速启动和AppCDS做了大量改造（[所以，亲，看机会吗？](https://zhuanlan.zhihu.com/p/392773209)）<br />回到技术本身。JVM之所以要加载-链接-初始化一个类，目的是让用户写的一个类Foo，在虚拟机里面能有个数据结构（即InstanceKlass）对应，这样虚拟机就可以通过它知道Foo实现了哪些接口，父类是谁等等。那么只要Foo类的字节码没有变过，我们跑多次应用，最终JVM里面的InstanceKlass就可以是一样的。这就是AppCDS的洞察，它可以让应用先 模拟 跑一次，把JVM里面已经走过加载-链接-初始化流程的InstanceKlass都存放到App.jsa文件里面，第二次 实际 运行时直接使用读App.jsa，拿到已经准备就绪的InstanceKlass直接用，省去了加载-链接的开销。<br />---- 探索2<br />注意AppCDS不能跳过初始化这个过程，这个过程需要另一项依赖AppCDS和G1的技术，即Pre-initialization提前初始化来部分解决。Pre-initialization是比较前沿的技术，也处于探索期间，最新的工作可以使这个技术适用于非G1的垃圾回收器。<br />OpenJDK还针对AppCDS做了非常多的工作，比如DynamicAppCDS、AppCDS for Lambda/Proxy Classes，就不展开了。<br />----探索3<br />除了VM上面做功夫之外，Linux CRIU技术也不容忽视。CRIU的介绍我就贴一点官网的：CRIU可以冻结运行中的容器或者某个单独的应用，然后把它的状态保存到磁盘上， 然后下次运行时读取磁盘的数据恢复执行。**理想情况下，**应用程序是无感知的，它不知道被暂停过。<br />OpenJDK也在积极探索，前一段时间Azul的一位开发者（为macOS M1提供JDK的那个男人）提议成立[CRaC项目](https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/discuss/2021-July/005862.html)（JDK中需要花费大量努力的方向或者技术探索都会创建一个项目，而不是在主线，比如ZGC，VectorAPI，Valhalla），这个技术旨在探索如何让CRIU和JVM更好的协作。该项目目前还在广泛讨(che)论(pi)，参与者至少包括RedHat，Amazon，Azul。对于开发者，等就完事了。<br />----探索4<br />再补充一点。<br />OpenJDK还有一个[Leyden项目](https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/announce/2020-May/000289.html)，探索static-image技术，目标也是为了解决上面我们提到的Java启动慢、内存高占用等问题。<br />那么static-image又是啥呢？假如有个void foo()方法，用传统的AOT如jatoc，会把foo编译成二进制，而static-image会把foo编译成二进制，**同时**再带上语言运行时（比如GC、线程模型等），最终得到一个“**闭合的二进制世界**”。static-image其实就是更广义的AOT。<br />所以不要悲观，OpenJDK和GraalVM虽然都废弃了传统的AOT编译，但是两者都**不约而同**的探索static-image技术，OpenJDK这边是Leyden，GraalVM那边是[SubstrateVM](https://www.zhihu.com/question/274042223/answer/1270829173)。不过我得吐槽一下。。Leyden雷声大雨点小，截至目前(2021.8.12)还没有实际的动静，GraalVM那边的SubstrateVM倒是做的风生水起。\n",
    "body_draft": "JIT的Profile神器JITWatch <br />[https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ](https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ)<br />​\n\n作者：kelthuzadx<br />链接：https://www.zhihu.com/question/478887438/answer/2054092011<br />来源：知乎<br />著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\nAOT编译即jaotc，可以将Java代码编成二进制，然后虚拟机直接用这些二进制，而不是在运行时花费时间用JIT编译。JDK10还尝试使用AOT背后的Graal代替HotSpot VM原有的C2 JIT编译器。但是它们两个的探索不算成功，首先用的不多，成功实践不多，关于这点可以问问自己有没有听过或者实际用过jaotc或者Graal JIT。<br />其次Graal主要是Oracle Labs那边做开发，他们有一个[仓库](https://link.zhihu.com/?target=https%3A//github.com/oracle/graal)，相当于它们是JDK里面的Graal和AOT的上游，但是它们在JDK中的测试挂了没人修，也不太活跃，对JDK的代码演进会照成一定的困扰（小道消息可能还有派系斗争。。），基于总总原因，OpenJDK社区决定在JDK17中移除它们，由Oracle Labs在独立的仓库中维护。所以，**OpenJDK社区确实已经彻底放弃基于Graal的AOT了，**但是彻底放弃AOT这个技术本身也不一定，没准哪天就有个基于C2的AOT呢：P.<br />是不是听起来感觉还有救？反正还有Oracle Labs仓库的继续维护，不慌。<br />相关用户还是要慌一下，因为Oracle Labs也在它们的主线上[移除了AOT](https://link.zhihu.com/?target=https%3A//github.com/oracle/graal/commit/2850e2ea3d47f0ac81a740f4ac48bf0e27135a11)，我们未来可能要永远告别jaotc了。至于Graal短时间内肯定还是有的，因为它是GraalVM安身立命的基础。<br />但是对于函数计算、Serverless甚至更广阔的应用场景，快速启动、内存低占用这些仍然是刚需，我们仍然需要解决。<br />---- 探索1<br />很多应用启动性能Profiling显示JVM启动慢的主要原因是类的**加载-链接-初始化**这一套，它们占据了启动的绝大部分时间，JVM本身的启动是非常快的（-Xlog:startuptime)。对于类的三部曲，一个解决方案是[AppCDS](https://link.zhihu.com/?target=http%3A//openjdk.java.net/jeps/310)技术，OpenJDK对它做了很多工作，阿里JDK也对快速启动和AppCDS做了大量改造（[所以，亲，看机会吗？](https://zhuanlan.zhihu.com/p/392773209)）<br />回到技术本身。JVM之所以要加载-链接-初始化一个类，目的是让用户写的一个类Foo，在虚拟机里面能有个数据结构（即InstanceKlass）对应，这样虚拟机就可以通过它知道Foo实现了哪些接口，父类是谁等等。那么只要Foo类的字节码没有变过，我们跑多次应用，最终JVM里面的InstanceKlass就可以是一样的。这就是AppCDS的洞察，它可以让应用先 模拟 跑一次，把JVM里面已经走过加载-链接-初始化流程的InstanceKlass都存放到App.jsa文件里面，第二次 实际 运行时直接使用读App.jsa，拿到已经准备就绪的InstanceKlass直接用，省去了加载-链接的开销。<br />---- 探索2<br />注意AppCDS不能跳过初始化这个过程，这个过程需要另一项依赖AppCDS和G1的技术，即Pre-initialization提前初始化来部分解决。Pre-initialization是比较前沿的技术，也处于探索期间，最新的工作可以使这个技术适用于非G1的垃圾回收器。<br />OpenJDK还针对AppCDS做了非常多的工作，比如DynamicAppCDS、AppCDS for Lambda/Proxy Classes，就不展开了。<br />----探索3<br />除了VM上面做功夫之外，Linux CRIU技术也不容忽视。CRIU的介绍我就贴一点官网的：CRIU可以冻结运行中的容器或者某个单独的应用，然后把它的状态保存到磁盘上， 然后下次运行时读取磁盘的数据恢复执行。**理想情况下，**应用程序是无感知的，它不知道被暂停过。<br />OpenJDK也在积极探索，前一段时间Azul的一位开发者（为macOS M1提供JDK的那个男人）提议成立[CRaC项目](https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/discuss/2021-July/005862.html)（JDK中需要花费大量努力的方向或者技术探索都会创建一个项目，而不是在主线，比如ZGC，VectorAPI，Valhalla），这个技术旨在探索如何让CRIU和JVM更好的协作。该项目目前还在广泛讨(che)论(pi)，参与者至少包括RedHat，Amazon，Azul。对于开发者，等就完事了。<br />----探索4<br />再补充一点。<br />OpenJDK还有一个[Leyden项目](https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/announce/2020-May/000289.html)，探索static-image技术，目标也是为了解决上面我们提到的Java启动慢、内存高占用等问题。<br />那么static-image又是啥呢？假如有个void foo()方法，用传统的AOT如jatoc，会把foo编译成二进制，而static-image会把foo编译成二进制，**同时**再带上语言运行时（比如GC、线程模型等），最终得到一个“**闭合的二进制世界**”。static-image其实就是更广义的AOT。<br />所以不要悲观，OpenJDK和GraalVM虽然都废弃了传统的AOT编译，但是两者都**不约而同**的探索static-image技术，OpenJDK这边是Leyden，GraalVM那边是[SubstrateVM](https://www.zhihu.com/question/274042223/answer/1270829173)。不过我得吐槽一下。。Leyden雷声大雨点小，截至目前(2021.8.12)还没有实际的动静，GraalVM那边的SubstrateVM倒是做的风生水起。\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u86442191\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 22px; color: rgb(51, 51, 51)\">JIT的Profile神器JITWatch </span></p><p id=\"u3adc20a2\" class=\"ne-p\"><a href=\"https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ\" data-href=\"https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ</span></a></p><p id=\"u319a547c\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 22px; color: rgb(51, 51, 51)\"></span></p><p id=\"u11c8637c\" class=\"ne-p\"><span class=\"ne-text\">作者：kelthuzadx<br /></span><span class=\"ne-text\">链接：https://www.zhihu.com/question/478887438/answer/2054092011<br /></span><span class=\"ne-text\">来源：知乎<br /></span><span class=\"ne-text\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br /><br /></span></p><p id=\"u040401ce\" class=\"ne-p\"><span class=\"ne-text\">AOT编译即jaotc，可以将Java代码编成二进制，然后虚拟机直接用这些二进制，而不是在运行时花费时间用JIT编译。JDK10还尝试使用AOT背后的Graal代替HotSpot VM原有的C2 JIT编译器。但是它们两个的探索不算成功，首先用的不多，成功实践不多，关于这点可以问问自己有没有听过或者实际用过jaotc或者Graal JIT。</span></p><p id=\"ua9a700ce\" class=\"ne-p\"><span class=\"ne-text\">其次Graal主要是Oracle Labs那边做开发，他们有一个</span><a href=\"https://link.zhihu.com/?target=https%3A//github.com/oracle/graal\" data-href=\"https://link.zhihu.com/?target=https%3A//github.com/oracle/graal\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">仓库</span></a><span class=\"ne-text\">，相当于它们是JDK里面的Graal和AOT的上游，但是它们在JDK中的测试挂了没人修，也不太活跃，对JDK的代码演进会照成一定的困扰（小道消息可能还有派系斗争。。），基于总总原因，OpenJDK社区决定在JDK17中移除它们，由Oracle Labs在独立的仓库中维护。所以，</span><strong><span class=\"ne-text\">OpenJDK社区确实已经彻底放弃基于Graal的AOT了，</span></strong><span class=\"ne-text\">但是彻底放弃AOT这个技术本身也不一定，没准哪天就有个基于C2的AOT呢：P.</span></p><p id=\"u903d31ab\" class=\"ne-p\"><span class=\"ne-text\">是不是听起来感觉还有救？反正还有Oracle Labs仓库的继续维护，不慌。</span></p><p id=\"u7643e46f\" class=\"ne-p\"><span class=\"ne-text\">相关用户还是要慌一下，因为Oracle Labs也在它们的主线上</span><a href=\"https://link.zhihu.com/?target=https%3A//github.com/oracle/graal/commit/2850e2ea3d47f0ac81a740f4ac48bf0e27135a11\" data-href=\"https://link.zhihu.com/?target=https%3A//github.com/oracle/graal/commit/2850e2ea3d47f0ac81a740f4ac48bf0e27135a11\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">移除了AOT</span></a><span class=\"ne-text\">，我们未来可能要永远告别jaotc了。至于Graal短时间内肯定还是有的，因为它是GraalVM安身立命的基础。</span></p><p id=\"u15e87a0d\" class=\"ne-p\"><span class=\"ne-text\">但是对于函数计算、Serverless甚至更广阔的应用场景，快速启动、内存低占用这些仍然是刚需，我们仍然需要解决。</span></p><p id=\"ud8af010b\" class=\"ne-p\"><span class=\"ne-text\">---- 探索1</span></p><p id=\"ua3798413\" class=\"ne-p\"><span class=\"ne-text\">很多应用启动性能Profiling显示JVM启动慢的主要原因是类的</span><strong><span class=\"ne-text\">加载-链接-初始化</span></strong><span class=\"ne-text\">这一套，它们占据了启动的绝大部分时间，JVM本身的启动是非常快的（-Xlog:startuptime)。对于类的三部曲，一个解决方案是</span><a href=\"https://link.zhihu.com/?target=http%3A//openjdk.java.net/jeps/310\" data-href=\"https://link.zhihu.com/?target=http%3A//openjdk.java.net/jeps/310\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">AppCDS</span></a><span class=\"ne-text\">技术，OpenJDK对它做了很多工作，阿里JDK也对快速启动和AppCDS做了大量改造（</span><a href=\"https://zhuanlan.zhihu.com/p/392773209\" data-href=\"https://zhuanlan.zhihu.com/p/392773209\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">所以，亲，看机会吗？</span></a><span class=\"ne-text\">）</span></p><p id=\"uf8e0a294\" class=\"ne-p\"><span class=\"ne-text\">回到技术本身。JVM之所以要加载-链接-初始化一个类，目的是让用户写的一个类Foo，在虚拟机里面能有个数据结构（即InstanceKlass）对应，这样虚拟机就可以通过它知道Foo实现了哪些接口，父类是谁等等。那么只要Foo类的字节码没有变过，我们跑多次应用，最终JVM里面的InstanceKlass就可以是一样的。这就是AppCDS的洞察，它可以让应用先 模拟 跑一次，把JVM里面已经走过加载-链接-初始化流程的InstanceKlass都存放到App.jsa文件里面，第二次 实际 运行时直接使用读App.jsa，拿到已经准备就绪的InstanceKlass直接用，省去了加载-链接的开销。</span></p><p id=\"ue2df4451\" class=\"ne-p\"><span class=\"ne-text\">---- 探索2</span></p><p id=\"uc3210ca7\" class=\"ne-p\"><span class=\"ne-text\">注意AppCDS不能跳过初始化这个过程，这个过程需要另一项依赖AppCDS和G1的技术，即Pre-initialization提前初始化来部分解决。Pre-initialization是比较前沿的技术，也处于探索期间，最新的工作可以使这个技术适用于非G1的垃圾回收器。</span></p><p id=\"u156667e1\" class=\"ne-p\"><span class=\"ne-text\">OpenJDK还针对AppCDS做了非常多的工作，比如DynamicAppCDS、AppCDS for Lambda/Proxy Classes，就不展开了。</span></p><p id=\"u3d0b24e3\" class=\"ne-p\"><span class=\"ne-text\">----探索3</span></p><p id=\"u8d130106\" class=\"ne-p\"><span class=\"ne-text\">除了VM上面做功夫之外，Linux CRIU技术也不容忽视。CRIU的介绍我就贴一点官网的：CRIU可以冻结运行中的容器或者某个单独的应用，然后把它的状态保存到磁盘上， 然后下次运行时读取磁盘的数据恢复执行。</span><strong><span class=\"ne-text\">理想情况下，</span></strong><span class=\"ne-text\">应用程序是无感知的，它不知道被暂停过。</span></p><p id=\"u68594828\" class=\"ne-p\"><span class=\"ne-text\">OpenJDK也在积极探索，前一段时间Azul的一位开发者（为macOS M1提供JDK的那个男人）提议成立</span><a href=\"https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/discuss/2021-July/005862.html\" data-href=\"https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/discuss/2021-July/005862.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">CRaC项目</span></a><span class=\"ne-text\">（JDK中需要花费大量努力的方向或者技术探索都会创建一个项目，而不是在主线，比如ZGC，VectorAPI，Valhalla），这个技术旨在探索如何让CRIU和JVM更好的协作。该项目目前还在广泛讨(che)论(pi)，参与者至少包括RedHat，Amazon，Azul。对于开发者，等就完事了。</span></p><p id=\"u4703f68a\" class=\"ne-p\"><span class=\"ne-text\">----探索4</span></p><p id=\"u3e044c7a\" class=\"ne-p\"><span class=\"ne-text\">再补充一点。</span></p><p id=\"uf410604a\" class=\"ne-p\"><span class=\"ne-text\">OpenJDK还有一个</span><a href=\"https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/announce/2020-May/000289.html\" data-href=\"https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/announce/2020-May/000289.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">Leyden项目</span></a><span class=\"ne-text\">，探索static-image技术，目标也是为了解决上面我们提到的Java启动慢、内存高占用等问题。</span></p><p id=\"uf621f4ce\" class=\"ne-p\"><span class=\"ne-text\">那么static-image又是啥呢？假如有个void foo()方法，用传统的AOT如jatoc，会把foo编译成二进制，而static-image会把foo编译成二进制，</span><strong><span class=\"ne-text\">同时</span></strong><span class=\"ne-text\">再带上语言运行时（比如GC、线程模型等），最终得到一个“</span><strong><span class=\"ne-text\">闭合的二进制世界</span></strong><span class=\"ne-text\">”。static-image其实就是更广义的AOT。</span></p><p id=\"uf8e96500\" class=\"ne-p\"><span class=\"ne-text\">所以不要悲观，OpenJDK和GraalVM虽然都废弃了传统的AOT编译，但是两者都</span><strong><span class=\"ne-text\">不约而同</span></strong><span class=\"ne-text\">的探索static-image技术，OpenJDK这边是Leyden，GraalVM那边是</span><a href=\"https://www.zhihu.com/question/274042223/answer/1270829173\" data-href=\"https://www.zhihu.com/question/274042223/answer/1270829173\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">SubstrateVM</span></a><span class=\"ne-text\">。不过我得吐槽一下。。Leyden雷声大雨点小，截至目前(2021.8.12)还没有实际的动静，GraalVM那边的SubstrateVM倒是做的风生水起。</span></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u86442191\" id=\"u86442191\"><span data-lake-id=\"u3dcc013a\" id=\"u3dcc013a\" class=\"lake-fontsize-16\" style=\"color: rgb(51, 51, 51)\">JIT的Profile神器JITWatch </span></p><p data-lake-id=\"u3adc20a2\" id=\"u3adc20a2\"><a href=\"https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ\" target=\"_blank\" data-lake-id=\"u6d33bf8c\" id=\"u6d33bf8c\"><span data-lake-id=\"u07940eab\" id=\"u07940eab\">https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ</span></a></p><p data-lake-id=\"u319a547c\" id=\"u319a547c\"><span data-lake-id=\"ud200d357\" id=\"ud200d357\" class=\"lake-fontsize-16\" style=\"color: rgb(51, 51, 51)\">​</span><br></p><p data-lake-id=\"u11c8637c\" id=\"u11c8637c\"><span data-lake-id=\"uf0ad5db9\" id=\"uf0ad5db9\">作者：kelthuzadx<br /></span><span data-lake-id=\"u9ccd3a83\" id=\"u9ccd3a83\">链接：https://www.zhihu.com/question/478887438/answer/2054092011<br /></span><span data-lake-id=\"u996c1129\" id=\"u996c1129\">来源：知乎<br /></span><span data-lake-id=\"u3db1108d\" id=\"u3db1108d\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br /><br /><br /></span></p><p data-lake-id=\"u040401ce\" id=\"u040401ce\"><span data-lake-id=\"ued7ca6a7\" id=\"ued7ca6a7\">AOT编译即jaotc，可以将Java代码编成二进制，然后虚拟机直接用这些二进制，而不是在运行时花费时间用JIT编译。JDK10还尝试使用AOT背后的Graal代替HotSpot VM原有的C2 JIT编译器。但是它们两个的探索不算成功，首先用的不多，成功实践不多，关于这点可以问问自己有没有听过或者实际用过jaotc或者Graal JIT。</span></p><p data-lake-id=\"ua9a700ce\" id=\"ua9a700ce\"><span data-lake-id=\"u4bd920ff\" id=\"u4bd920ff\">其次Graal主要是Oracle Labs那边做开发，他们有一个</span><a href=\"https://link.zhihu.com/?target=https%3A//github.com/oracle/graal\" target=\"_blank\" data-lake-id=\"u4d10dcc7\" id=\"u4d10dcc7\"><span data-lake-id=\"u8b34c60e\" id=\"u8b34c60e\">仓库</span></a><span data-lake-id=\"u8f1c11cd\" id=\"u8f1c11cd\">，相当于它们是JDK里面的Graal和AOT的上游，但是它们在JDK中的测试挂了没人修，也不太活跃，对JDK的代码演进会照成一定的困扰（小道消息可能还有派系斗争。。），基于总总原因，OpenJDK社区决定在JDK17中移除它们，由Oracle Labs在独立的仓库中维护。所以，</span><strong><span data-lake-id=\"ud20a7cfb\" id=\"ud20a7cfb\">OpenJDK社区确实已经彻底放弃基于Graal的AOT了，</span></strong><span data-lake-id=\"u5fa11739\" id=\"u5fa11739\">但是彻底放弃AOT这个技术本身也不一定，没准哪天就有个基于C2的AOT呢：P.</span></p><p data-lake-id=\"u903d31ab\" id=\"u903d31ab\"><span data-lake-id=\"ufcc1579d\" id=\"ufcc1579d\">是不是听起来感觉还有救？反正还有Oracle Labs仓库的继续维护，不慌。</span></p><p data-lake-id=\"u7643e46f\" id=\"u7643e46f\"><span data-lake-id=\"u0058221e\" id=\"u0058221e\">相关用户还是要慌一下，因为Oracle Labs也在它们的主线上</span><a href=\"https://link.zhihu.com/?target=https%3A//github.com/oracle/graal/commit/2850e2ea3d47f0ac81a740f4ac48bf0e27135a11\" target=\"_blank\" data-lake-id=\"ucfa22ca6\" id=\"ucfa22ca6\"><span data-lake-id=\"uf9340c01\" id=\"uf9340c01\">移除了AOT</span></a><span data-lake-id=\"u89334c1b\" id=\"u89334c1b\">，我们未来可能要永远告别jaotc了。至于Graal短时间内肯定还是有的，因为它是GraalVM安身立命的基础。</span></p><p data-lake-id=\"u15e87a0d\" id=\"u15e87a0d\"><span data-lake-id=\"u217e9149\" id=\"u217e9149\">但是对于函数计算、Serverless甚至更广阔的应用场景，快速启动、内存低占用这些仍然是刚需，我们仍然需要解决。</span></p><p data-lake-id=\"ud8af010b\" id=\"ud8af010b\"><span data-lake-id=\"u3ac2997f\" id=\"u3ac2997f\">---- 探索1</span></p><p data-lake-id=\"ua3798413\" id=\"ua3798413\"><span data-lake-id=\"u46132e8e\" id=\"u46132e8e\">很多应用启动性能Profiling显示JVM启动慢的主要原因是类的</span><strong><span data-lake-id=\"u1cb7546a\" id=\"u1cb7546a\">加载-链接-初始化</span></strong><span data-lake-id=\"uc43b5d4a\" id=\"uc43b5d4a\">这一套，它们占据了启动的绝大部分时间，JVM本身的启动是非常快的（-Xlog:startuptime)。对于类的三部曲，一个解决方案是</span><a href=\"https://link.zhihu.com/?target=http%3A//openjdk.java.net/jeps/310\" target=\"_blank\" data-lake-id=\"u13c1b8f7\" id=\"u13c1b8f7\"><span data-lake-id=\"u10614644\" id=\"u10614644\">AppCDS</span></a><span data-lake-id=\"ue9d667c0\" id=\"ue9d667c0\">技术，OpenJDK对它做了很多工作，阿里JDK也对快速启动和AppCDS做了大量改造（</span><a href=\"https://zhuanlan.zhihu.com/p/392773209\" target=\"_blank\" data-lake-id=\"u36a04a41\" id=\"u36a04a41\"><span data-lake-id=\"ufdf80a63\" id=\"ufdf80a63\">所以，亲，看机会吗？</span></a><span data-lake-id=\"u1c834542\" id=\"u1c834542\">）</span></p><p data-lake-id=\"uf8e0a294\" id=\"uf8e0a294\"><span data-lake-id=\"u918a5cec\" id=\"u918a5cec\">回到技术本身。JVM之所以要加载-链接-初始化一个类，目的是让用户写的一个类Foo，在虚拟机里面能有个数据结构（即InstanceKlass）对应，这样虚拟机就可以通过它知道Foo实现了哪些接口，父类是谁等等。那么只要Foo类的字节码没有变过，我们跑多次应用，最终JVM里面的InstanceKlass就可以是一样的。这就是AppCDS的洞察，它可以让应用先 模拟 跑一次，把JVM里面已经走过加载-链接-初始化流程的InstanceKlass都存放到App.jsa文件里面，第二次 实际 运行时直接使用读App.jsa，拿到已经准备就绪的InstanceKlass直接用，省去了加载-链接的开销。</span></p><p data-lake-id=\"ue2df4451\" id=\"ue2df4451\"><span data-lake-id=\"u26a2d738\" id=\"u26a2d738\">---- 探索2</span></p><p data-lake-id=\"uc3210ca7\" id=\"uc3210ca7\"><span data-lake-id=\"u2f74d940\" id=\"u2f74d940\">注意AppCDS不能跳过初始化这个过程，这个过程需要另一项依赖AppCDS和G1的技术，即Pre-initialization提前初始化来部分解决。Pre-initialization是比较前沿的技术，也处于探索期间，最新的工作可以使这个技术适用于非G1的垃圾回收器。</span></p><p data-lake-id=\"u156667e1\" id=\"u156667e1\"><span data-lake-id=\"u3c0b59bb\" id=\"u3c0b59bb\">OpenJDK还针对AppCDS做了非常多的工作，比如DynamicAppCDS、AppCDS for Lambda/Proxy Classes，就不展开了。</span></p><p data-lake-id=\"u3d0b24e3\" id=\"u3d0b24e3\"><span data-lake-id=\"uc9e38d29\" id=\"uc9e38d29\">----探索3</span></p><p data-lake-id=\"u8d130106\" id=\"u8d130106\"><span data-lake-id=\"uf60337bb\" id=\"uf60337bb\">除了VM上面做功夫之外，Linux CRIU技术也不容忽视。CRIU的介绍我就贴一点官网的：CRIU可以冻结运行中的容器或者某个单独的应用，然后把它的状态保存到磁盘上， 然后下次运行时读取磁盘的数据恢复执行。</span><strong><span data-lake-id=\"u6d7ebfc4\" id=\"u6d7ebfc4\">理想情况下，</span></strong><span data-lake-id=\"ub85448d3\" id=\"ub85448d3\">应用程序是无感知的，它不知道被暂停过。</span></p><p data-lake-id=\"u68594828\" id=\"u68594828\"><span data-lake-id=\"u5d2c207f\" id=\"u5d2c207f\">OpenJDK也在积极探索，前一段时间Azul的一位开发者（为macOS M1提供JDK的那个男人）提议成立</span><a href=\"https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/discuss/2021-July/005862.html\" target=\"_blank\" data-lake-id=\"u6e4b7074\" id=\"u6e4b7074\"><span data-lake-id=\"u1639e57f\" id=\"u1639e57f\">CRaC项目</span></a><span data-lake-id=\"u0571f2c2\" id=\"u0571f2c2\">（JDK中需要花费大量努力的方向或者技术探索都会创建一个项目，而不是在主线，比如ZGC，VectorAPI，Valhalla），这个技术旨在探索如何让CRIU和JVM更好的协作。该项目目前还在广泛讨(che)论(pi)，参与者至少包括RedHat，Amazon，Azul。对于开发者，等就完事了。</span></p><p data-lake-id=\"u4703f68a\" id=\"u4703f68a\"><span data-lake-id=\"u6499804b\" id=\"u6499804b\">----探索4</span></p><p data-lake-id=\"u3e044c7a\" id=\"u3e044c7a\"><span data-lake-id=\"u9b8940fc\" id=\"u9b8940fc\">再补充一点。</span></p><p data-lake-id=\"uf410604a\" id=\"uf410604a\"><span data-lake-id=\"ue236d000\" id=\"ue236d000\">OpenJDK还有一个</span><a href=\"https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/announce/2020-May/000289.html\" target=\"_blank\" data-lake-id=\"u4636ba77\" id=\"u4636ba77\"><span data-lake-id=\"u48fe4c7b\" id=\"u48fe4c7b\">Leyden项目</span></a><span data-lake-id=\"uf8169a8f\" id=\"uf8169a8f\">，探索static-image技术，目标也是为了解决上面我们提到的Java启动慢、内存高占用等问题。</span></p><p data-lake-id=\"uf621f4ce\" id=\"uf621f4ce\"><span data-lake-id=\"ue91386c2\" id=\"ue91386c2\">那么static-image又是啥呢？假如有个void foo()方法，用传统的AOT如jatoc，会把foo编译成二进制，而static-image会把foo编译成二进制，</span><strong><span data-lake-id=\"uec80a6ae\" id=\"uec80a6ae\">同时</span></strong><span data-lake-id=\"u39df8889\" id=\"u39df8889\">再带上语言运行时（比如GC、线程模型等），最终得到一个“</span><strong><span data-lake-id=\"u1621d471\" id=\"u1621d471\">闭合的二进制世界</span></strong><span data-lake-id=\"uac842835\" id=\"uac842835\">”。static-image其实就是更广义的AOT。</span></p><p data-lake-id=\"uf8e96500\" id=\"uf8e96500\"><span data-lake-id=\"u2a80b005\" id=\"u2a80b005\">所以不要悲观，OpenJDK和GraalVM虽然都废弃了传统的AOT编译，但是两者都</span><strong><span data-lake-id=\"u6dfe41b0\" id=\"u6dfe41b0\">不约而同</span></strong><span data-lake-id=\"u98711db4\" id=\"u98711db4\">的探索static-image技术，OpenJDK这边是Leyden，GraalVM那边是</span><a href=\"https://www.zhihu.com/question/274042223/answer/1270829173\" target=\"_blank\" data-lake-id=\"uf539db13\" id=\"uf539db13\"><span data-lake-id=\"ucbb376f3\" id=\"ucbb376f3\">SubstrateVM</span></a><span data-lake-id=\"u56b00528\" id=\"u56b00528\">。不过我得吐槽一下。。Leyden雷声大雨点小，截至目前(2021.8.12)还没有实际的动静，GraalVM那边的SubstrateVM倒是做的风生水起。</span></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u86442191\" id=\"u86442191\"><span data-lake-id=\"u3dcc013a\" id=\"u3dcc013a\" class=\"lake-fontsize-16\" style=\"color: rgb(51, 51, 51)\">JIT的Profile神器JITWatch </span></p><p data-lake-id=\"u3adc20a2\" id=\"u3adc20a2\"><a href=\"https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ\" target=\"_blank\" data-lake-id=\"u6d33bf8c\" id=\"u6d33bf8c\"><span data-lake-id=\"u07940eab\" id=\"u07940eab\">https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ</span></a></p><p data-lake-id=\"u319a547c\" id=\"u319a547c\"><span data-lake-id=\"ud200d357\" id=\"ud200d357\" class=\"lake-fontsize-16\" style=\"color: rgb(51, 51, 51)\">​</span><br></p><p data-lake-id=\"u11c8637c\" id=\"u11c8637c\"><span data-lake-id=\"uf0ad5db9\" id=\"uf0ad5db9\">作者：kelthuzadx<br /></span><span data-lake-id=\"u9ccd3a83\" id=\"u9ccd3a83\">链接：https://www.zhihu.com/question/478887438/answer/2054092011<br /></span><span data-lake-id=\"u996c1129\" id=\"u996c1129\">来源：知乎<br /></span><span data-lake-id=\"u3db1108d\" id=\"u3db1108d\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br /><br /><br /></span></p><p data-lake-id=\"u040401ce\" id=\"u040401ce\"><span data-lake-id=\"ued7ca6a7\" id=\"ued7ca6a7\">AOT编译即jaotc，可以将Java代码编成二进制，然后虚拟机直接用这些二进制，而不是在运行时花费时间用JIT编译。JDK10还尝试使用AOT背后的Graal代替HotSpot VM原有的C2 JIT编译器。但是它们两个的探索不算成功，首先用的不多，成功实践不多，关于这点可以问问自己有没有听过或者实际用过jaotc或者Graal JIT。</span></p><p data-lake-id=\"ua9a700ce\" id=\"ua9a700ce\"><span data-lake-id=\"u4bd920ff\" id=\"u4bd920ff\">其次Graal主要是Oracle Labs那边做开发，他们有一个</span><a href=\"https://link.zhihu.com/?target=https%3A//github.com/oracle/graal\" target=\"_blank\" data-lake-id=\"u4d10dcc7\" id=\"u4d10dcc7\"><span data-lake-id=\"u8b34c60e\" id=\"u8b34c60e\">仓库</span></a><span data-lake-id=\"u8f1c11cd\" id=\"u8f1c11cd\">，相当于它们是JDK里面的Graal和AOT的上游，但是它们在JDK中的测试挂了没人修，也不太活跃，对JDK的代码演进会照成一定的困扰（小道消息可能还有派系斗争。。），基于总总原因，OpenJDK社区决定在JDK17中移除它们，由Oracle Labs在独立的仓库中维护。所以，</span><strong><span data-lake-id=\"ud20a7cfb\" id=\"ud20a7cfb\">OpenJDK社区确实已经彻底放弃基于Graal的AOT了，</span></strong><span data-lake-id=\"u5fa11739\" id=\"u5fa11739\">但是彻底放弃AOT这个技术本身也不一定，没准哪天就有个基于C2的AOT呢：P.</span></p><p data-lake-id=\"u903d31ab\" id=\"u903d31ab\"><span data-lake-id=\"ufcc1579d\" id=\"ufcc1579d\">是不是听起来感觉还有救？反正还有Oracle Labs仓库的继续维护，不慌。</span></p><p data-lake-id=\"u7643e46f\" id=\"u7643e46f\"><span data-lake-id=\"u0058221e\" id=\"u0058221e\">相关用户还是要慌一下，因为Oracle Labs也在它们的主线上</span><a href=\"https://link.zhihu.com/?target=https%3A//github.com/oracle/graal/commit/2850e2ea3d47f0ac81a740f4ac48bf0e27135a11\" target=\"_blank\" data-lake-id=\"ucfa22ca6\" id=\"ucfa22ca6\"><span data-lake-id=\"uf9340c01\" id=\"uf9340c01\">移除了AOT</span></a><span data-lake-id=\"u89334c1b\" id=\"u89334c1b\">，我们未来可能要永远告别jaotc了。至于Graal短时间内肯定还是有的，因为它是GraalVM安身立命的基础。</span></p><p data-lake-id=\"u15e87a0d\" id=\"u15e87a0d\"><span data-lake-id=\"u217e9149\" id=\"u217e9149\">但是对于函数计算、Serverless甚至更广阔的应用场景，快速启动、内存低占用这些仍然是刚需，我们仍然需要解决。</span></p><p data-lake-id=\"ud8af010b\" id=\"ud8af010b\"><span data-lake-id=\"u3ac2997f\" id=\"u3ac2997f\">---- 探索1</span></p><p data-lake-id=\"ua3798413\" id=\"ua3798413\"><span data-lake-id=\"u46132e8e\" id=\"u46132e8e\">很多应用启动性能Profiling显示JVM启动慢的主要原因是类的</span><strong><span data-lake-id=\"u1cb7546a\" id=\"u1cb7546a\">加载-链接-初始化</span></strong><span data-lake-id=\"uc43b5d4a\" id=\"uc43b5d4a\">这一套，它们占据了启动的绝大部分时间，JVM本身的启动是非常快的（-Xlog:startuptime)。对于类的三部曲，一个解决方案是</span><a href=\"https://link.zhihu.com/?target=http%3A//openjdk.java.net/jeps/310\" target=\"_blank\" data-lake-id=\"u13c1b8f7\" id=\"u13c1b8f7\"><span data-lake-id=\"u10614644\" id=\"u10614644\">AppCDS</span></a><span data-lake-id=\"ue9d667c0\" id=\"ue9d667c0\">技术，OpenJDK对它做了很多工作，阿里JDK也对快速启动和AppCDS做了大量改造（</span><a href=\"https://zhuanlan.zhihu.com/p/392773209\" target=\"_blank\" data-lake-id=\"u36a04a41\" id=\"u36a04a41\"><span data-lake-id=\"ufdf80a63\" id=\"ufdf80a63\">所以，亲，看机会吗？</span></a><span data-lake-id=\"u1c834542\" id=\"u1c834542\">）</span></p><p data-lake-id=\"uf8e0a294\" id=\"uf8e0a294\"><span data-lake-id=\"u918a5cec\" id=\"u918a5cec\">回到技术本身。JVM之所以要加载-链接-初始化一个类，目的是让用户写的一个类Foo，在虚拟机里面能有个数据结构（即InstanceKlass）对应，这样虚拟机就可以通过它知道Foo实现了哪些接口，父类是谁等等。那么只要Foo类的字节码没有变过，我们跑多次应用，最终JVM里面的InstanceKlass就可以是一样的。这就是AppCDS的洞察，它可以让应用先 模拟 跑一次，把JVM里面已经走过加载-链接-初始化流程的InstanceKlass都存放到App.jsa文件里面，第二次 实际 运行时直接使用读App.jsa，拿到已经准备就绪的InstanceKlass直接用，省去了加载-链接的开销。</span></p><p data-lake-id=\"ue2df4451\" id=\"ue2df4451\"><span data-lake-id=\"u26a2d738\" id=\"u26a2d738\">---- 探索2</span></p><p data-lake-id=\"uc3210ca7\" id=\"uc3210ca7\"><span data-lake-id=\"u2f74d940\" id=\"u2f74d940\">注意AppCDS不能跳过初始化这个过程，这个过程需要另一项依赖AppCDS和G1的技术，即Pre-initialization提前初始化来部分解决。Pre-initialization是比较前沿的技术，也处于探索期间，最新的工作可以使这个技术适用于非G1的垃圾回收器。</span></p><p data-lake-id=\"u156667e1\" id=\"u156667e1\"><span data-lake-id=\"u3c0b59bb\" id=\"u3c0b59bb\">OpenJDK还针对AppCDS做了非常多的工作，比如DynamicAppCDS、AppCDS for Lambda/Proxy Classes，就不展开了。</span></p><p data-lake-id=\"u3d0b24e3\" id=\"u3d0b24e3\"><span data-lake-id=\"uc9e38d29\" id=\"uc9e38d29\">----探索3</span></p><p data-lake-id=\"u8d130106\" id=\"u8d130106\"><span data-lake-id=\"uf60337bb\" id=\"uf60337bb\">除了VM上面做功夫之外，Linux CRIU技术也不容忽视。CRIU的介绍我就贴一点官网的：CRIU可以冻结运行中的容器或者某个单独的应用，然后把它的状态保存到磁盘上， 然后下次运行时读取磁盘的数据恢复执行。</span><strong><span data-lake-id=\"u6d7ebfc4\" id=\"u6d7ebfc4\">理想情况下，</span></strong><span data-lake-id=\"ub85448d3\" id=\"ub85448d3\">应用程序是无感知的，它不知道被暂停过。</span></p><p data-lake-id=\"u68594828\" id=\"u68594828\"><span data-lake-id=\"u5d2c207f\" id=\"u5d2c207f\">OpenJDK也在积极探索，前一段时间Azul的一位开发者（为macOS M1提供JDK的那个男人）提议成立</span><a href=\"https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/discuss/2021-July/005862.html\" target=\"_blank\" data-lake-id=\"u6e4b7074\" id=\"u6e4b7074\"><span data-lake-id=\"u1639e57f\" id=\"u1639e57f\">CRaC项目</span></a><span data-lake-id=\"u0571f2c2\" id=\"u0571f2c2\">（JDK中需要花费大量努力的方向或者技术探索都会创建一个项目，而不是在主线，比如ZGC，VectorAPI，Valhalla），这个技术旨在探索如何让CRIU和JVM更好的协作。该项目目前还在广泛讨(che)论(pi)，参与者至少包括RedHat，Amazon，Azul。对于开发者，等就完事了。</span></p><p data-lake-id=\"u4703f68a\" id=\"u4703f68a\"><span data-lake-id=\"u6499804b\" id=\"u6499804b\">----探索4</span></p><p data-lake-id=\"u3e044c7a\" id=\"u3e044c7a\"><span data-lake-id=\"u9b8940fc\" id=\"u9b8940fc\">再补充一点。</span></p><p data-lake-id=\"uf410604a\" id=\"uf410604a\"><span data-lake-id=\"ue236d000\" id=\"ue236d000\">OpenJDK还有一个</span><a href=\"https://link.zhihu.com/?target=https%3A//mail.openjdk.java.net/pipermail/announce/2020-May/000289.html\" target=\"_blank\" data-lake-id=\"u4636ba77\" id=\"u4636ba77\"><span data-lake-id=\"u48fe4c7b\" id=\"u48fe4c7b\">Leyden项目</span></a><span data-lake-id=\"uf8169a8f\" id=\"uf8169a8f\">，探索static-image技术，目标也是为了解决上面我们提到的Java启动慢、内存高占用等问题。</span></p><p data-lake-id=\"uf621f4ce\" id=\"uf621f4ce\"><span data-lake-id=\"ue91386c2\" id=\"ue91386c2\">那么static-image又是啥呢？假如有个void foo()方法，用传统的AOT如jatoc，会把foo编译成二进制，而static-image会把foo编译成二进制，</span><strong><span data-lake-id=\"uec80a6ae\" id=\"uec80a6ae\">同时</span></strong><span data-lake-id=\"u39df8889\" id=\"u39df8889\">再带上语言运行时（比如GC、线程模型等），最终得到一个“</span><strong><span data-lake-id=\"u1621d471\" id=\"u1621d471\">闭合的二进制世界</span></strong><span data-lake-id=\"uac842835\" id=\"uac842835\">”。static-image其实就是更广义的AOT。</span></p><p data-lake-id=\"uf8e96500\" id=\"uf8e96500\"><span data-lake-id=\"u2a80b005\" id=\"u2a80b005\">所以不要悲观，OpenJDK和GraalVM虽然都废弃了传统的AOT编译，但是两者都</span><strong><span data-lake-id=\"u6dfe41b0\" id=\"u6dfe41b0\">不约而同</span></strong><span data-lake-id=\"u98711db4\" id=\"u98711db4\">的探索static-image技术，OpenJDK这边是Leyden，GraalVM那边是</span><a href=\"https://www.zhihu.com/question/274042223/answer/1270829173\" target=\"_blank\" data-lake-id=\"uf539db13\" id=\"uf539db13\"><span data-lake-id=\"ucbb376f3\" id=\"ucbb376f3\">SubstrateVM</span></a><span data-lake-id=\"u56b00528\" id=\"u56b00528\">。不过我得吐槽一下。。Leyden雷声大雨点小，截至目前(2021.8.12)还没有实际的动静，GraalVM那边的SubstrateVM倒是做的风生水起。</span></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-09-26T03:41:48.000Z",
    "deleted_at": null,
    "created_at": "2021-09-24T06:14:08.000Z",
    "updated_at": "2021-11-16T06:52:06.000Z",
    "published_at": "2021-09-26T03:41:48.000Z",
    "first_published_at": "2021-09-26T03:37:11.000Z",
    "word_count": 1482,
    "cover": null,
    "description": "JIT的Profile神器JITWatch https://mp.weixin.qq.com/s/1r2NtTgsI63G_ICJMx6XxQ作者：kelthuzadx链接：https://www.zhihu.com/question/478887438/answer/2054092011来源...",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 53579351,
    "slug": "iphtyg",
    "title": "稳定性",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "\n<br />扩展性  （架构与业务能力）<br />​\n\n可运营&高性能  <br />​\n\n​<br />\n",
    "body_draft": "\n<br />扩展性  （架构与业务能力）<br />​\n\n可运营&高性能  <br />​\n\n​<br />\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"ub7f0b837\" class=\"ne-p\"><br></p><p id=\"u897cc13c\" class=\"ne-p\"><span class=\"ne-text\">扩展性  （架构与业务能力）</span></p><p id=\"ue3b983cb\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u964f4780\" class=\"ne-p\"><span class=\"ne-text\">可运营&amp;高性能  </span></p><p id=\"u2acd25e2\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u87803965\" class=\"ne-p\"><span class=\"ne-text\"></span></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"ub7f0b837\" id=\"ub7f0b837\"><br></p><p data-lake-id=\"u897cc13c\" id=\"u897cc13c\"><span data-lake-id=\"ub6346bb1\" id=\"ub6346bb1\">扩展性  （架构与业务能力）</span></p><p data-lake-id=\"ue3b983cb\" id=\"ue3b983cb\"><span data-lake-id=\"u09801804\" id=\"u09801804\">​</span><br></p><p data-lake-id=\"u964f4780\" id=\"u964f4780\"><span data-lake-id=\"u65878adf\" id=\"u65878adf\">可运营&amp;高性能  </span></p><p data-lake-id=\"u2acd25e2\" id=\"u2acd25e2\"><span data-lake-id=\"u361e4809\" id=\"u361e4809\">​</span><br></p><p data-lake-id=\"u87803965\" id=\"u87803965\"><span data-lake-id=\"ue3092c2f\" id=\"ue3092c2f\">​</span><br></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"ub7f0b837\" id=\"ub7f0b837\"><br></p><p data-lake-id=\"u897cc13c\" id=\"u897cc13c\"><span data-lake-id=\"ub6346bb1\" id=\"ub6346bb1\">扩展性  （架构与业务能力）</span></p><p data-lake-id=\"ue3b983cb\" id=\"ue3b983cb\"><span data-lake-id=\"u09801804\" id=\"u09801804\">​</span><br></p><p data-lake-id=\"u964f4780\" id=\"u964f4780\"><span data-lake-id=\"u65878adf\" id=\"u65878adf\">可运营&amp;高性能  </span></p><p data-lake-id=\"u2acd25e2\" id=\"u2acd25e2\"><span data-lake-id=\"u361e4809\" id=\"u361e4809\">​</span><br></p><p data-lake-id=\"u87803965\" id=\"u87803965\"><span data-lake-id=\"ue3092c2f\" id=\"ue3092c2f\">​</span><br></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-09-16T10:46:20.000Z",
    "deleted_at": null,
    "created_at": "2021-09-16T10:45:05.000Z",
    "updated_at": "2021-11-16T06:52:06.000Z",
    "published_at": "2021-09-16T10:46:20.000Z",
    "first_published_at": "2021-09-16T10:45:48.000Z",
    "word_count": 19,
    "cover": null,
    "description": "扩展性  （架构与业务能力）可运营&高性能",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 53211656,
    "slug": "gpyhoq",
    "title": "缓存的方案",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "\n",
    "body_draft": "\n",
    "body_html": "<!doctype html><p><br /></p>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p><br /></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p><br /></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-09-12T10:46:06.000Z",
    "deleted_at": null,
    "created_at": "2021-09-12T10:46:01.000Z",
    "updated_at": "2021-11-16T11:34:53.000Z",
    "published_at": "2021-09-12T10:46:06.000Z",
    "first_published_at": "2021-09-12T10:46:06.000Z",
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 53211573,
    "slug": "fg1q5y",
    "title": "微服务",
    "book_id": 20817242,
    "book": {
      "id": 20817242,
      "type": "Book",
      "slug": "blog",
      "name": "博客",
      "user_id": 86384,
      "description": "",
      "creator_id": 86384,
      "public": 1,
      "items_count": 11,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-11-18T05:42:52.567Z",
      "updated_at": "2021-11-18T05:42:52.000Z",
      "created_at": "2021-09-12T10:16:08.000Z",
      "namespace": "54iter/blog",
      "user": {
        "id": 86384,
        "type": "User",
        "login": "54iter",
        "name": "仰望星空",
        "description": "工程师",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
        "books_count": 7,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 4,
        "created_at": "2018-01-11T03:15:45.000Z",
        "updated_at": "2021-11-18T05:37:49.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 86384,
    "creator": {
      "id": 86384,
      "type": "User",
      "login": "54iter",
      "name": "仰望星空",
      "description": "工程师",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/86384/1630992204221-avatar/b960e228-5008-43ab-a92d-b5935f89a821.png",
      "books_count": 7,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 4,
      "created_at": "2018-01-11T03:15:45.000Z",
      "updated_at": "2021-11-18T05:37:49.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "不能把系统问题（用微服务解决系统可用性）。 带给业务\n",
    "body_draft": "不能把系统问题（用微服务解决系统可用性）。 带给业务\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u16c63f78\" class=\"ne-p\"><span class=\"ne-text\">不能把系统问题（用微服务解决系统可用性）。 带给业务</span></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u16c63f78\" id=\"u16c63f78\"><span data-lake-id=\"ue5b34698\" id=\"ue5b34698\">不能把系统问题（用微服务解决系统可用性）。 带给业务</span></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u16c63f78\" id=\"u16c63f78\"><span data-lake-id=\"ue5b34698\" id=\"ue5b34698\">不能把系统问题（用微服务解决系统可用性）。 带给业务</span></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-09-12T10:43:17.000Z",
    "deleted_at": null,
    "created_at": "2021-09-12T10:42:53.000Z",
    "updated_at": "2021-11-16T06:52:06.000Z",
    "published_at": "2021-09-12T10:43:17.000Z",
    "first_published_at": "2021-09-12T10:43:17.000Z",
    "word_count": 25,
    "cover": null,
    "description": "不能把系统问题（用微服务解决系统可用性）。 带给业务",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  }
]